---
title: Linux Netfilter 提权漏洞 (CVE-2023-4015) 复现与利用分析
date: 2026-02-07 10:20:00
categories:
  - CVE
tags:
---

# Linux Netfilter 提权漏洞 (CVE-2023-4015) 复现与利用分析

# 一. 综合描述

​	CVE-2023-4015 揭示了 Linux 内核 Netfilter (nf_tables) 子系统中一个极为精妙的逻辑设计缺陷。该漏洞的核心在于 nf_tables 在处理复杂的 Netlink 批处理事务时，未能正确维护对象在异常回滚过程中的引用状态。具体而言，当攻击者构造一个包含特定 immediate 表达式（用于实现跳转逻辑）的规则，并故意在同一事务中触发后续错误的路径时，内核会因为逻辑重叠而对同一个 nft_chain 对象执行两次去激活（Deactivate）操作。这种“双重去激活”直接导致了对象的引用计数（use count）异常归零，从而触发提前释放。

​	由于内核在回滚（Abort）阶段的清理逻辑不够严谨，虽然对象在内存中已被释放回 SLUB 分配器，但先前建立的规则索引中依然保留着指向该内存地址的悬垂指针。这意味着攻击者可以通过后续的堆喷射（Heap Spraying）技术，将恶意构造的数据填入该内存坑位，从而实现类型混淆。在拥有 CAP_NET_ADMIN 权限的前提下（非特权用户可通过用户命名空间轻松获得此权限），该漏洞能够绕过 KASLR 等现代防御机制，最终实现从普通用户到 Root 权限的本地提权。这个漏洞不仅展示了逻辑漏洞在复杂事务模型中的隐蔽性，也再次证明了引用计数管理在内核安全中的关键地位。

# 二. 背景知识介绍

![nf_objects_desc](images/CVE-2023-4015/nf_objects_desc.png)

### 2.1 Netfilter 核心架构

​	Netfilter 的 nf_tables 模块构建了一个高度层级化的对象管理体系。其核心对象包括 Table（表）、Chain（链）、Rule（规则）以及 Set（集合）和 Element（元素）。Table 作为最顶层的容器，包含了所有的链；Chain 则是规则的集合，通常与内核协议栈的钩子（Hook）点绑定；Rule 包含了具体的匹配表达式（Expression），负责实际的数据包处理逻辑。Set 和 Element 则提供了一种高效的键值匹配机制，允许规则在不线性遍历的情况下处理大量的 IP 地址或端口。这些对象之间通过引用计数相互链接，例如一个规则引用了一个跳转链，那么该链的引用计数就会增加，只有当所有引用都消失时，对象才能被安全释放。

![netfilter_arch](images/CVE-2023-4015/netfilter_arch.png)

### 2.2 RCU 无锁机制与宽限期检测

​	在 Linux 内核网络子系统中，为了兼顾高并发下的读取性能与数据一致性，广泛采用了 RCU（Read-Copy-Update）机制。RCU 的核心哲学在于“读者优先”，它允许多个读者在没有任何锁开销的情况下并发访问数据，而写者则通过“复制-修改-更新”的方式进行操作。当写者完成更新并切换全局指针后，旧的数据副本并不能立即释放，因为可能仍有读者正在引用它。此时，旧副本进入所谓的“宽限期”（Grace Period）。

​	内核判断 RCU 读操作结束的标准是基于“静止状态”的检测。通过 `rcu_read_lock()` 和 `rcu_read_unlock()` 标记的临界区内禁止发生进程调度。因此，当每一个 CPU 都至少经历了一次上下文切换（Context Switch）或进入了 CPU 空闲状态（Idle），即意味着所有在宽限期开始前进入临界区的读者都已退出了读操作。此时，系统认为该 CPU 度过了一个“静止状态”（Quiescent State）。当全系统所有 CPU 都经历了静止状态，内核便可安全地物理释放旧内存。在 CVE-2023-4015 的利用中，理解逻辑释放（引用计数归零）与物理释放（宽限期结束）之间的时间差至关重要。

### 2.3 nf_tables 事务处理模型

​	为了保证规则更新的原子性和一致性，nf_tables 引入了基于 Netlink 的批处理事务处理逻辑（nft_trans）。这一机制模仿了数据库的“两阶段提交”：在 Preparation Phase（准备阶段），内核会解析用户发送的 Batch 消息，分配资源并验证参数，此时所有的更改都被记录在事务链表中而未真正生效；如果该阶段通过，则进入 Commit Phase（提交阶段）将更改原子性地应用到全局状态。

​	如果中间任何一步出错，则会触发 Abort Phase（中止阶段），内核将遍历事务链表，按照相反的顺序撤销所有已记录的操作。这种事务处理在内核中是序列化的，通常在进程的上下文中执行，但对象的物理释放往往会延迟到 RCU 回调或特定的系统工作队列（workqueue）中异步完成。这种同步更新状态与异步释放内存的设计，正是 CVE-2023-4015 能够通过并发竞争和逻辑交织制造出 UAF 场景的架构基础。

![nft_transaction](images/CVE-2023-4015/nft_transaction.png)

# 三. 漏洞原理分析

​	漏洞的深层诱因源于 `nf_tables_newrule` 函数在处理新规则创建失败时的错误清理路径，与后续事务中止（Abort）路径之间发生的逻辑碰撞。在内核解析 Netlink 消息创建规则的过程中，如果遇到参数非法或内存不足等错误，系统会立即跳转至错误处理标签 `err_release_rule`。在此处，内核会显式调用 `nft_rule_expr_deactivate` 并携带 `NFT_TRANS_PREPARE_ERROR` 标志，旨在撤销当前规则中已经部分解析的表达式对其他对象的引用。对于 `immediate` 类型的表达式，这不仅意味着要递减目标跳转链的引用计数，还会通过 `nf_tables_unbind_chain` 解除该链与当前规则的绑定关系。

```c
err_release_rule:
  // 第一次去激活：由 nf_tables_newrule 直接触发
  nft_rule_expr_deactivate(&ctx, rule, NFT_TRANS_PREPARE_ERROR);
  nf_tables_rule_destroy(&ctx, rule);
```

​	然而，由于该事务已经标记为失败，内核在完成局部的错误处理后，仍会不可避免地触发全局的 `__nf_tables_abort`。在该函数遍历事务链表处理 `NFT_MSG_NEWRULE` 类型的操作时，逻辑出现了致命偏差。由于目标链在之前的错误处理路径中已经执行了 `unbind` 操作，导致 `nft_trans_rule_bound` 的状态检查失效。于是，回滚逻辑会再一次、也是第二次对该规则调用 `nft_rule_expr_deactivate`，此时的阶段标志被设为 `NFT_TRANS_ABORT`。

```c
case NFT_MSG_NEWRULE:
  if (nft_trans_rule_bound(trans)) { // 状态位已在 Preparation 错误路径中被污染，导致检查跳过
    nft_trans_destroy(trans);
    break;
  }
  // 第二次去激活：导致目标 Chain 的引用计数产生 Underflow
  nft_rule_expr_deactivate(&trans->ctx, nft_trans_rule(trans), NFT_TRANS_ABORT);
```

​	这一系列动作导致目标跳转链（Victim Chain）的引用计数经历了两次连续的递减。如果我们构造一个初始引用计数为 1 的链，并在一次恶意事务中先通过规则引用它再人为制造错误，该链的引用计数会先降至 1（Preparation 报错），随后在 Abort 阶段降至 0。此时内核错误地认为该链已无人使用，从而将其物理释放。然而，我们的 `Base` 链中依然保留着指向这个已释放地址的规则索引，这就形成了一个稳定的 Use-After-Free 漏洞点。

# 四. 漏洞利用过程详解

​	在成功制造出 UAF 场景后，利用过程转向了精密的内存布局控制。首先是 KASLR 绕过与堆地址泄露。我们利用了 `nft_immediate_expr` 在 dump 时的行为：当内核通过 `GETRULE` 命令向用户态返回规则信息时，`nft_verdict_dump` 会试图读取并打印 `chain->name` 指向的字符串。通过精确控制 Victim 链名称的长度（如 9-16 字节），使其落入 `kmalloc-cg-16` 内存池。在链被释放后，我们立即喷射大量的 `counter` 表达式对象（恰好占用 16 字节），利用 SLUB 分配器的后进先出（LIFO）特性覆盖 Victim 链的名称指针。由于表达式对象的头部存放的是其 `ops` 函数指针表地址，内核在执行 dump 时会误将该指针地址作为字符串读出，从而帮助我们计算出内核基址。同理，通过喷射包含链表指针的 `nft_rule` 对象并读取其 `list.next` 字段，我们能够稳定获取内核堆块的绝对地址。

​	接下来是劫持 RIP 的关键步骤。我们盯上了 `nft_do_chain` 函数中对 `chain->blob_gen_0` 的引用。这是一个存储预编译规则数据的内存块，通常被分配在 `kmalloc-cg-64`。我们通过 UAF 释放该 blob 后，利用 `nft_table` 的 `udata` 功能（用户控制的数据区）喷射恶意数据将其重新填充。通过构造虚假的 `nft_expr` 结构，我们将 `ops` 指针指向一个预先布置在堆上的伪造函数表。当网络数据包经过该 Chain 触发评估逻辑时，内核会调用 `expr_call_ops_eval`，进而执行我们伪造的 `eval` 指针，从而彻底接管控制流。

​	最终的提权通过一段精心设计的双重 ROP 载荷实现。由于单个 `udata` 或规则数据区的空间限制，我们将 ROP 链拆分为两部分，分别存放在已泄露地址的 `kmalloc-cg-96` 和 `kmalloc-cg-192` 块中。第一段载荷利用 `PUSH RSI; JMP QWORD PTR [RSI + 0xF]` 指令配合栈迁移 gadget，将 `RSP` 指向我们的堆区；随后通过 `commit_creds(prepare_kernel_cred(0))` 提升权限。为了实现容器逃逸，第二段载荷会调用 `find_task_by_vpid(1)` 获取 init 进程的上下文，并通过 `switch_task_namespaces` 将当前进程切换回系统的初始命名空间。最后，利用 KPTI 绕过跳板（trampoline）安全返回用户态，从而在被攻击的系统上获得一个拥有完整 Root 权限的交互式 Shell。这种从微小引用计数错误到完整系统控制的演变，生动地展示了内核安全博弈的深度与复杂性。

# 五. 总结

​	CVE-2023-4015 的复现过程展示了内核利用的艺术：一个微小的事务回滚逻辑缺陷，通过精密的堆布局控制与类型混淆，一步步转化为任意读写，最终实现完全的权限提升。这不仅是对 Netfilter 复杂性的警示，也是对内核开发者在处理原子操作与对象生命周期时必须保持极度严谨的有力证明。
