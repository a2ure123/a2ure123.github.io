---
title: Linux Netfilter 提权漏洞 (CVE-2023-4015) 复现与利用分析
date: 2026-02-07 10:20:00
categories:
  - CVE
tags:
---

# Linux Netfilter 提权漏洞 (CVE-2023-4015) 复现与利用分析

# 一. 漏洞背景

​	CVE-2023-4015 是一个发生在 Linux 内核网络子系统 Netfilter 模块中的经典逻辑漏洞。该漏洞源于 nf_tables 在处理事务异常回滚（Abort）时的逻辑缺陷。通过精心构造的 Netlink 消息，攻击者可以欺骗内核对同一个对象（通常是 nft_chain）进行两次“去激活”操作，从而人为制造出一个 Use-After-Free (UAF) 场景。

​	在拥有 `CAP_NET_ADMIN` 权限（即使是在非特权用户命名空间内）的情况下，攻击者可以利用此 UAF 漏洞实现本地提权。该漏洞影响多个 Linux 内核版本，是一个极具研究价值的内核漏洞案例。

### 1.1 Netfilter 事务机制

​	nf_tables 采用了一套类似数据库的“两阶段提交”机制来保证规则集更新的原子性：
1.  **Preparation Phase**：分配资源，检查参数合法性。
2.  **Commit/Abort Phase**：如果 Preparation 成功则提交更改；如果中间任何一步失败，则触发 Abort 回滚所有操作。

# 二. 漏洞原理

​	漏洞的根源在于 `nf_tables_newrule` 函数在错误处理逻辑与事务回滚逻辑上的重叠，导致了“双重去激活”（Double Deactivate）。

### 2.1 漏洞触发流程

1.  **错误处理阶段**：当创建一个包含 `immediate` 表达式（用于跳转到另一个链）的新规则时，如果过程中发生错误（如参数校验失败），内核会调用 `nft_rule_expr_deactivate` 清理表达式。此时，目标链的引用计数会递减，并执行解绑操作。
2.  **事务回滚阶段**：由于错误触发，内核随后进入 `__nf_tables_abort` 函数。在处理 `NFT_MSG_NEWRULE` 事务时，由于之前的清理逻辑并未完整更新事务状态，内核会再次对该规则调用 `nft_rule_expr_deactivate`。

### 2.2 核心代码逻辑分析

​	在 `nf_tables_newrule` 报错跳转到 `err_release_rule` 后：
```c
// 第一次去激活
nft_rule_expr_deactivate(&ctx, rule, NFT_TRANS_PREPARE_ERROR);
```
​	而在 `__nf_tables_abort` 中：
```c
// 第二次去激活
nft_rule_expr_deactivate(&ctx, nft_trans_rule(trans), NFT_TRANS_ABORT);
```
​	这导致同一个 Chain 的引用计数被递减两次，从而降为 0 并被释放，但攻击者手中仍持有指向该已释放 Chain 的 `r_primitive` 规则。

# 三. 漏洞复现与利用

### 3.1 环境搭建与预处理

*   **权限获取**：使用 `unshare(CLONE_NEWUSER | CLONE_NEWNET)` 获取必要的 `CAP_NET_ADMIN`。
*   **CPU 绑定**：通过 `sched_setaffinity` 将进程绑定到 CPU 0，确保 SLUB 分配器在 Per-CPU 缓存中工作，提高堆喷射稳定性。

### 3.2 第一阶段：泄露堆地址 (Heap Leak)

​	利用 `kmalloc-cg-192` 类型的 `nft_rule` 对象占位被释放的 `nft_chain`。利用 `nft_chain->name` 指针与 `nft_rule->list.next` 指针在内存偏移上的重叠，通过 `NFT_MSG_GETRULE` 泄露堆地址。

### 3.3 第二阶段：绕过 KASLR

​	利用 `nft_table` 的 `udata` 功能在堆上伪造 `nft_chain` 结构体。将伪造结构体的 `name` 指针指向堆上存放 `nft_notrack_ops` 等函数指针的位置，实现任意地址读，从而泄露内核基地址。

### 3.4 第三阶段：劫持 RIP 与 ROP

​	通过 `nft_expr` 的 `ops->deactivate` 函数指针进行劫持。
1.  **Stack Pivot**：使用 JOP Gadget `PUSH RSI; JMP QWORD PTR [RSI + 0xF]` 将 `RSP` 迁移到堆上。
2.  **ROP Chain**：
    *   执行 `commit_creds(prepare_kernel_cred(0))`。
    *   执行 `switch_task_namespaces` 逃逸容器。
    *   利用 `swapgs_restore_regs_and_return_to_usermode` 安全返回。

# 四. 最终 Exploit 结构分析

​	完整的利用程序通过以下核心逻辑串联：

```c
int main() {
    setup(); // 初始化沙箱和CPU绑定
    
    // 1. 触发 UAF 并泄露堆地址
    while (heap < 0xffff000000000000) {
        trigger_uaf(); 
        leak_heap();   
    }

    // 2. 利用 UAF 泄露内核基址
    while (vmlinux < 0xffffffff00000000) {
        leak_vmlinux(); 
    }

    // 3. 部署 ROP 链并触发执行
    spray_krop(); 
    escalate();   // 触发权限提升
}
```

​	该漏洞的成功利用再次证明了 Linux 内核事务处理机制的复杂性及其在边界情况下可能引入的严重安全风险。