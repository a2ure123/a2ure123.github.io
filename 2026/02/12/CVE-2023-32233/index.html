<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="综合描述​	CVE-2023-32233 揭示了 Linux 内核 Netfilter (nf_tables) 子系统中一个关键的 Use-After-Free (UAF) 逻辑缺陷。该漏洞的核心在于内核在处理“匿名集合”（Anonymous Sets）的生命周期时存在设计疏忽。通过构造特定的批处理事务并利用内核处理大量数据时的延迟，攻击者可以在匿名集合仍被规则引用的情况下，诱导内核将其提前释放。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Netfilter 匿名集合 UAF 漏洞 (CVE-2023-32233) 复现与利用分析">
<meta property="og:url" content="http://example.com/2026/02/12/CVE-2023-32233/index.html">
<meta property="og:site_name" content="a2ure&#39;s blog">
<meta property="og:description" content="综合描述​	CVE-2023-32233 揭示了 Linux 内核 Netfilter (nf_tables) 子系统中一个关键的 Use-After-Free (UAF) 逻辑缺陷。该漏洞的核心在于内核在处理“匿名集合”（Anonymous Sets）的生命周期时存在设计疏忽。通过构造特定的批处理事务并利用内核处理大量数据时的延迟，攻击者可以在匿名集合仍被规则引用的情况下，诱导内核将其提前释放。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/vuln-logic-schematic.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/confirm-set-sa.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/watchpoint-ops.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/rhash-elem-content.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/debug-nf-tables-newset.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/watchpoint-memcpy-udata.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/finish-memcpy-udata.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/udata-overlap-confirmed.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/kmalloc-cg-256-chunks.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/rcu-list-insertion-rule.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/leak-nft-counter-ops.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/nft-rule-layout.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-32233/nft-expr-layout.png">
<meta property="article:published_time" content="2026-02-12T03:30:00.000Z">
<meta property="article:modified_time" content="2026-02-12T07:11:24.341Z">
<meta property="article:author" content="a2ure">
<meta property="article:tag" content="Netfilter">
<meta property="article:tag" content="Linux Kernel">
<meta property="article:tag" content="UAF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/CVE-2023-32233/vuln-logic-schematic.png">

<link rel="canonical" href="http://example.com/2026/02/12/CVE-2023-32233/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux Netfilter 匿名集合 UAF 漏洞 (CVE-2023-32233) 复现与利用分析 | a2ure's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">a2ure's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/12/CVE-2023-32233/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux Netfilter 匿名集合 UAF 漏洞 (CVE-2023-32233) 复现与利用分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2026-02-12 11:30:00 / Modified: 15:11:24" itemprop="dateCreated datePublished" datetime="2026-02-12T11:30:00+08:00">2026-02-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CVE/" itemprop="url" rel="index"><span itemprop="name">CVE</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="综合描述"><a href="#综合描述" class="headerlink" title="综合描述"></a>综合描述</h1><p>​	CVE-2023-32233 揭示了 Linux 内核 Netfilter (nf_tables) 子系统中一个关键的 Use-After-Free (UAF) 逻辑缺陷。该漏洞的核心在于内核在处理“匿名集合”（Anonymous Sets）的生命周期时存在设计疏忽。通过构造特定的批处理事务并利用内核处理大量数据时的延迟，攻击者可以在匿名集合仍被规则引用的情况下，诱导内核将其提前释放。利用这一不稳定的内存状态，攻击者可以实现稳定的堆喷射与类型混淆，进而绕过 KASLR 防护并劫持内核控制流。</p>
<h1 id="背景知识介绍"><a href="#背景知识介绍" class="headerlink" title="背景知识介绍"></a>背景知识介绍</h1><h2 id="匿名集合-Anonymous-Sets"><a href="#匿名集合-Anonymous-Sets" class="headerlink" title="匿名集合 (Anonymous Sets)"></a>匿名集合 (Anonymous Sets)</h2><p>​	在 Linux Netfilter 的 <code>nf_tables</code> 框架中，集合（Set）用于存储数据以供规则高效匹配。匿名集合（带有 <code>NFT_SET_ANONYMOUS</code> 标志）通常作为规则中 <code>lookup</code> 等表达式的附属品自动生成。其生命周期理论上应与规则严格绑定：规则创建时增加引用计数，规则删除时减少引用。</p>
<h1 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h1><p>​	漏洞根源于 <code>nf_tables_deactivate_set</code> 函数在事务准备阶段（<code>NFT_TRANS_PREPARE</code>）仅递减了引用计数 <code>set-&gt;use</code>，却未执行解绑（unbind）操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_tables_api.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nf_tables_deactivate_set</span><span class="params">(..., <span class="keyword">enum</span> nft_trans_phase phase)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (phase) &#123;</span><br><span class="line">    <span class="keyword">case</span> NFT_TRANS_PREPARE:</span><br><span class="line">        <span class="built_in">set</span>-&gt;use--; <span class="comment">// 仅递减计数</span></span><br><span class="line">        <span class="keyword">return</span>;     <span class="comment">// 逻辑缺陷：未进行 unbind 便直接返回</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这导致一个计数已归零、逻辑上应销毁的对象依然残留在全局链表中。通过在同一个 Batch 事务中精心编排“删除规则 -&gt; 显式删除集合”的操作序列，可以诱导内核对同一个物理对象执行两次销毁流程，从而将 UAF 演变为 Double Free。</p>
<h1 id="漏洞利用过程详解"><a href="#漏洞利用过程详解" class="headerlink" title="漏洞利用过程详解"></a>漏洞利用过程详解</h1><p>​	CVE-2023-32233 的复现是一场精密的对象生命周期操纵艺术。在深入细节之前，下图展示了整个利用逻辑的核心路径，包括对象释放与抢占的顺序。</p>
<p><img src="/images/CVE-2023-32233/vuln-logic-schematic.png" alt="漏洞利用逻辑示意图"></p>
<p>​	我们通过 <code>exploit.c</code> 将这一艺术转化为稳定的提权原语。</p>
<h2 id="1-基础环境构建与精准堆排布"><a href="#1-基础环境构建与精准堆排布" class="headerlink" title="1. 基础环境构建与精准堆排布"></a>1. 基础环境构建与精准堆排布</h2><p>​	利用的第一步是在内核中构建一个受控的 Netfilter 环境并进行精密的堆内存布局。CVE-2023-32233 的核心矛盾在于：当一个匿名集合（Anonymous Set）被规则引用时，虽然其生命周期应与规则绑定，但攻击者可以通过特定的批处理序列，在规则被标记删除后、集合正式解绑前，利用逻辑缺陷显式地触发集合的删除流程。</p>
<p>​	为了实现这一目标，我们首先通过 <code>pwn_prepare</code> 函数建立 nftables 的逻辑框架。这包括创建一个独立的主表 <code>testfirewall</code>，并在其中定义两个关键链：<code>pwn_lookup_chain</code> (OUTPUT) 用于存放最初引用受害者集合的规则，而 <code>pwn_log_chain</code> (INPUT) 则预留给后续的堆喷射操作。这种分层隔离不仅条理清晰，更确保了漏洞触发过程不会干扰系统的正常网络功能，为后续的内存操作提供了一个稳定的“手术台”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pwn_prepare</span><span class="params">(<span class="keyword">struct</span> mnl_socket *nl)</span> &#123;</span><br><span class="line">    pwn_create_table(batch, seq++); <span class="comment">// 创建实验主表</span></span><br><span class="line">    pwn_create_chain(batch, seq++, pwn_lookup_chain); <span class="comment">// 承载受害者规则</span></span><br><span class="line">    pwn_create_chain(batch, seq++, pwn_log_chain);    <span class="comment">// 用于后续对象喷射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在实际调试过程中，为了验证堆排布的效果并精确定位受害者集合 <code>s_a</code> 的内存地址，我们可以在内核源码的 <code>net/netfilter/nf_tables_api.c:6145</code> 处打入断点。这里的目的是为了观察 <code>elem.priv</code>，它指向了我们目标集合对应的 <code>nft_rhash_elem</code> 内容。通过 GDB 的输出可以看到，此时处理的正是我们预设的目标集合 “s_a”，这证实了基础环境构建的准确性。</p>
<p><img src="/images/CVE-2023-32233/confirm-set-sa.png" alt="目标集合 s_a 的确认"></p>
<p>​	紧随其后的是至关重要的堆整理（Heap Grooming）阶段。为了确保受害者对象落在可预测的内存位置并具备特定的溢出属性，我们执行 <code>pwn_uaf_spray</code> 函数。该函数通过循环喷射大量匿名集合来清理 SLUB 分配器的空闲列表（Freelist），迫使内核向伙伴系统申请全新的 Slab 页面。在这一喷射序列的中段，我们分配受害者集合 <code>s_a</code>（即代码中的 <code>pwn_lookup_set</code>）。此处的一个关键技巧是通过 <code>userdata</code> 将该对象的大小调整为 0x100 字节，使其精确落入 <code>kmalloc-256</code> 缓存池。</p>
<p>​	为了深入观察这个匿名集合在后续 Double Free 过程中的状态变化，我们需要利用硬件断点进行精细监控。通过命令 <code>p &amp;set-&gt;ops</code> 获取 <code>ops</code> 指针格在内存中的绝对地址（例如 <code>0xffff888102bf74c0</code>），随后设置硬件监视点：<code>watch *0xffff888102bf74c0</code>。这样做是因为在触发漏洞时，受害者内存块会被释放并可能被另一个“竞争集合”（Race Set）占领。监控 <code>ops</code> 成员的变化，能够让我们在复杂的事务提交流程中，精准地捕捉到对象被重新占用或二次释放的瞬间。</p>
<p><img src="/images/CVE-2023-32233/watchpoint-ops.png" alt="设置硬件断点监控 ops"></p>
<p>​	环境准备的最后一步是通过 <code>pwn_create_lookup_rule</code> 创建一条引用 <code>s_a</code> 的 <code>lookup</code> 规则。此时，受害者集合 <code>s_a</code> 的引用计数（<code>use</code>）变为 1，它在逻辑上已正式成为规则的一部分。这一步是整个利用链条的“挂钩”点：只有建立了这种引用关系，我们才能在后续的事务处理中，利用 <code>nf_tables_deactivate_set</code> 函数的逻辑缺陷，强行触发对该集合的非法释放，从而打开通往 Use-After-Free 的大门。</p>
<h2 id="2-操控时空：构造执行延迟-Manipulating-Time-The-Delay-Mechanism"><a href="#2-操控时空：构造执行延迟-Manipulating-Time-The-Delay-Mechanism" class="headerlink" title="2. 操控时空：构造执行延迟 (Manipulating Time: The Delay Mechanism)"></a>2. 操控时空：构造执行延迟 (Manipulating Time: The Delay Mechanism)</h2><p>​	单纯的并发竞争往往难以跨越微秒级的内核指令间隙，因此我们需要一种机制来人为地“拉伸”内核的执行时间。在攻击准备阶段，我们通过 <code>pwn_delay_spray_set_elem</code> 函数向一个名为 <code>set_delay</code> 的辅助集合中预先填充了海量元素（数量高达 <code>0x300 * 0x800</code>）。这个庞大的集合就像是一个蓄势待发的“时间锚”。</p>
<p>​	当我们在后续的攻击事务中请求删除这个集合时，内核被迫陷入漫长的内存释放循环中，必须逐个清理这些元素。这个精心构造的“停顿”操作，就像是插入齿轮中的一根撬棍，强行将内核的处理流程卡滞在特定的事务提交阶段。这产生了长达数十毫秒的执行延迟，为用户态的后续操作赢得了宝贵的“子弹时间”，使得原本稍纵即逝的竞争条件变得稳定可控，让我们有足够的时间从容地进行堆内存的抢占与布局。</p>
<h2 id="3-致命一击：触发-Double-Free-与对象重叠-Triggering-Double-Free-Object-Overlap"><a href="#3-致命一击：触发-Double-Free-与对象重叠-Triggering-Double-Free-Object-Overlap" class="headerlink" title="3. 致命一击：触发 Double Free 与对象重叠 (Triggering Double Free &amp; Object Overlap)"></a>3. 致命一击：触发 Double Free 与对象重叠 (Triggering Double Free &amp; Object Overlap)</h2><p>​	万事俱备，利用流程进入了最关键的阶段。在正式触发 Double Free 之前，通过 GDB 调试观察 <code>nft_rhash_elem</code> 的内容，可以进一步确认受害者集合 <code>s_a</code> 的内存排布。如下图所示，<code>elem.priv</code> 准确指向了我们的目标匿名集合记录。</p>
<p><img src="/images/CVE-2023-32233/rhash-elem-content.png" alt="rhash elem 内容确认"></p>
<p>​	接下来的核心挑战在于如何在两次释放的微小间隙中完成内存抢占。我们的策略是：在 <code>s_a</code> 被第一次释放后，立即通过另一个事务创建一个“竞争集合”（Race Set）。这里有一个极其精妙的设计：我们将 <code>race_set</code> 的名称（name）构造为一个大小属于 <code>kmalloc-cg-256</code> 的字符串。由于 <code>s_a</code> 刚刚被释放，内核分配器极大概率会将 <code>race_set-&gt;name</code> 分配到 <code>s_a</code> 原有的内存槽位上。通过在 <code>nf_tables_newset</code> 函数处设置断点，我们可以精准地捕捉到这个覆盖瞬间。</p>
<p><img src="/images/CVE-2023-32233/debug-nf-tables-newset.png" alt="在 nf_tables_newset 处断点拦截"></p>
<p>​	此时原本存放 <code>s_a</code> 结构体的空间已经被 <code>race_set</code> 的名称字符串所覆盖。为了进一步监控这块内存的变化，我们获取 <code>name</code> 的地址（例如 <code>0xffff888102af4f00</code>）并设置硬件监视点：<code>watch *0xffff888102af4f00</code>。当利用程序继续执行 <code>add chain</code> 操作时，这个监视点会被断下，此时正好处于 <code>memcpy</code> 用户数据（udata）到内核空间的时刻。</p>
<p><img src="/images/CVE-2023-32233/watchpoint-memcpy-udata.png" alt="udata 拷贝时的硬件断点命中"></p>
<p>​	执行 <code>finish</code> 结束 <code>memcpy</code> 后，观察内存状态可以清晰地看到原本的 <code>name</code> 字段已经被我们完全可控的 <code>chain-&gt;udata</code> 所填充。</p>
<p><img src="/images/CVE-2023-32233/finish-memcpy-udata.png" alt="memcpy 执行完成后的内存状态"></p>
<p>​	至此，受害者集合 <code>race_set</code> 的 <code>name</code> 指针已经变成了一个指向“幽灵内存”的悬垂指针，且该内存中的数据已被我们占位。</p>
<p><img src="/images/CVE-2023-32233/udata-overlap-confirmed.png" alt="udata 覆盖确认"></p>
<p>​	随后，漏洞逻辑触发了对 <code>s_a</code> 的第二次释放。由于之前的重叠，内核实际上释放的是 <code>race_set-&gt;name</code> 的内存。这就在 <code>kmalloc-cg-256</code> 缓存池中制造了一个空闲槽位。为了引入更具“价值”的对象——<code>nft_rule</code>，我们在这里执行了一个关键的步骤：**主动释放 <code>race_set</code>**。通过调用 <code>pwn_uaf_del_set</code>，内核会显式释放 <code>race_set-&gt;name</code>。由于物理地址重叠，这实际上将 <code>chain-&gt;udata</code> 所在的内存块再次放回了空闲列表。</p>
<p><img src="/images/CVE-2023-32233/kmalloc-cg-256-chunks.png" alt="kmalloc-cg-256 中的内存块状态"></p>
<p>​	接下来的目标是让 <code>nft_rule</code> 对象占领这个空位。由于 <code>nft_rule</code> 及其表达式（如 <code>counter</code>）同样使用该缓存池，我们可以通过喷射规则来触发占位。如下图所示，当内核执行到规则插入 RCU 链表的关键步骤时，新的规则对象已经精准地坐落在之前被释放的内存块上。</p>
<p><img src="/images/CVE-2023-32233/rcu-list-insertion-rule.png" alt="规则对象精准占位"></p>
<p>​	此时，利用进入了信息泄露阶段。通过 <code>NFT_MSG_GETCHAIN</code> 接口读取该链表的 <code>udata</code>，原本存放用户数据的内存中，现在赫然出现了 <code>nft_counter_ops</code> 的指针。通过解析这些数据，我们能够成功提取出这个内核符号地址，从而计算出内核基址（kbase），实现 KASLR 的完美绕过。</p>
<p><img src="/images/CVE-2023-32233/leak-nft-counter-ops.png" alt="泄露出 nft_counter_ops 地址"></p>
<p>​	下图展示了 <code>nft_rule</code> 及其内部 <code>nft_expr</code> 的具体布局，这也正是我们能够通过重叠内存读取到关键指针的原因。</p>
<p><img src="/images/CVE-2023-32233/nft-rule-layout.png" alt="nft_rule 内存结构"><br><img src="/images/CVE-2023-32233/nft-expr-layout.png" alt="nft_expr 内存结构"></p>
<h2 id="4-权力交接：劫持与提权-Precision-Hijack-Root-Shell"><a href="#4-权力交接：劫持与提权-Precision-Hijack-Root-Shell" class="headerlink" title="4. 权力交接：劫持与提权 (Precision Hijack &amp; Root Shell)"></a>4. 权力交接：劫持与提权 (Precision Hijack &amp; Root Shell)</h2><p>​	在成功获取内核基址与堆地址后，利用进入了最后的劫持阶段。这一阶段的核心在于通过再次的对象重叠，在内核中植入一个我们完全控制的“伪造对象”。</p>
<p>​	我们利用泄露的信息，在用户态构造了一个精密的 ROP 链。整个提权逻辑如下：</p>
<ol>
<li><strong>定位 Init 进程</strong>：通过 <code>find_task_by_vpid(1)</code> 获取 init 进程的 <code>task_struct</code> 地址。</li>
<li><strong>逃逸命名空间</strong>：调用 <code>switch_task_namespaces(init_task, &amp;init_nsproxy)</code>，将当前进程的命名空间切换回全局初始命名空间，从而绕过容器或沙箱限制。</li>
<li><strong>获取 Root 权限</strong>：执行 <code>commit_creds(&amp;init_cred)</code>，将当前进程的凭证替换为系统管理员权限。</li>
<li><strong>维持稳定</strong>：最后调用 <code>vfork()</code> 并进入一段长时间的延迟，以确保提权后的环境能够稳定运行。</li>
</ol>
<p>​	为了触发这个 ROP 链，我们利用 <code>pwn_uaf_spray_chain_fake_rule</code> 喷射一组精心构造的 <code>fake_nft_rule</code> 结构体。在这些伪造结构体中，我们篡改了操作钩子（Ops），将其指向一个关键的跳转 Gadget（如 <code>push rax ; pop rsp ; ret</code>），而 <code>rax</code> 此时正好指向我们布置好的 ROP 链。</p>
<p>​	当一切准备就绪，我们只需发起一个 handle 为 <code>0xffff</code> 的删除规则请求。内核在遍历链表并尝试执行删除前的清理逻辑时，会毫无察觉地调用那个被篡改的指针。瞬间，内核栈被劫持到 ROP 链上，提权逻辑在内核态高速执行。随着 <code>win()</code> 函数在用户态被调用，一个具有 root 权限的 Shell 跃然屏上，宣告了这场内核生命周期操纵艺术的最终胜利。</p>
<h1 id="补丁分析与总结"><a href="#补丁分析与总结" class="headerlink" title="补丁分析与总结"></a>补丁分析与总结</h1><p>​	官方补丁通过在 <code>nf_tables_deactivate_set</code> 中增加状态检查，确保了集合在引用计数归零时被正确解绑，从而堵住了这一逻辑漏洞。CVE-2023-32233 的复现过程不仅展示了 Netfilter 子系统中复杂的对象生命周期管理风险，更生动地演绎了如何通过精密的堆风水（Heap Feng Shui）和时间操控（Time Dilation），将一个看似受限的 UAF 漏洞转化为稳定的内核提权利器。这无疑是内核漏洞利用艺术的一次精彩展示。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Netfilter/" rel="tag"># Netfilter</a>
              <a href="/tags/Linux-Kernel/" rel="tag"># Linux Kernel</a>
              <a href="/tags/UAF/" rel="tag"># UAF</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2026/02/07/CVE-2023-4015/" rel="prev" title="Linux Netfilter 提权漏洞 (CVE-2023-4015) 复现与利用分析">
      <i class="fa fa-chevron-left"></i> Linux Netfilter 提权漏洞 (CVE-2023-4015) 复现与利用分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2026/02/12/%E9%95%BF%E5%9F%8E%E6%9D%AFavm%20wp/" rel="next" title="长城杯avm wp">
      长城杯avm wp <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">综合描述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">背景知识介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E9%9B%86%E5%90%88-Anonymous-Sets"><span class="nav-number">2.1.</span> <span class="nav-text">匿名集合 (Anonymous Sets)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">漏洞原理分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">漏洞利用过程详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%B2%BE%E5%87%86%E5%A0%86%E6%8E%92%E5%B8%83"><span class="nav-number">4.1.</span> <span class="nav-text">1. 基础环境构建与精准堆排布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%93%8D%E6%8E%A7%E6%97%B6%E7%A9%BA%EF%BC%9A%E6%9E%84%E9%80%A0%E6%89%A7%E8%A1%8C%E5%BB%B6%E8%BF%9F-Manipulating-Time-The-Delay-Mechanism"><span class="nav-number">4.2.</span> <span class="nav-text">2. 操控时空：构造执行延迟 (Manipulating Time: The Delay Mechanism)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%87%B4%E5%91%BD%E4%B8%80%E5%87%BB%EF%BC%9A%E8%A7%A6%E5%8F%91-Double-Free-%E4%B8%8E%E5%AF%B9%E8%B1%A1%E9%87%8D%E5%8F%A0-Triggering-Double-Free-Object-Overlap"><span class="nav-number">4.3.</span> <span class="nav-text">3. 致命一击：触发 Double Free 与对象重叠 (Triggering Double Free &amp; Object Overlap)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9D%83%E5%8A%9B%E4%BA%A4%E6%8E%A5%EF%BC%9A%E5%8A%AB%E6%8C%81%E4%B8%8E%E6%8F%90%E6%9D%83-Precision-Hijack-Root-Shell"><span class="nav-number">4.4.</span> <span class="nav-text">4. 权力交接：劫持与提权 (Precision Hijack &amp; Root Shell)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">补丁分析与总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">a2ure</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">a2ure</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">29k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:44</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
