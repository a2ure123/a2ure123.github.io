<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="综合描述​	CVE-2023-4015 揭示了 Linux 内核 Netfilter (nf_tables) 子系统中一个极为精妙的逻辑设计缺陷。 该漏洞的核心在于 nf_tables 在处理复杂的 Netlink 批处理事务时，未能正确维护对象在异常回滚过程中的引用状态。具体而言，当攻击者构造一个包含特定 immediate 表达式（用于实现跳转逻辑）的规则，并故意在同一事务中触发后续错误的路径">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Netfilter 提权漏洞 (CVE-2023-4015) 复现与利用分析">
<meta property="og:url" content="http://example.com/2026/02/07/CVE-2023-4015/index.html">
<meta property="og:site_name" content="a2ure&#39;s blog">
<meta property="og:description" content="综合描述​	CVE-2023-4015 揭示了 Linux 内核 Netfilter (nf_tables) 子系统中一个极为精妙的逻辑设计缺陷。 该漏洞的核心在于 nf_tables 在处理复杂的 Netlink 批处理事务时，未能正确维护对象在异常回滚过程中的引用状态。具体而言，当攻击者构造一个包含特定 immediate 表达式（用于实现跳转逻辑）的规则，并故意在同一事务中触发后续错误的路径">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/CVE-2023-4015/netfilter_arch.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-4015/nf_objects_desc.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-4015/nft_transaction.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-4015/gdb_nf_tables_addchain.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-4015/gdb_chain_destroy_1.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-4015/gdb_chain_destroy_2.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-4015/gdb_nft_immediate_dump_1.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-4015/gdb_nft_immediate_dump_2.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-4015/gdb_leak_vmlinux.png">
<meta property="og:image" content="http://example.com/images/CVE-2023-4015/udata_spray_mechanism.png">
<meta property="article:published_time" content="2026-02-07T02:20:00.000Z">
<meta property="article:modified_time" content="2026-02-12T06:54:22.019Z">
<meta property="article:author" content="a2ure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/CVE-2023-4015/netfilter_arch.png">

<link rel="canonical" href="http://example.com/2026/02/07/CVE-2023-4015/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux Netfilter 提权漏洞 (CVE-2023-4015) 复现与利用分析 | a2ure's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">a2ure's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/07/CVE-2023-4015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux Netfilter 提权漏洞 (CVE-2023-4015) 复现与利用分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2026-02-07 10:20:00" itemprop="dateCreated datePublished" datetime="2026-02-07T10:20:00+08:00">2026-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2026-02-12 14:54:22" itemprop="dateModified" datetime="2026-02-12T14:54:22+08:00">2026-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CVE/" itemprop="url" rel="index"><span itemprop="name">CVE</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>19 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="综合描述"><a href="#综合描述" class="headerlink" title="综合描述"></a>综合描述</h1><p>​	CVE-2023-4015 揭示了 Linux 内核 Netfilter (nf_tables) 子系统中一个极为精妙的逻辑设计缺陷。</p>
<p>该漏洞的核心在于 nf_tables 在处理复杂的 Netlink 批处理事务时，未能正确维护对象在异常回滚过程中的引用状态。具体而言，当攻击者构造一个包含特定 immediate 表达式（用于实现跳转逻辑）的规则，并故意在同一事务中触发后续错误的路径时，内核会因为逻辑重叠而对同一个 nft_chain 对象执行两次去激活（Deactivate）操作。这种“双重去激活”直接导致了对象的引用计数（use count）异常归零，从而触发提前释放。</p>
<p>​	由于内核在回滚（Abort）阶段的清理逻辑不够严谨，虽然对象在内存中已被释放回 SLUB 分配器，但先前建立的规则索引中依然保留着指向该内存地址的悬垂指针。这意味着攻击者可以通过后续的堆喷射（Heap Spraying）技术，将恶意构造的数据填入该内存坑位，从而实现类型混淆。在拥有 CAP_NET_ADMIN 权限的前提下（非特权用户可通过用户命名空间轻松获得此权限），该漏洞能够绕过 KASLR 等现代防御机制，最终实现从普通用户到 Root 权限的本地提权。这个漏洞不仅展示了逻辑漏洞在复杂事务模型中的隐蔽性，也再次证明了引用计数管理在内核安全中的关键地位。</p>
<h1 id="背景知识介绍"><a href="#背景知识介绍" class="headerlink" title="背景知识介绍"></a>背景知识介绍</h1><h2 id="Netfilter-核心架构"><a href="#Netfilter-核心架构" class="headerlink" title="Netfilter 核心架构"></a>Netfilter 核心架构</h2><p>​	Netfilter 的 nf_tables 模块构建了一个高度层级化的对象管理体系。其核心对象包括 Table（表）、Chain（链）、Rule（规则）以及 Set（集合）和 Element（元素）。Table 作为最顶层的容器，包含了所有的链；Chain 则是规则的集合，通常与内核协议栈的钩子（Hook）点绑定；Rule 包含了具体的匹配表达式（Expression），负责实际的数据包处理逻辑。Set 和 Element 则提供了一种高效的键值匹配机制，允许规则在不线性遍历的情况下处理大量的 IP 地址或端口。这些对象之间通过引用计数相互链接，例如一个规则引用了一个跳转链，那么该链的引用计数就会增加，只有当所有引用都消失时，对象才能被安全释放。</p>
<p><img src="/images/CVE-2023-4015/netfilter_arch.png" alt="netfilter_arch"></p>
<h2 id="RCU-无锁机制与宽限期检测"><a href="#RCU-无锁机制与宽限期检测" class="headerlink" title="RCU 无锁机制与宽限期检测"></a>RCU 无锁机制与宽限期检测</h2><p>​	在 Linux 内核网络子系统中，为了兼顾高并发下的读取性能与数据一致性，广泛采用了 RCU（Read-Copy-Update）机制。RCU 的核心哲学在于“读者优先”，它允许多个读者在没有任何锁开销的情况下并发访问数据，而写者则通过“复制-修改-更新”的方式进行操作。当写者完成更新并切换全局指针后，旧的数据副本并不能立即释放，因为可能仍有读者正在引用它。此时，旧副本进入所谓的“宽限期”（Grace Period）。</p>
<p>​	内核判断 RCU 读操作结束的标准是基于“静止状态”的检测。通过 <code>rcu_read_lock()</code> 和 <code>rcu_read_unlock()</code> 标记的临界区内禁止发生进程调度。因此，当每一个 CPU 都至少经历了一次上下文切换（Context Switch）或进入了 CPU 空闲状态（Idle），即意味着所有在宽限期开始前进入临界区的读者都已退出了读操作。此时，系统认为该 CPU 度过了一个“静止状态”（Quiescent State）。当全系统所有 CPU 都经历了静止状态，内核便可安全地物理释放旧内存。在 CVE-2023-4015 的利用中，理解这种逻辑释放（引用计数归零）与物理释放（宽限期结束）之间的时间差至关重要。</p>
<p><img src="/images/CVE-2023-4015/nf_objects_desc.png" alt="nf_objects_desc"></p>
<h2 id="nf-tables-事务处理模型"><a href="#nf-tables-事务处理模型" class="headerlink" title="nf_tables 事务处理模型"></a>nf_tables 事务处理模型</h2><p>​	为了保证规则更新的原子性和一致性，nf_tables 引入了基于 Netlink 的批处理事务处理逻辑（nft_trans）。这一机制模仿了数据库的“两阶段提交”：在 Preparation Phase（准备阶段），内核会解析用户发送的 Batch 消息，分配资源并验证参数，此时所有的更改都被记录在事务链表中而未真正生效；如果该阶段通过，则进入 Commit Phase（提交阶段）将更改原子性地应用到全局状态。</p>
<p>​	如果中间任何一步出错，则会触发 Abort Phase（中止阶段），内核将遍历事务链表，按照相反的顺序撤销所有已记录的操作。这种事务处理在内核中是序列化的，通常在进程的上下文中执行，但对象的物理释放往往会延迟到 RCU 回调或特定的系统工作队列（workqueue）中异步完成。这种同步更新状态与异步释放内存的设计，正是 CVE-2023-4015 能够通过并发竞争和逻辑交织制造出 UAF 场景的架构基础。</p>
<p><img src="/images/CVE-2023-4015/nft_transaction.png" alt="nft_transaction"></p>
<h1 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h1><p>​	漏洞的深层诱因源于 <code>nf_tables_newrule</code> 函数在处理新规则创建失败时的错误清理路径，与后续事务中止（Abort）路径之间发生的逻辑碰撞。在内核解析 Netlink 消息创建规则的过程中，如果遇到参数非法或内存不足等错误，系统会立即跳转至错误处理标签 <code>err_release_rule</code>。在此处，内核会显式调用 <code>nft_rule_expr_deactivate</code> 并携带 <code>NFT_TRANS_PREPARE_ERROR</code> 标志，旨在撤销当前规则中已经部分解析的表达式对其他对象的引用。对于 <code>immediate</code> 类型的表达式，这不仅意味着要递减目标跳转链的引用计数，还会通过 <code>nf_tables_unbind_chain</code> 解除该链与当前规则的绑定关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err_release_rule:</span><br><span class="line">  <span class="comment">// 第一次去激活：由 nf_tables_newrule 直接触发</span></span><br><span class="line">  nft_rule_expr_deactivate(&amp;ctx, rule, NFT_TRANS_PREPARE_ERROR);</span><br><span class="line">  nf_tables_rule_destroy(&amp;ctx, rule);</span><br></pre></td></tr></table></figure>

<p>​	然而，由于该事务已经标记为失败，内核在完成局部的错误处理后，仍会不可避免地触发全局的 <code>__nf_tables_abort</code>。在该函数遍历事务链表处理 <code>NFT_MSG_NEWRULE</code> 类型的操作时，逻辑出现了致命偏差。由于目标链在之前的错误处理路径中已经执行了 <code>unbind</code> 操作，导致 <code>nft_trans_rule_bound</code> 的状态检查失效。于是，回滚逻辑会再一次、也是第二次对该规则调用 <code>nft_rule_expr_deactivate</code>，此时的阶段标志被设为 <code>NFT_TRANS_ABORT</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> NFT_MSG_NEWRULE:</span><br><span class="line">  <span class="keyword">if</span> (nft_trans_rule_bound(trans)) &#123; <span class="comment">// 状态位已在 Preparation 错误路径中被污染，导致检查跳过</span></span><br><span class="line">    nft_trans_destroy(trans);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第二次去激活：导致目标 Chain 的引用计数产生 Underflow</span></span><br><span class="line">  nft_rule_expr_deactivate(&amp;trans-&gt;ctx, nft_trans_rule(trans), NFT_TRANS_ABORT);</span><br></pre></td></tr></table></figure>

<p>​	这一系列动作导致目标跳转链（Victim Chain）的引用计数经历了两次连续的递减。如果我们构造一个初始引用计数为 1 的链，并在一次恶意事务中先通过规则引用它再人为制造错误，该链的引用计数会先降至 1（Preparation 报错），随后在 Abort 阶段降至 0。此时内核错误地认为该链已无人使用，从而将其物理释放。然而，我们的 <code>Base</code> 链中依然保留着指向这个已释放地址的规则索引，这就形成了一个稳定的 Use-After-Free 漏洞点。</p>
<h1 id="漏洞利用过程详解"><a href="#漏洞利用过程详解" class="headerlink" title="漏洞利用过程详解"></a>漏洞利用过程详解</h1><h2 id="UAF触发"><a href="#UAF触发" class="headerlink" title="UAF触发"></a>UAF触发</h2><p>​	漏洞利用的第一步，也是最关键的一步，是精确控制目标对象的引用计数，使其在内核逻辑认为“已释放”的同时，我们手中仍持有指向它的有效引用。在 <code>trigger_uaf</code> 函数中，我们通过一系列精心编排的 Netlink 批处理事务（Batch Transactions）来实现这一目标。</p>
<p>​	首先，我们需要在内核中建立三个关键的链：<code>c_free</code>（即 Victim，受害者链）、<code>c_primitive</code>（持有悬垂指针的 Base 链）以及 <code>c_spray</code>（用于后续堆喷射的占位链）。在代码中，我们特别将 <code>c_free</code> 的名称设置为全 ‘A’ 的长字符串，这是为了让它在后续被释放时能够落入特定的 <code>kmalloc-cg-192</code> 缓存池，方便我们进行堆喷射占位。通过第一个 Batch，我们完成了这些对象的创建，并添加了一条规则 <code>r_primitive</code>，让其通过 <code>immediate</code> 表达式引用 <code>c_free</code>。此时，如果我们通过调试器在 <code>nf_tables_addchain</code> 处下断点并观察，可以看到名为 ‘AAAA…’ 的 <code>c_free</code> 链已被成功创建。执行 <code>finish</code> 跳出函数后，可以清晰地观察到该受害链的内存结构信息，包括其地址以及当前的引用计数状态。下图中0xffff888102b3e300地址代表的是对应刚才通过ctx-&gt;chain获得的对应chain的地址，而0xffff888102b05300则是他的name指向的slab的内存区域也就是kmalloc-cg-192里面的地址。</p>
<p><img src="/images/CVE-2023-4015/gdb_nf_tables_addchain.png" alt="gdb_nf_tables_addchain"></p>
<p>​	接下来的操作是漏洞触发的核心。</p>
<p>我们构造了一个包含两条新规则的恶意 Batch。第一条规则 <code>r_effect</code> 被添加到 <code>effect</code> 链中，它再次引用了 <code>c_free</code>。这一步在事务的 Preparation 阶段会将 <code>c_free</code> 的引用计数从 1 增加到 2。紧接着，我们在 <code>attack</code> 链中创建第二条规则 <code>r_attack</code>，它包含两个表达式：第一个引用合法的 <code>effect</code> 链，而第二个表达式则故意引用一个不存在的链 <code>some_invalid_chain</code>。这个不存在的链是整个逻辑陷阱的扳机，它将直接导致当前事务进入错误处理流程。</p>
<p>​	当内核处理这个构造精巧的恶意 Batch 时，逻辑陷阱被成功触发。在处理 <code>r_attack</code> 规则时，由于引用的目标链不存在，内核立即抛出错误并进入 <code>NFT_TRANS_PREPARE_ERROR</code> 阶段。随后，内核开始回滚该 Batch 中已处理的规则，调用 <code>nft_immediate_deactivate</code> 来清理 <code>r_effect</code>。由于我们预先为 <code>c_effect</code> 链设置了 <code>NFT_CHAIN_BINDING</code> 标志，这一操作会触发递归解绑，导致受害者链 <code>c_free</code> 的引用计数从 2 递减至 1。然而，真正的致命一击发生在整个事务最终中止（Abort）的时刻。内核在执行 <code>__nf_tables_abort</code> 逻辑时，会再次遍历事务链表处理 <code>NFT_MSG_NEWRULE</code> 操作。由于先前的解绑逻辑未能在事务状态中留下完整标记，导致状态检查失效，回滚流程对 <code>r_effect</code> 发起了第二次去激活操作。至此，<code>c_free</code> 的引用计数再次递减，彻底归零。</p>
<p>​	为了直观观察这一破坏过程，我们可以利用 GDB 设置条件断点：<code>b nf_tables_chain_destroy if ctx-&gt;chain == 0xffff888102b3e300</code>（地址需根据实际情况调整）。当我们在后续 Batch 中发送删除受害者链的指令时，断点会被触发。通过调试输出可以看到，在 <code>nf_tables_chain_destroy</code> 执行完毕后，原先存储 <code>c_free</code> 对象的内存区域已被破坏，原本清晰的 ‘AAAA…’ 名称指针位置现在充斥着内存回收后的脏数据，这标志着该内存块已正式返回 SLUB 分配器，成为了一个可被喷射占位的 UAF 坑位。</p>
<p><img src="/images/CVE-2023-4015/gdb_chain_destroy_1.png" alt="gdb_chain_destroy_1"></p>
<p><img src="/images/CVE-2023-4015/gdb_chain_destroy_2.png" alt="gdb_chain_destroy_2"></p>
<p>​	现在，<code>c_free</code> 的引用计数已经归零，内核认为它不再被任何规则引用。于是，我们在下一个 Batch 中发送 <code>NFT_MSG_DELCHAIN</code> 命令来删除 <code>c_free</code>。内核执行删除操作后，那个全 ‘A’ 名称的 <code>c_free</code> 链所占用的内存被释放回 <code>kmalloc-cg-192</code> 缓存池。然而，我们在第一阶段创建的 <code>r_primitive</code> 规则依然静静地躺在内核中，它的 <code>immediate</code> 表达式仍然指向那个已经被释放的内存地址。至此，一个完美的 Use-After-Free 漏洞场景构建完成，我们通过 <code>r_primitive</code> 获得了一个通向内核堆内存深处的“后门”。</p>
<h2 id="堆地址泄露-Heap-Leak"><a href="#堆地址泄露-Heap-Leak" class="headerlink" title="堆地址泄露 (Heap Leak)"></a>堆地址泄露 (Heap Leak)</h2><p>​	在成功制造了 UAF 之后，首要任务是泄露内核堆地址，为后续的利用铺平道路。<code>leak_heap</code> 函数的核心思想是利用堆喷射（Heap Spraying）技术，将一种我们可控的内核对象填入刚刚被释放的 <code>c_free</code> 内存坑位中。这里我们选择了 <code>nft_rule</code> 对象，因为它的大小可以通过附加表达式灵活调整，使其正好落入 <code>kmalloc-cg-192</code> 缓存池。</p>
<p>​	<strong>占位与类型混淆</strong><br>​	我们构造了一个包含 <code>notrack</code> 表达式的 <code>nft_rule</code>，并通过大量发送 <code>NFT_MSG_NEWRULE</code> 请求进行喷射。当其中一个 <code>nft_rule</code> 恰好占据了原 <code>c_free</code> 的内存位置时，就发生了关键的类型混淆（Type Confusion）：原 <code>nft_chain</code> 结构体中的 <code>name</code> 指针字段，在内存偏移上恰好与新 <code>nft_rule</code> 结构体中的 <code>list.next</code> 指针重叠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造 payload 使 nft_rule 大小适配 kmalloc-cg-192</span></span><br><span class="line"><span class="type">char</span> data[<span class="number">191</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nft_expr) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nft_rule)] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">rule r = make_rule(current_table_name, <span class="string">&quot;spray&quot;</span>, &amp;e, <span class="number">1</span>, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>);</span><br><span class="line"><span class="comment">// ... 循环发送 batch_new_rule 进行喷射 ...</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>信息泄露路径</strong><br>​	为了读取这个指针，我们向内核发送 <code>NFT_MSG_GETRULE</code> 命令，请求获取那个一直被我们持有的悬垂指针 <code>r_primitive</code>。内核在处理这个请求时，会调用 <code>nft_verdict_dump</code> 来导出规则中的 <code>immediate</code> 表达式信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发信息泄露</span></span><br><span class="line">nlmsghdr hdr = dump_rule(r_primitive, buf);</span><br></pre></td></tr></table></figure>
<p>​	在 <code>nft_verdict_dump</code> 中，内核会试图读取并发送 <code>verdict.chain-&gt;name</code>。由于此时 <code>chain</code> 指针指向的内存已经被我们的 <code>nft_rule</code> 覆盖，内核实际上读取的是 <code>nft_rule-&gt;list.next</code> 的值。</p>
<p>​	为了验证堆喷射是否成功占位，我们可以通过 GDB 在 <code>nft_immediate_dump</code> 函数处设置断点。当执行到泄露逻辑并触发该断点时，观察受害者链的 <code>name</code> 字段可以发现，它已经不再指向原本的名称字符串，而是指向了一块典型的 slab 内存区域。</p>
<p>​	通过进一步解析这块内存，我们可以确认其内部结构完全符合我们喷射的 <code>nft_rule</code> 对象（大小为 192 字节）。利用 GDB 的结构体查看功能，我们可以清晰地看到 <code>nft_rule</code> 的元数据，并且通过对其 <code>extensions</code> 区域的进一步探测，能够识别出我们预埋的 <code>nft_expr</code> 表达式类型。这种内存层面的吻合完美证实了受害者链的 <code>name</code> 指针确实已被我们的恶意规则对象所覆盖，类型混淆已成定局。</p>
<p><img src="/images/CVE-2023-4015/gdb_nft_immediate_dump_1.png" alt="gdb_nft_immediate_dump_1"><br><img src="/images/CVE-2023-4015/gdb_nft_immediate_dump_2.png" alt="gdb_nft_immediate_dump_2"></p>
<p>​	<strong>解析泄露数据</strong><br>​	在用户态的回调函数 <code>dump_expr_leak_heap</code> 中，我们接收并解析这段数据。由于 <code>list.next</code> 指向的是双向链表中的下一个规则（或链表头），我们得到的是一个内核堆地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dump_expr_leak_heap</span><span class="params">(expr e, <span class="type">void</span> *_unused)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">r</span> =</span> (<span class="keyword">struct</span> nft_rule *)data;</span><br><span class="line">    heap = (<span class="type">uint64_t</span>)r-&gt;<span class="built_in">list</span>.next;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	通过这种方式，我们成功将一个内核内部的链表指针作为字符串“偷”了出来。一旦获得这个堆地址，我们就能计算出我们喷射对象的具体位置，从而精准地控制后续的内存布局。这里的list的next也就是上述说的0xffff888102b050c0地址。</p>
<h2 id="绕过-KASLR-Leak-Kernel-Base"><a href="#绕过-KASLR-Leak-Kernel-Base" class="headerlink" title="绕过 KASLR (Leak Kernel Base)"></a>绕过 KASLR (Leak Kernel Base)</h2><p>​	在获取了堆地址后，下一步就是绕过 KASLR（内核地址空间布局随机化）。我们继续利用 <code>c_free</code> 的 UAF 坑位，但这次我们需要更精细的控制。<code>leak_vmlinux</code> 函数展示了如何通过 <code>nft_table</code> 的 <code>udata</code>（用户自定义数据）功能来实施这一攻击。</p>
<p>​	<strong>伪造 nft_chain 结构体</strong><br>​	我们不再喷射 <code>nft_rule</code>，而是喷射带有 <code>udata</code> 的 <code>nft_table</code>。<code>udata</code> 的内容完全由用户态控制，我们将一段伪造的 <code>nft_chain</code> 结构体数据填入其中。当这个 <code>udata</code> 恰好覆盖了原 <code>c_free</code> 的位置时，内核再次访问 <code>c_free</code> 时实际上访问的是我们伪造的数据。</p>
<p>​	<strong>构造任意地址读</strong><br>​	攻击的关键在于伪造链的 <code>name</code> 指针。我们将 <code>fake_chain-&gt;name</code> 指向了堆上的一个特定偏移位置：<code>heap + sizeof(struct nft_rule)</code>。回顾之前的堆喷射，这个位置正好存放着 <code>nft_rule</code> 内部的 <code>nft_expr</code>（表达式）结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 name 指针指向 nft_rule 之后，即 nft_expr 的起始位置</span></span><br><span class="line">fake_chain-&gt;name = (<span class="type">char</span> *)(heap + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nft_rule));</span><br></pre></td></tr></table></figure>

<p>​	而 <code>nft_expr</code> 结构体的第一个成员正是 <code>ops</code> 指针（指向 <code>nft_expr_ops</code>，如 <code>nft_notrack_ops</code>）。这个 <code>ops</code> 指针位于内核代码段（.text），是一个固定的内核符号地址。通过调试器观察，我们可以清晰地看到伪造的 <code>chain</code> 结构体已经成功占据了内存，且其 <code>name</code> 指针准确地指向了 <code>nft_expr</code> 的起始地址。</p>
<p>​	<strong>泄露 ops 指针</strong></p>
<p><img src="/images/CVE-2023-4015/gdb_leak_vmlinux.png" alt="gdb_leak_vmlinux"></p>
<p>​	当我们再次触发 <code>NFT_MSG_GETRULE</code> 进行 dump 时，内核会顺着这个伪造的 <code>name</code> 指针去读取字符串。结果，它把位于该地址的 <code>nft_notrack_ops</code> 内核函数地址当作字符串读取并发送给了我们。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dump_expr_leak_vmlinux</span><span class="params">(expr e, <span class="type">void</span> *dat)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);</span><br><span class="line">    <span class="comment">// 直接读取前8字节作为内核地址</span></span><br><span class="line">    vmlinux = *(<span class="type">uint64_t</span> *)data;</span><br><span class="line">    <span class="comment">// 计算内核基址</span></span><br><span class="line">    <span class="keyword">if</span> (vmlinux &gt;= <span class="number">0xffffffff00000000</span>) &#123;</span><br><span class="line">        vmlinux -= NFT_NOTRACK_OPS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	通过计算泄露出的 <code>ops</code> 地址与已知的 <code>NFT_NOTRACK_OPS</code> 偏移，我们即可精准计算出内核基址 <code>vmlinux_base</code>，从而彻底击败 KASLR 保护。</p>
<h2 id="劫持-RIP：udata-喷射的“偷梁换柱”"><a href="#劫持-RIP：udata-喷射的“偷梁换柱”" class="headerlink" title="劫持 RIP：udata 喷射的“偷梁换柱”"></a>劫持 RIP：udata 喷射的“偷梁换柱”</h2><p>​	在之前的堆地址泄露阶段，我们使用了 <code>nft_rule</code> 对象来占位，那是为了利用其内部合法的链表指针。然而，在最终的劫持阶段，我们需要对内存内容拥有<strong>字节级</strong>的完全控制权，特别是要精确伪造 <code>ops</code> 指针。合法的 <code>nft_rule</code> 结构受内核逻辑限制，许多字段无法被用户态随意修改。因此，我们在这里采用了一种更为底层的喷射技术——**<code>nft_table</code> 的 <code>udata</code>（用户定义数据）喷射**。</p>
<p>​	<code>udata</code> 的核心特性在于其“透传”性：内核会将用户提供的数据原封不动地 <code>memcpy</code> 到堆内存中。这就给了我们实施“偷梁换柱”的绝佳机会。我们不再依赖内核去构造对象，而是在用户态直接构造一个包含恶意 <code>ops</code> 指针的“伪造数据包”，然后利用 <code>udata</code> 机制将其注入到内核堆中。</p>
<p><img src="/images/CVE-2023-4015/udata_spray_mechanism.png" alt="udata_spray_mechanism"></p>
<p>​	<strong>用户态构造 payload</strong><br>​	我们在用户态定义一个与 UAF 坑位大小匹配的数组（如 192 字节），并将其强制转换为 <code>nft_rule</code> 和 <code>nft_expr</code> 的结构体指针。注意，此时这些操作完全在用户态内存中进行。我们计算出 <code>ops</code> 指针在结构体中的偏移，并将计算好的恶意地址（指向我们的 JOP Gadget）直接写入该位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 在本地准备伪造数据</span></span><br><span class="line"><span class="type">char</span> data[<span class="number">192</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">fake_rule</span> =</span> (<span class="keyword">struct</span> nft_rule *)data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">fake_expr</span> =</span> (<span class="keyword">struct</span> nft_expr *)(data + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nft_rule));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将恶意的 ops 指针写入本地数组</span></span><br><span class="line">fake_expr-&gt;ops = (<span class="keyword">struct</span> nft_expr_ops *)(heap + JOP_OFFSET - DEACTIVATE_OFFSET);</span><br></pre></td></tr></table></figure>

<p>​	<strong>内核态堆喷射</strong><br>​	随后，我们调用 <code>make_table</code> 并将这个精心构造的 <code>data</code> 数组作为 <code>udata</code> 传入。内核在处理 <code>NFT_MSG_NEWTABLE</code> 请求时，会申请一块与 <code>data</code> 大小相同的内存。由于其大小恰好也是 192 字节，SLUB 分配器极大概率会将刚刚释放的 UAF 坑位分配给它。紧接着，内核执行内存拷贝，将包含恶意 <code>ops</code> 指针的 <code>data</code> 数据完整地写入这块内核内存。</p>
<p>​	<strong>最终触发</strong><br>​	当内核随后尝试通过悬垂指针访问这个对象并调用 <code>deactivate</code> 时，它会读取到我们通过 <code>udata</code> 注入的恶意 <code>ops</code> 指针，从而跳转执行 JOP Gadget，开启 ROP 之旅。</p>
<p>​	<strong>ROP 载荷构造</strong><br>​	由于单个 <code>udata</code> 或规则数据区的空间限制，我们将 ROP 链拆分为两部分。第一段载荷利用 <code>PUSH RSI; JMP QWORD PTR [RSI + 0xF]</code> 指令配合栈迁移 gadget，将 <code>RSP</code> 指向我们的堆区。随后的 ROP 链执行标准的提权流程：</p>
<ol>
<li><strong>提权</strong>：调用 <code>commit_creds(prepare_kernel_cred(0))</code> 将当前进程凭证提升为 Root。</li>
<li><strong>逃逸</strong>：调用 <code>find_task_by_vpid(1)</code> 获取 init 进程，并通过 <code>switch_task_namespaces</code> 切换命名空间以逃逸容器。</li>
<li><strong>返回</strong>：利用 KPTI 跳板（trampoline）安全返回用户态，执行 <code>system(&quot;/bin/bash&quot;)</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commit_creds(&amp;init_cred)</span></span><br><span class="line">*rop++ = vmlinux + POP_RDI_RET;</span><br><span class="line">*rop++ = vmlinux + INIT_CRED;</span><br><span class="line">*rop++ = vmlinux + COMMIT_CREDS;</span><br><span class="line"><span class="comment">// ... 命名空间切换与返回用户态 ...</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​	CVE-2023-4015 的复现过程展示了内核利用的艺术：一个微小的事务回滚逻辑缺陷，通过精密的堆布局控制与类型混淆，一步步转化为任意读写，最终实现完全的权限提升。这不仅是对 Netfilter 复杂性的警示，也是对内核开发者在处理原子操作与对象生命周期时必须保持极度严谨的有力证明。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2026/02/07/AliyunCTF--Alimem/" rel="prev" title="AliyunCTF--Alimem">
      <i class="fa fa-chevron-left"></i> AliyunCTF--Alimem
    </a></div>
      <div class="post-nav-item">
    <a href="/2026/02/12/CVE-2023-32233/" rel="next" title="Linux Netfilter 匿名集合 UAF 漏洞 (CVE-2023-32233) 复现与利用分析">
      Linux Netfilter 匿名集合 UAF 漏洞 (CVE-2023-32233) 复现与利用分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">综合描述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">背景知识介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Netfilter-%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">Netfilter 核心架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RCU-%E6%97%A0%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%BD%E9%99%90%E6%9C%9F%E6%A3%80%E6%B5%8B"><span class="nav-number">2.2.</span> <span class="nav-text">RCU 无锁机制与宽限期检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nf-tables-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">nf_tables 事务处理模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">漏洞原理分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">漏洞利用过程详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UAF%E8%A7%A6%E5%8F%91"><span class="nav-number">4.1.</span> <span class="nav-text">UAF触发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%9C%B0%E5%9D%80%E6%B3%84%E9%9C%B2-Heap-Leak"><span class="nav-number">4.2.</span> <span class="nav-text">堆地址泄露 (Heap Leak)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%95%E8%BF%87-KASLR-Leak-Kernel-Base"><span class="nav-number">4.3.</span> <span class="nav-text">绕过 KASLR (Leak Kernel Base)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%AB%E6%8C%81-RIP%EF%BC%9Audata-%E5%96%B7%E5%B0%84%E7%9A%84%E2%80%9C%E5%81%B7%E6%A2%81%E6%8D%A2%E6%9F%B1%E2%80%9D"><span class="nav-number">4.4.</span> <span class="nav-text">劫持 RIP：udata 喷射的“偷梁换柱”</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">a2ure</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">a2ure</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">29k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:44</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
